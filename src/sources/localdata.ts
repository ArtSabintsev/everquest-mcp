// Local EverQuest game data parser
// Reads data directly from installed EQ game files for authoritative, offline lookups

import { readFile, readdir, writeFile, stat } from 'fs/promises';
import { join } from 'path';
import { existsSync } from 'fs';
import { createHash } from 'crypto';
import { SearchResult, SpellData, ZoneData, fuzzyMatch, normalizeQuery } from './base.js';

// ============ CONFIGURATION ============

const DEFAULT_EQ_PATH = '/Users/arthur/Library/Application Support/CrossOver/Bottles/EverQuest/drive_c/users/Public/Daybreak Game Company/Installed Games/EverQuest';
const EQ_GAME_PATH = process.env.EQ_GAME_PATH || DEFAULT_EQ_PATH;

// ============ CLASS MAPPING ============

const CLASS_IDS: Record<number, string> = {
  1: 'Warrior', 2: 'Cleric', 3: 'Paladin', 4: 'Ranger',
  5: 'Shadow Knight', 6: 'Druid', 7: 'Monk', 8: 'Bard',
  9: 'Rogue', 10: 'Shaman', 11: 'Necromancer', 12: 'Wizard',
  13: 'Magician', 14: 'Enchanter', 15: 'Beastlord', 16: 'Berserker',
};

const CLASS_SHORT: Record<number, string> = {
  1: 'WAR', 2: 'CLR', 3: 'PAL', 4: 'RNG', 5: 'SHD', 6: 'DRU',
  7: 'MNK', 8: 'BRD', 9: 'ROG', 10: 'SHM', 11: 'NEC', 12: 'WIZ',
  13: 'MAG', 14: 'ENC', 15: 'BST', 16: 'BER',
};

// ============ RACE MAPPING ============

const RACE_IDS: Record<number, string> = {
  1: 'Human', 2: 'Barbarian', 3: 'Erudite', 4: 'Wood Elf',
  5: 'High Elf', 6: 'Dark Elf', 7: 'Half Elf', 8: 'Dwarf',
  9: 'Troll', 10: 'Ogre', 11: 'Halfling', 12: 'Gnome',
  128: 'Iksar', 130: 'Vah Shir', 330: 'Froglok', 522: 'Drakkin',
};

// Race-class availability (which classes each race can play)
const RACE_CLASSES: Record<number, number[]> = {
  1:   [1,2,3,4,5,6,7,8,9,11,12,13,14],       // Human
  2:   [1,9,10,15,16],                          // Barbarian
  3:   [2,3,5,11,12,13,14],                     // Erudite
  4:   [1,4,6,8,9,15],                          // Wood Elf
  5:   [2,3,12,13,14],                          // High Elf
  6:   [1,2,5,9,11,12,13,14],                   // Dark Elf
  7:   [1,3,4,6,8,9],                           // Half Elf
  8:   [1,2,3,9,16],                            // Dwarf
  9:   [1,5,10,15,16],                          // Troll
  10:  [1,5,10,15,16],                          // Ogre
  11:  [1,2,3,4,6,9],                           // Halfling
  12:  [1,2,3,5,9,11,12,13,14],                 // Gnome
  128: [1,5,7,10,11,15],                        // Iksar
  130: [1,8,9,10,15,16],                        // Vah Shir
  330: [1,2,3,5,9,11,12],                       // Froglok
  522: [1,2,3,4,5,6,7,8,9,11,12,13,14],         // Drakkin
};

// Reverse lookup: name -> ID
const CLASS_NAME_TO_ID: Record<string, number> = {};
for (const [id, name] of Object.entries(CLASS_IDS)) {
  CLASS_NAME_TO_ID[name.toLowerCase()] = parseInt(id);
}
for (const [id, short] of Object.entries(CLASS_SHORT)) {
  CLASS_NAME_TO_ID[short.toLowerCase()] = parseInt(id);
}

const RACE_NAME_TO_ID: Record<string, number> = {};
for (const [id, name] of Object.entries(RACE_IDS)) {
  RACE_NAME_TO_ID[name.toLowerCase()] = parseInt(id);
}
// Common aliases
RACE_NAME_TO_ID['de'] = 6;
RACE_NAME_TO_ID['he'] = 5;
RACE_NAME_TO_ID['we'] = 4;
RACE_NAME_TO_ID['hef'] = 7;

// Faction modifier IDs for playable races (from dbstr type 45)
const PLAYABLE_RACE_MODIFIER_IDS = new Set([
  51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, // Human through Gnome
  178, // Iksar
  180, // Vah Shir
  661, // Froglok (Guktan)
  1106, // Drakkin
]);

// Map playable race names to faction modifier IDs
const RACE_TO_FACTION_MODIFIER: Record<string, number> = {
  'human': 51, 'barbarian': 52, 'erudite': 53, 'wood elf': 54,
  'high elf': 55, 'dark elf': 56, 'half elf': 57, 'dwarf': 58,
  'troll': 59, 'ogre': 60, 'halfling': 61, 'gnome': 62,
  'iksar': 178, 'vah shir': 180, 'froglok': 661, 'drakkin': 1106,
  // Short aliases
  'de': 56, 'he': 55, 'we': 54, 'hef': 57,
};

// Map deity names to faction modifier IDs (from dbstr type 45)
const DEITY_TO_FACTION_MODIFIER: Record<string, number> = {
  'bertoxxulous': 201, 'brell serilis': 202, 'brell': 202,
  'cazic-thule': 203, 'cazic thule': 203, 'cazic': 203,
  'erollisi marr': 204, 'erollisi': 204,
  'bristlebane': 205, 'fizzlethorp': 205,
  'innoruuk': 206, 'karana': 207,
  'mithaniel marr': 208, 'mithaniel': 208,
  'prexus': 209, 'quellious': 210,
  'rallos zek': 211, 'rallos': 211,
  'rodcet nife': 212, 'rodcet': 212,
  'solusek ro': 213, 'solusek': 213,
  'the tribunal': 214, 'tribunal': 214,
  'tunare': 215, 'veeshan': 216,
  'agnostic': 396,
};

const DEITY_MODIFIER_IDS = new Set(Object.values(DEITY_TO_FACTION_MODIFIER));

// Race starting base stats: [STR, STA, AGI, DEX, WIS, INT, CHA]
const RACE_BASE_STATS: Record<number, number[]> = {
  1:   [75, 75, 75, 75, 75, 75, 75],       // Human
  2:   [103, 95, 82, 70, 70, 60, 55],       // Barbarian
  3:   [60, 70, 70, 70, 83, 107, 70],       // Erudite
  4:   [65, 65, 95, 80, 80, 75, 75],        // Wood Elf
  5:   [55, 65, 85, 70, 95, 92, 80],        // High Elf
  6:   [60, 65, 90, 75, 83, 99, 60],        // Dark Elf
  7:   [70, 70, 90, 85, 60, 75, 75],        // Half Elf
  8:   [90, 90, 70, 90, 83, 60, 45],        // Dwarf
  9:   [108, 109, 83, 75, 60, 52, 40],      // Troll
  10:  [130, 127, 70, 70, 67, 60, 37],      // Ogre
  11:  [70, 75, 95, 90, 80, 67, 50],        // Halfling
  12:  [60, 70, 85, 85, 67, 98, 60],        // Gnome
  128: [70, 70, 90, 85, 80, 75, 55],        // Iksar
  130: [90, 75, 90, 70, 70, 65, 65],        // Vah Shir
  330: [70, 80, 100, 100, 75, 75, 50],      // Froglok
  522: [70, 80, 85, 75, 80, 85, 75],        // Drakkin
};
const STAT_NAMES = ['STR', 'STA', 'AGI', 'DEX', 'WIS', 'INT', 'CHA'];

// Race -> starting city dbstr type 15 IDs
const RACE_STARTING_CITY_IDS: Record<number, number[]> = {
  1: [1, 382],      // Human: Qeynos, Freeport
  2: [29],           // Barbarian: Halas
  3: [23],           // Erudite: Erudin/Paineel
  4: [54],           // Wood Elf: Kelethin
  5: [61],           // High Elf: Felwithe
  6: [40],           // Dark Elf: Neriak
  7: [382, 3],       // Half Elf: Freeport, Surefall Glade
  8: [60],           // Dwarf: Kaladim
  9: [52],           // Troll: Grobb
  10: [49],          // Ogre: Oggok
  11: [19],          // Halfling: Rivervale
  12: [55],          // Gnome: Ak'Anon
  128: [82],         // Iksar: Cabilis
  130: [155],        // Vah Shir: Shar Vahl
  330: [50],         // Froglok: Gukta
  522: [394],        // Drakkin: Crescent Reach
};

// Deity data from eqstr_us.txt (IDs 3250-3266)
const DEITY_IDS: Record<number, number> = {
  3250: 0, 3251: 201, 3252: 202, 3253: 203, 3254: 206,
  3255: 207, 3256: 204, 3257: 205, 3258: 208, 3259: 209,
  3260: 210, 3261: 213, 3262: 211, 3263: 214, 3264: 215,
  3265: 216, 3266: 212,
};

// Race-deity availability
const RACE_DEITIES: Record<number, string[]> = {
  1:   ['Agnostic', 'Bertoxxulous', 'Bristlebane', 'Cazic-Thule', 'Erollisi Marr', 'Innoruuk', 'Karana', 'Mithaniel Marr', 'Prexus', 'Quellious', 'Rallos Zek', 'Rodcet Nife', 'Solusek Ro', 'The Tribunal', 'Tunare'],
  2:   ['Agnostic', 'Bristlebane', 'Rallos Zek', 'The Tribunal', 'Tunare'],
  3:   ['Agnostic', 'Bristlebane', 'Cazic-Thule', 'Prexus', 'Quellious', 'Solusek Ro'],
  4:   ['Agnostic', 'Bristlebane', 'Karana', 'Tunare'],
  5:   ['Agnostic', 'Karana', 'Mithaniel Marr', 'Tunare'],
  6:   ['Agnostic', 'Cazic-Thule', 'Innoruuk', 'Solusek Ro'],
  7:   ['Agnostic', 'Bristlebane', 'Karana', 'Tunare'],
  8:   ['Agnostic', 'Bertoxxulous', 'Brell Serilis', 'Bristlebane', 'Innoruuk', 'The Tribunal', 'Tunare'],
  9:   ['Agnostic', 'Cazic-Thule', 'Innoruuk', 'Rallos Zek'],
  10:  ['Agnostic', 'Cazic-Thule', 'Rallos Zek'],
  11:  ['Agnostic', 'Brell Serilis', 'Bristlebane', 'Karana'],
  12:  ['Agnostic', 'Bertoxxulous', 'Brell Serilis', 'Bristlebane', 'Solusek Ro'],
  128: ['Cazic-Thule'],
  130: ['Agnostic', 'The Tribunal'],
  330: ['Mithaniel Marr'],
  522: ['Agnostic', 'Bertoxxulous', 'Bristlebane', 'Cazic-Thule', 'Erollisi Marr', 'Innoruuk', 'Karana', 'Mithaniel Marr', 'Prexus', 'Quellious', 'Rallos Zek', 'Rodcet Nife', 'Solusek Ro', 'The Tribunal', 'Tunare', 'Veeshan'],
};

// ============ SPELL FIELD INDICES ============

// spells_us.txt is caret-delimited with 150+ fields per spell line
const SF = {
  ID: 0,
  NAME: 1,
  TELEPORT_ZONE: 3,
  RANGE: 4,
  AE_RANGE: 5,
  PUSH_BACK: 6,
  PUSH_UP: 7,
  CAST_TIME: 8,       // milliseconds
  RECOVERY_TIME: 9,   // milliseconds
  RECAST_TIME: 10,    // milliseconds
  DURATION_FORMULA: 11,
  DURATION_VALUE: 12,
  AE_DURATION: 13,
  MANA: 14,
  BENEFICIAL: 28,      // 1=beneficial, 0=detrimental
  RESIST_TYPE: 29,
  TARGET_TYPE: 30,
  // Class levels (fields 36-51): 255 = cannot use, else = minimum level
  CLASS_LEVEL_START: 36,
  CLASS_LEVEL_END: 51,
  // Class order: WAR(36), CLR(37), PAL(38), RNG(39), SHD(40), DRU(41),
  //              MNK(42), BRD(43), ROG(44), SHM(45), NEC(46), WIZ(47),
  //              MAG(48), ENC(49), BST(50), BER(51)
  RECOURSE: 81,     // Recourse spell ID (spell cast on caster when landing on target)
  CATEGORY: 87,     // Spell category ID (maps to dbstr type 5)
  SUBCATEGORY: 88,  // Spell subcategory ID (maps to dbstr type 5)
  ENDURANCE: 96,    // Endurance cost (melee/hybrid combat abilities)
  TIMER_ID: 97,     // Reuse timer group (0 = default spell gem, >0 = shared timer)
};

// ============ LOOKUP TABLES ============

const TARGET_TYPES: Record<number, string> = {
  1: 'Line of Sight', 2: 'AE (PC v1)', 3: 'Group v1', 4: 'PB AE',
  5: 'Single', 6: 'Self', 8: 'Targeted AE', 9: 'Animal', 10: 'Undead',
  13: 'Lifetap', 14: 'Pet', 15: 'Corpse', 36: 'Free Target',
  40: 'AE (PC v2)', 41: 'Group v2', 42: 'Directional AE', 44: 'Beam',
  46: 'Target Ring AE',
};

const RESIST_TYPES: Record<number, string> = {
  0: 'Unresistable', 1: 'Magic', 2: 'Fire', 3: 'Cold',
  4: 'Poison', 5: 'Disease', 6: 'Chromatic', 7: 'Prismatic',
  8: 'Physical', 9: 'Corruption',
};

const SPA_NAMES: Record<number, string> = {
  0: 'HP', 1: 'AC', 2: 'ATK', 3: 'Movement Speed',
  4: 'STR', 5: 'DEX', 6: 'AGI', 7: 'STA', 8: 'INT', 9: 'WIS', 10: 'CHA',
  11: 'Melee Haste', 12: 'Invisibility', 13: 'See Invisible',
  14: 'Water Breathing', 15: 'Mana', 16: 'NPC Enchant Immunity',
  17: 'Food/Water', 18: 'Pacify', 19: 'Faction',
  20: 'Blind', 21: 'Stun', 22: 'Charm', 23: 'Fear', 24: 'Stamina/Endurance',
  25: 'Bind Affinity', 26: 'Gate', 27: 'NPC Frenzy',
  28: 'Ultravision', 29: 'Infravision', 30: 'Identify',
  31: 'Snare', 32: 'Summon Item', 33: 'Summon Pet', 34: 'HP Regen',
  35: 'Mana Regen', 36: 'Dispel Magic', 37: 'NPC Buff',
  38: 'Shadow Step', 39: 'Berserk', 40: 'Lycanthropy',
  41: 'Vampirism', 42: 'Fire Resist (Mirrored)', 43: 'Transport',
  44: 'Antigate', 45: 'Summon BST Pet',
  46: 'Fire Resist', 47: 'Cold Resist',
  48: 'Poison Resist', 49: 'Disease Resist', 50: 'Magic Resist',
  51: 'Detect Undead', 52: 'Detect Summoned', 53: 'Detect Animals',
  54: 'Stoneskin', 55: 'Damage Absorb', 56: 'True North',
  57: 'Levitate', 58: 'Spin Stun', 59: 'Infravision',
  60: 'Undead Spell Resist', 61: 'Summoned Spell Resist',
  62: 'Animal Spell Resist', 63: 'Absorb Magic Damage',
  64: 'Sense Traps', 65: 'Disarm Traps', 66: 'Divination',
  67: 'Destroy Undead', 68: 'Feign Death',
  69: 'Max HP', 70: 'NPC Cannotmiss', 71: 'Gate',
  72: 'Summon Skeleton Pet', 73: 'Bind Sight', 74: 'Mesmerize',
  75: 'NPC Target', 76: 'Calm', 77: 'Dispel Detrimental',
  78: 'Shadowstep', 79: 'HP Limit',
  80: 'Resurrection', 81: 'Summon Player', 82: 'Teleport Zone',
  83: 'Throw Skill', 84: 'Restrict Spell School',
  85: 'Spell Proc', 86: 'Illusion', 87: 'Damage Shield',
  88: 'Transfer Mana', 89: 'Add Reverse DS',
  90: 'Spell Casting Level', 91: 'Summon Corpse',
  92: 'Adjust Aggro', 93: 'Resist Adj', 94: 'Spin Target',
  95: 'Amnesia', 96: 'Intoxication', 97: 'Spell Shield',
  98: 'Reduce Target HP %', 99: 'Mental Stamina',
  100: 'Teleport', 101: 'HP Change', 102: 'Stacking: Command',
  103: 'Stacking: Overwrite', 104: 'Max HP Change',
  105: 'Pet Shield', 106: 'Max Mana Change', 107: 'Endurance',
  108: 'Endurance Regen', 109: 'Familiarize', 110: 'Add Stun Resist',
  111: 'Reverse Damage Shield', 112: 'Screech', 113: 'Improved Spell Range',
  114: 'Aggro', 115: 'Mana/HP Return', 116: 'Curse',
  117: 'Make Vulnerable', 118: 'Timer Lockout',
  119: 'Melee Proc', 120: 'Range Proc', 121: 'Illusion: Other',
  122: 'Mass Group Buff', 123: 'Group Fear Immunity', 124: 'Rampage',
  125: 'AE Taunt', 126: 'Flesh to Bone', 127: 'Spell Haste',
  128: 'Spell Duration Increase', 129: 'Spell Duration Decrease',
  130: 'Strikethrough', 131: 'Stun Resist',
  132: 'Mitigate Melee Damage', 133: 'Mitigate Spell Damage',
  134: 'Shielding', 135: 'Revenge Spell', 136: 'Skill Damage',
  137: 'Endurance Regen', 138: 'Taunt', 139: 'Proc Rate Modifier',
  140: 'Twincast Chance', 141: 'NPC Assist Radius',
  142: 'Melee AE Range', 143: 'NPC Maxrange', 144: 'HP Regen Per Tick',
  145: 'Cure Corruption', 146: 'Corruption Resist',
  147: 'Slow', 148: 'Stacking Block', 149: 'Strip Buffs',
  150: 'Song DoT', 151: 'Song DoT2', 152: 'Shielding Duration',
  153: 'Shrink', 154: 'Gate Disabled',
  158: 'Hate', 159: 'Weather Control', 160: 'Fragile',
  161: 'Sacrifice', 162: 'Silence', 163: 'Max Mana',
  164: 'Bard AE DoT', 165: 'Max Endurance',
  167: 'Pet Haste', 168: 'Decrease Chance to Land',
  169: 'Crit HoT', 170: 'Absorb Rune', 171: 'AC Soft Cap',
  172: 'Corruption', 173: 'Primary Melee Double',
  174: 'Skill Damage Mod', 175: 'Skill Damage Mod2',
  176: 'Parry Chance', 177: 'Dodge Chance', 178: 'Riposte Chance',
  179: 'Absorb Damage', 180: 'Pet Crit Melee', 181: 'Pet Crit Spell',
  182: 'Pet Max HP', 183: 'Pet Avoidance', 184: 'Accuracy',
  185: 'Headshot', 186: 'Pet Crit Melee2', 187: 'Slay Undead',
  188: 'Increase Skill Damage', 189: 'Double Riposte',
  190: 'AE Stun Resist', 191: 'Stun Resist',
  192: 'Frontal Backstab Chance', 193: 'Chaotic Stab',
  194: 'Shield Block Chance', 195: 'Shroud of Stealth',
  196: 'Extended Pet Duration', 197: 'Pet Power Increase',
  198: 'Backstab from Front', 199: 'Chaotic Stab',
  200: 'Spell Crit Chance', 201: 'Shield Bash Stun',
  202: 'Melee Crit Chance', 203: 'Spell Crit Damage',
  204: 'Dodge Chance', 205: 'Mend Companion',
  206: 'Doppelganger', 207: 'Archery Damage Mod',
  208: 'Offhand Damage Mod', 209: 'Pet Melee Crit Damage',
  210: 'Triple Backstab', 211: 'Combat Stability',
  212: 'Add Singing Mod', 213: 'Song Mod Cap',
  214: 'Increase Trap Count', 215: 'Change Padder',
  216: 'Increase Archery', 217: 'Increase Singing',
  218: 'DoT Damage', 219: 'Heal Amount', 220: 'Heal Amount2',
  221: 'Nuke Damage', 222: 'All Avoidance',
  225: 'Pet Discipline', 226: 'Limit: Detrimental',
  227: 'Limit: Beneficial', 228: 'Limit: Spell Type',
  229: 'Limit: Min Mana', 230: 'Limit: Spell Class',
  231: 'Limit: Spell Subclass', 232: 'Limit: Combat Skills',
  233: 'Limit: Non-Combat Skills',
  250: 'Increase Damage', 251: 'Manaburn', 252: 'Endurance Burn',
  253: 'Limit: Spell Group',
  254: 'Placeholder',
  255: 'Triple Attack', 256: 'Spell Proc',
  258: 'Sympathetic Proc', 259: 'Raise Stats Cap',
  260: 'Reduce Timer Special', 261: 'No Break AE Sneak',
  262: 'Spell Slots', 263: 'Buff Slots', 264: 'Max Negative HP',
  265: 'DeathSave', 266: 'HP Regen from Spells',
  267: 'Mana Regen from Spells', 268: 'Endurance Regen from Spells',
  269: 'Max HP Mod', 270: 'Max Mana Mod',
  271: 'Max Endurance Mod', 272: 'AC vs Type',
  273: 'Max HP', 274: 'Max Mana', 275: 'Max Endurance',
  276: 'Pet Flurry', 277: 'Pet Crit', 278: 'Shield Specialist',
  279: 'Accuracy Mod', 280: 'Headshot Damage', 281: 'Assassinate Damage',
  282: 'Finishing Blow Damage',
  286: 'Limit: Min Level', 287: 'Limit: Max Level',
  288: 'Limit: Cast Time', 289: 'Improved Spell Effect',
  290: 'Limit: Spell', 291: 'Limit: Min Duration', 292: 'Limit: Effect',
  293: 'Limit: Combat Skills', 294: 'Limit: Target',
  295: 'Limit: Mana Min', 296: 'Limit: Mana Max',
  297: 'Skill Attack', 298: 'Skill Accuracy Mod',
  299: 'Change Height', 300: 'Wakethe Dead', 301: 'Doppelganger',
  302: 'Archery Damage', 303: 'Secondary Bash',
  304: 'Spell Damage Shield', 305: 'Reduce Weight', 306: 'Alchemist Mastery',
  307: 'Block Behind', 308: 'Double Melee Round',
  309: 'Limit: Mana Max', 310: 'Limit: Mana Min',
  311: 'Limit: Max Level', 312: 'Limit: Resist Min',
  313: 'Limit: Resist Max', 314: 'Cast if Cursed',
  315: 'Cast if Cured', 316: 'Summon All Corpses',
  317: 'Block DS', 318: 'Overheal', 319: 'Focus Pet',
  320: 'AE Melee', 321: 'Frenzied Devastation',
  322: 'Pet HP %', 323: 'Change Target', 324: 'AE Rampage',
  325: 'AE Flurry', 326: 'Pet Flurry',
  327: 'DS Mitigation', 328: 'Melee Damage Amt',
  329: 'Auto Attack', 330: 'Wake the Dead',
  331: 'Doppelganger', 332: 'Increase Range DS',
  333: 'Fake Death', 334: 'Improved Rune',
  335: 'Max HP Increase', 336: 'Max Mana Increase',
  337: 'Stun Resist', 338: 'Strikethrough2',
  339: 'Trigger Spell', 340: 'Trigger Spell (Proc)',
  341: 'Crit DoT Damage', 342: 'Crit Heal', 343: 'Crit HoT',
  344: 'Crit Mend', 345: 'Dual Wield', 346: 'Double Attack',
  347: 'Lifetap from Weapon', 348: 'Instrument Mod',
  349: 'Resist All', 350: 'Cast on Fade',
  351: 'Base Damage Adj', 352: 'Limit: HP Min',
  353: 'HP Change per Tick', 354: 'Skill Specialization',
  355: 'Incoming Damage Mod', 356: 'Worn Regen',
  357: 'Ban Trade', 358: 'Song Range', 359: 'Reduce Skill Timer',
  360: 'Song AOE', 361: 'Reduce Combat Skill Timer',
  362: 'Limit: Resist', 363: 'Limit: No Focus',
  364: 'Cast if Twincast', 365: 'AE Hate',
  366: 'Spell Hate', 367: 'Worn Endurance Regen',
  368: 'Limit: Min Cast Time', 369: 'Limit: No Detrimental',
  370: 'Worn Purity', 371: 'Bodily Inhibition',
  372: 'Crit Melee Damage', 373: 'Crit Spell Damage',
  374: 'Critical Heal Chance', 375: 'Critical Heal Amount',
  376: 'Crit HoT Chance', 377: 'Crit HoT Amount',
  378: 'Melee Crit Guard', 379: 'Spell Crit Guard',
  380: 'Melee Flurry', 381: 'Spell PB AE',
  382: 'Trigger on Crit', 383: 'Crit Melee2',
  384: 'Crit Spell2', 385: 'Flurry Chance',
  386: 'Pet Flurry Chance', 387: 'Limit: Beneficial',
  388: 'Improved Binding', 389: 'Feign Death Chance',
  390: 'Limit: Detrimental', 391: 'Limit: Spell',
  392: 'Limit: Target Type',
  399: 'Worn HP Regen Cap', 400: 'Worn Mana Regen Cap',
  401: 'Limit: Pet', 402: 'Skill Min Damage Mod',
  403: 'Heal Rate', 404: 'Mana Drain',
  405: 'Endurance Drain', 406: 'Limit: Class',
  407: 'Limit: Race', 408: 'Base Damage',
  409: 'Limit: Skill', 410: 'Limit: Item Class',
  411: 'AC2', 412: 'Mana2', 413: 'Spell Damage',
  414: 'Increase Healing', 415: 'Reverse DS Guard',
  416: 'DoT Guard', 417: 'Melee Threshold Guard',
  418: 'Spell Threshold Guard', 419: 'Trigger Spell on Kill',
  420: 'Trigger Spell on Death', 421: 'Potion Belt Slots',
  422: 'Bandolier Slots', 423: 'Triple Attack Chance',
  424: 'Worn Attack Cap', 425: 'Group Shielding',
  426: 'Trade Skill Mastery', 427: 'Reduce AA Timer',
  428: 'No Fizzle', 429: 'Add Procs',
  430: '2H Bash', 431: 'Reduce Falling Damage',
  432: 'Cast on Fly', 433: 'Add Extended Target Slots',
  434: 'Skill Base Damage Mod', 435: 'Limit: Skill',
  436: 'Limit: Item Type', 437: 'Spell Damage Resist',
  438: 'Shadow Knight Fear', 439: 'Fade',
  440: 'Stun Resist', 441: 'Strikethrough3',
  442: 'Skill Min Damage2', 443: 'Limit: HP %',
  444: 'Limit: Mana %', 445: 'Limit: Endurance %',
  446: 'Limit: Class2', 447: 'Limit: Race2',
  448: 'Limit: Caster Class', 449: 'Limit: Same Caster',
  450: 'Extend Tradeskill Cap', 451: 'Pushback',
  452: 'Luck Chance', 453: 'Luck Amount',
  454: 'Endurance Absorb', 455: 'Limit: SpellGroup',
  456: 'Doom on Fade', 457: 'No Remove',
  458: 'Spell Proc Guard', 459: 'Melee Proc Guard',
  460: 'Pet Power', 461: 'HP Absorb % Max',
  462: 'HP Absorb Total', 463: 'Melee Threshold',
  464: 'Spell Threshold', 465: 'Triple Backstab',
  466: 'Combat Agility', 467: 'Combat Stability',
  468: 'Worn Attack', 469: 'Mana Absorb',
  470: 'Endurance Absorb', 471: 'DoT Crit Chance',
  472: 'Heal Crit Chance', 473: 'Mend Crit Chance',
  474: 'Dual Wield Chance', 475: 'Double Attack Chance',
  476: 'Limit: Min Level', 477: 'Limit: Max Level',
  478: 'Limit: Min Cast Time', 479: 'Limit: Max Cast Time',
  480: 'Limit: Min Mana', 481: 'Limit: Max Mana',
  482: 'Limit: Spell Type', 483: 'Limit: Cast Time Max',
  484: 'Limit: Cast Time Min', 485: 'Improved Taunt',
  486: 'Add Melee Proc', 487: 'Add Range Proc',
  488: 'Illusion: Other', 489: 'Mass Group Buff',
  490: 'Group Stun Resist', 491: 'Rampage2',
  492: 'AE Taunt2', 493: 'Flesh to Bone2',
  494: 'HP/Tick', 495: 'Mana/Tick', 496: 'Endurance/Tick',
  497: 'Hate Mod', 498: 'Chance Best in Spell Group',
  499: 'Trigger Best in Spell Group',
  500: 'AC Limit', 501: 'Mana Limit', 502: 'HP Limit',
  503: 'Endurance Limit', 504: 'Add Hate %',
  505: 'Spell Damage Shield Amt', 506: 'Manaburn2',
  507: 'Overshadow', 508: 'Doom Dispeller',
  509: 'Doom Melee', 510: 'Doom Spell',
  511: 'Add Body Type', 512: 'Faction Mod',
  513: 'Corruption Resist', 514: 'Corruption Damage',
  515: 'Melee Delay', 516: 'Foraging',
  517: 'Doom Entity', 518: 'Limit: Combat Skills',
  519: 'Sanctuary', 520: 'DoT Damage Mod',
  521: 'Nuke Damage Mod',
};

const SKILL_NAMES: Record<number, string> = {
  0: '1H Blunt', 1: '1H Slashing', 2: '2H Blunt', 3: '2H Slashing',
  4: 'Abjuration', 5: 'Alteration', 6: 'Apply Poison', 7: 'Archery',
  8: 'Backstab', 9: 'Bind Wound', 10: 'Bash', 11: 'Block',
  12: 'Brass Instruments', 13: 'Channeling', 14: 'Conjuration', 15: 'Defense',
  16: 'Disarm', 17: 'Disarm Traps', 18: 'Divination', 19: 'Dodge',
  20: 'Double Attack', 21: 'Dragon Punch', 22: 'Dual Wield', 23: 'Eagle Strike',
  24: 'Evocation', 25: 'Feign Death', 26: 'Flying Kick', 27: 'Forage',
  28: 'Hand to Hand', 29: 'Hide', 30: 'Kick', 31: 'Meditate',
  32: 'Mend', 33: 'Offense', 34: 'Parry', 35: 'Pick Lock',
  36: '1H Piercing', 37: 'Riposte', 38: 'Round Kick', 39: 'Safe Fall',
  40: 'Sense Heading', 41: 'Singing', 42: 'Sneak',
  43: 'Specialize Abjuration', 44: 'Specialize Alteration',
  45: 'Specialize Conjuration', 46: 'Specialize Divination',
  47: 'Specialize Evocation', 48: 'Pick Pockets', 49: 'Stringed Instruments',
  50: 'Swimming', 51: 'Throwing', 52: 'Tiger Claw', 53: 'Tracking',
  54: 'Wind Instruments', 55: 'Fishing', 56: 'Make Poison', 57: 'Tinkering',
  58: 'Research', 59: 'Alchemy', 60: 'Baking', 61: 'Tailoring',
  62: 'Sense Traps', 63: 'Blacksmithing', 64: 'Fletching', 65: 'Brewing',
  66: 'Alcohol Tolerance', 67: 'Begging', 68: 'Jewelry Making',
  69: 'Pottery', 70: 'Percussion Instruments', 71: 'Intimidation',
  72: 'Berserking', 73: 'Taunt', 74: 'Frenzy',
  75: 'Remove Traps', 76: 'Triple Attack', 77: '2H Piercing',
};

// ============ INTERNAL DATA TYPES ============

interface LocalSpell {
  id: number;
  name: string;
  fields: string[];
}

interface SpellStrings {
  casterMe: string;
  casterOther: string;
  castedMe: string;
  castedOther: string;
  spellGone: string;
}

interface LocalZone {
  id: number;
  name: string;
  levelMin: number;
  levelMax: number;
}

interface SkillCapEntry {
  classId: number;
  skillId: number;
  level: number;
  cap: number;
}

interface BaseStatEntry {
  level: number;
  classId: number;
  hp: number;
  mana: number;
  endurance: number;
  unknown1: number;
  unknown2: number;
  hpRegen: number;
  manaRegen: number;
  enduranceRegen: number;
}

interface AchievementEntry {
  id: number;
  name: string;
  description: string;
  rewardId: number;
  points: number;
  hidden: boolean;
  locked: boolean;
}

interface SpellStackEntry {
  spellId: number;
  stackingGroup: number;
  rank: number;
  stackingType: number;
}

interface ACMitigationEntry {
  classId: number;
  level: number;
  acCap: number;
  softCapMultiplier: number;
}

interface MapPOI {
  x: number;
  y: number;
  z: number;
  label: string;
  r: number;
  g: number;
  b: number;
}

interface FactionEntry {
  id: number;
  name: string;
  minValue: number;
  maxValue: number;
  category?: string;       // Expansion/category name
  startingValues?: { modifierId: number; value: number }[]; // Race/class starting faction adjustments
}

interface AAEntry {
  id: number;
  name: string;
  description: string;
}

interface LoreEntry {
  filename: string;
  title: string;
  content: string;
}

interface AchievementCategory {
  id: number;
  parentId: number;
  order: number;
  name: string;
  description: string;
}

interface AchievementComponent {
  achievementId: number;
  componentNum: number;
  type: number;
  requirement: number;
  description: string;
}

interface OverseerMinion {
  id: number;
  rarity: number;
  shortName: string;
  fullName: string;
  bio: string;
  traits: string[];
  traitIds: number[];
  jobs: { jobTypeId: number; level: number }[];
}

interface OverseerSlotDetail {
  slotId: number;
  jobTypeId: number;
  isRequired: boolean;
  bonusTraitIds: number[];
}

interface OverseerQuest {
  id: number;
  categoryId: number;
  name: string;
  description: string;
  difficulty: number;
  duration: number;
  requiredSlots: number;
  optionalSlots: number;
  slotDetails: OverseerSlotDetail[];
}

interface MercenaryEntry {
  id: number;
  tier: string;
  description: string;
  race: string;
  type: string;
  confidence: string;
  proficiency: string;
}

// ============ LAZY-LOADED DATA STORES ============

let spells: Map<number, LocalSpell> | null = null;
let spellNameIndex: Map<string, number[]> | null = null;
let spellStrings: Map<number, SpellStrings> | null = null;
let zones: Map<number, LocalZone> | null = null;
let zoneNameIndex: Map<string, number[]> | null = null;
let skillCaps: SkillCapEntry[] | null = null;
let baseStats: BaseStatEntry[] | null = null;
let achievements: Map<number, AchievementEntry> | null = null;
let achievementNameIndex: Map<string, number[]> | null = null;
let spellStacking: Map<number, SpellStackEntry[]> | null = null;
let spellGroupNames: Map<number, string> | null = null;
let bonusDescriptions: Map<number, string> | null = null;
let augmentGroups: Map<number, string> | null = null;
let acMitigation: ACMitigationEntry[] | null = null;
let spellRequirements: Map<number, { subId: number; reqId: number; failureStringId: number }[]> | null = null;
let mapCache: Map<string, MapPOI[]> = new Map();

// dbstr_us.txt parsed data
let dbStrings: Map<number, Map<number, string>> | null = null; // type -> id -> text
let factions: Map<number, FactionEntry> | null = null;
let factionNameIndex: Map<string, number[]> | null = null;
let factionCategories: Map<number, string> | null = null; // categoryId -> name (expansion)
let factionModifierNames: Map<number, string> | null = null; // modifierId -> name (Race: Human, etc.)
let aaAbilities: Map<number, AAEntry> | null = null;
let aaNameIndex: Map<string, number[]> | null = null;
let spellDescriptions: Map<number, string> | null = null;
let spellCategories: Map<number, string> | null = null;

// Lore/Storyline data
let loreEntries: LoreEntry[] | null = null;
let loreNameIndex: Map<string, number> | null = null; // lowercase title -> index in loreEntries

// Enhanced achievement data
let achievementCategories: Map<number, AchievementCategory> | null = null;
let achievementToCategories: Map<number, number[]> | null = null; // achievementId -> categoryIds
let categoryToAchievements: Map<number, number[]> | null = null; // categoryId -> achievementIds
let achievementComponents: Map<number, AchievementComponent[]> | null = null;

// Game strings (eqstr_us.txt)
let gameStrings: Map<number, string> | null = null;

// Overseer system
let overseerMinions: Map<number, OverseerMinion> | null = null;
let overseerMinionNameIndex: Map<string, number[]> | null = null;
let overseerQuests: Map<number, OverseerQuest> | null = null;
let overseerQuestNameIndex: Map<string, number[]> | null = null;

// Combat abilities / disciplines
let combatAbilities: Map<number, string> | null = null;
let combatAbilityNameIndex: Map<string, number[]> | null = null;

// Item effect descriptions (click/proc)
let itemEffectDescs: Map<number, string> | null = null;
let itemEffectIndex: Map<string, number[]> | null = null;

// Banner/campsite categories
let bannerCategories: Map<number, string> | null = null;
let campsiteCategories: Map<number, string> | null = null;

// Expansion names
let expansionNames: Map<number, string> | null = null;

// Game events (What's New system)
let gameEvents: Map<number, { banner: string; description: string }> | null = null;
let gameEventIndex: Map<string, number[]> | null = null;

// Mercenaries
let mercenaries: Map<number, MercenaryEntry> | null = null;
let mercenaryNameIndex: Map<string, number[]> | null = null;

// Mercenary stances and abilities
interface MercenaryStance {
  id: number;
  name: string;
  description: string;
  shortDesc: string;
}
interface MercenaryAbility {
  id: number;
  name: string;
  description: string;
}
let mercenaryStances: Map<number, MercenaryStance> | null = null;
let mercenaryTypes: Map<number, string> | null = null;
let mercenaryAbilities: Map<number, MercenaryAbility> | null = null;

// Race/class descriptions
let raceDescriptions: Map<number, { short: string; long: string }> | null = null;
let classDescriptions: Map<number, { short: string; long: string }> | null = null;
let statDescriptions: Map<string, string> | null = null;
let deityNames: Map<number, string> | null = null;
let deityDescriptions: Map<number, string> | null = null;

// Alternate currencies
let altCurrencies: Map<number, { name: string; description: string }> | null = null;

// Tributes
interface TributeEntry {
  id: number;
  name: string;
  description: string;
  isGuild: boolean;
}
let tributes: Map<number, TributeEntry> | null = null;
let tributeNameIndex: Map<string, number[]> | null = null;

// Overseer category/difficulty/incapacitation/trait/job names
let overseerCategories: Map<number, string> | null = null;
let overseerDifficulties: Map<number, string> | null = null;
let overseerTraitDescs: Map<number, string> | null = null;
let overseerIncapNames: Map<number, string> | null = null;
let overseerIncapDescs: Map<number, string> | null = null;
let overseerJobNames: Map<number, string> | null = null;
let overseerArchetypeNames: Map<number, string> | null = null;

// Creature race types (NPC/monster race names)
let creatureTypes: Map<number, string> | null = null;
let creatureTypeIndex: Map<string, number[]> | null = null;

// Starting city lore descriptions
let startingCityLore: Map<number, string> | null = null;

// Overseer job class descriptions
let overseerJobClassDescs: Map<number, string> | null = null;

// Overseer incapacitation durations: entry ID -> { jobType, duration in seconds }
let overseerIncapDurations: Map<number, { jobType: number; duration: number }> | null = null;

// Drakkin heritage data
interface DrakkinHeritage {
  id: number;
  name: string;
  classes: number[];
}
let drakkinHeritages: DrakkinHeritage[] | null = null;

let dataAvailable: boolean | null = null;

// ============ PATH HELPERS ============

function gamePath(...parts: string[]): string {
  return join(EQ_GAME_PATH, ...parts);
}

export function isGameDataAvailable(): boolean {
  if (dataAvailable !== null) return dataAvailable;
  dataAvailable = existsSync(gamePath('spells_us.txt'));
  if (dataAvailable) {
    console.error(`[LocalData] EQ game files found at: ${EQ_GAME_PATH}`);
  } else {
    console.error(`[LocalData] EQ game files NOT found at: ${EQ_GAME_PATH}`);
  }
  return dataAvailable;
}

async function readGameFile(path: string): Promise<string> {
  return readFile(gamePath(path), 'utf-8');
}

// ============ SPELL PARSER ============

async function loadSpells(): Promise<void> {
  if (spells !== null) return;

  if (!isGameDataAvailable()) {
    spells = new Map();
    spellNameIndex = new Map();
    return;
  }

  console.error('[LocalData] Loading spells_us.txt...');
  const data = await readGameFile('spells_us.txt');
  const lines = data.split('\n');

  spells = new Map();
  spellNameIndex = new Map();

  for (const line of lines) {
    if (!line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 52) continue;

    const id = parseInt(fields[SF.ID]);
    const name = fields[SF.NAME];
    if (isNaN(id) || !name) continue;

    spells.set(id, { id, name, fields });

    // Build name index for search (lowercase words -> spell IDs)
    const lowerName = name.toLowerCase();
    const existing = spellNameIndex.get(lowerName) || [];
    existing.push(id);
    spellNameIndex.set(lowerName, existing);
  }

  console.error(`[LocalData] Loaded ${spells.size} spells`);
}

async function loadSpellStrings(): Promise<void> {
  if (spellStrings !== null) return;

  if (!isGameDataAvailable()) {
    spellStrings = new Map();
    return;
  }

  try {
    console.error('[LocalData] Loading spells_us_str.txt...');
    const data = await readGameFile('spells_us_str.txt');
    const lines = data.split('\n');
    spellStrings = new Map();

    for (const line of lines) {
      if (line.startsWith('#') || !line.trim()) continue;
      const fields = line.split('^');
      if (fields.length < 6) continue;

      const id = parseInt(fields[0]);
      if (isNaN(id)) continue;

      spellStrings.set(id, {
        casterMe: fields[1] || '',
        casterOther: fields[2] || '',
        castedMe: fields[3] || '',
        castedOther: fields[4] || '',
        spellGone: fields[5] || '',
      });
    }

    console.error(`[LocalData] Loaded ${spellStrings.size} spell strings`);
  } catch {
    console.error('[LocalData] Could not load spells_us_str.txt');
    spellStrings = new Map();
  }
}

function formatEffectValue(base1: number, suffix: string = ''): string {
  if (base1 > 0) return ` +${base1}${suffix}`;
  return ` ${base1}${suffix}`;
}

function resolveSpellDescription(desc: string, fields: string[], duration?: string): string {
  let resolved = desc;

  // Replace %z with duration
  if (duration) {
    resolved = resolved.replace(/%z/g, duration);
  }

  // Replace #N (base value of slot N) and @N (max value of slot N)
  // Effect data is in the last pipe-delimited field
  for (let i = fields.length - 1; i >= 0; i--) {
    if (fields[i].includes('|')) {
      const slots = fields[i].split('$');
      for (const slot of slots) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const slotNum = parseInt(parts[0]);
          const base1 = parseInt(parts[2]);
          const max = parts.length > 4 ? parseInt(parts[4]) : 0;
          if (!isNaN(slotNum) && !isNaN(base1)) {
            const absBase = Math.abs(base1);
            resolved = resolved.replace(new RegExp(`#${slotNum}`, 'g'), absBase.toString());
            if (!isNaN(max) && max !== 0) {
              resolved = resolved.replace(new RegExp(`@${slotNum}`, 'g'), Math.abs(max).toString());
            }
          }
        }
      }
      break;
    }
  }

  return resolved;
}

function parseSpellEffects(fields: string[]): string[] {
  const effects: string[] = [];

  // Find the last field containing pipe characters (effect data)
  for (let i = fields.length - 1; i >= 0; i--) {
    if (fields[i].includes('|')) {
      const slots = fields[i].split('$');
      for (const slot of slots) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const slotNum = parseInt(parts[0]);
          const spa = parseInt(parts[1]);
          const base1 = parseInt(parts[2]);
          const base2 = parts.length > 3 ? parseInt(parts[3]) : 0;
          const max = parts.length > 4 ? parseInt(parts[4]) : 0;

          if (isNaN(spa) || (base1 === 0 && spa === 254)) continue;

          const spaName = SPA_NAMES[spa] || `SPA ${spa}`;
          let desc = `Slot ${slotNum}: ${spaName}`;

          // HP effects (heal, nuke, limit)
          if (spa === 0 || spa === 79 || spa === 101 || spa === 502) {
            desc += formatEffectValue(base1);
            if (max > 0) desc += ` (max: ${max})`;
          }
          // Percentage-based effects
          else if (spa === 3 || spa === 31 || spa === 11 || spa === 130 ||
                   spa === 140 || spa === 173 || spa === 200 || spa === 202 ||
                   spa === 203 || spa === 218 || spa === 219 || spa === 220 ||
                   spa === 221 || spa === 250 || spa === 255 || spa === 345 ||
                   spa === 346 || spa === 372 || spa === 373 || spa === 374 ||
                   spa === 375 || spa === 376 || spa === 377 || spa === 380 ||
                   spa === 385 || spa === 386 || spa === 403 || spa === 423 ||
                   spa === 452 || spa === 471 || spa === 472 || spa === 474 ||
                   spa === 475 || spa === 520 || spa === 521) {
            desc += ` ${base1}%`;
            if (max > 0) desc += ` (max: ${max})`;
          }
          // Stat effects (STR, DEX, AGI, STA, INT, WIS, CHA, AC, ATK)
          else if ((spa >= 4 && spa <= 10) || spa === 1 || spa === 2) {
            desc += formatEffectValue(base1);
          }
          // Resist effects (fire, cold, poison, disease, magic, corruption)
          else if ((spa >= 46 && spa <= 50) || spa === 146 || spa === 349) {
            desc += formatEffectValue(base1);
          }
          // Regen/tick effects
          else if (spa === 34 || spa === 35 || spa === 108 || spa === 137 ||
                   spa === 144 || spa === 353 || spa === 494 || spa === 495 ||
                   spa === 496) {
            desc += ` ${base1}/tick`;
          }
          // Max stat effects
          else if (spa === 69 || spa === 106 || spa === 163 || spa === 165 ||
                   spa === 269 || spa === 270 || spa === 271 || spa === 273 ||
                   spa === 274 || spa === 275 || spa === 335 || spa === 336) {
            desc += formatEffectValue(base1);
          }
          // Duration-based effects
          else if (spa === 127 || spa === 128 || spa === 129) {
            desc += ` ${base1}%`;
          }
          // Illusion
          else if (spa === 86) {
            desc += `: ${base1}`;
          }
          // Damage shield
          else if (spa === 87 || spa === 111) {
            desc += ` ${base1}`;
          }
          // Summon item
          else if (spa === 32) {
            desc += ` (item ID: ${base1})`;
          }
          // Spell trigger/proc
          else if (spa === 85 || spa === 289 || spa === 339 || spa === 340 ||
                   spa === 350 || spa === 419 || spa === 420) {
            const refSpell = spells?.get(base1);
            desc += refSpell ? ` → ${refSpell.name} [${base1}]` : ` (spell ID: ${base1})`;
            if (base2 > 0) desc += ` (${base2}% chance)`;
          }
          // Melee/range procs
          else if (spa === 119 || spa === 120) {
            const refSpell = spells?.get(base1);
            desc += refSpell ? ` → ${refSpell.name} [${base1}]` : ` (spell ID: ${base1})`;
            if (base2 > 0) desc += ` +${base2} rate mod`;
          }
          // Damage mitigation
          else if (spa === 132 || spa === 133 || spa === 327 ||
                   spa === 461 || spa === 462 || spa === 463 || spa === 464) {
            desc += formatEffectValue(base1);
            if (max > 0) desc += ` (max: ${max})`;
          }
          // Aggro
          else if (spa === 114 || spa === 92 || spa === 158 || spa === 365 ||
                   spa === 366 || spa === 497 || spa === 504) {
            desc += formatEffectValue(base1);
          }
          // Skill damage
          else if (spa === 136 || spa === 174 || spa === 175 || spa === 188 ||
                   spa === 297 || spa === 328 || spa === 434) {
            desc += formatEffectValue(base1);
            if (base2 > 0) {
              const skillName = SKILL_NAMES[base2] || `Skill ${base2}`;
              desc += ` (${skillName})`;
            }
          }
          // Absorb effects
          else if (spa === 55 || spa === 54 || spa === 170 || spa === 179) {
            desc += ` ${base1}`;
            if (max > 0) desc += ` (max: ${max})`;
          }
          // Stacking/limit effects - show value
          else if (spa === 148 || spa === 102 || spa === 103) {
            desc += ` (${base1})`;
          }
          // Limit SPAs - show the limit value
          else if (spaName.startsWith('Limit:')) {
            desc += ` ${base1}`;
          }
          // Default: show numeric value if non-zero
          else if (base1 !== 0) {
            desc += formatEffectValue(base1);
          }

          effects.push(desc);
        }
      }
      break;
    }
  }

  return effects;
}

function formatDuration(formula: number, value: number): string {
  if (formula === 0 && value === 0) return 'Instant';

  const ticks = calculateDurationTicks(formula, value);
  if (ticks === -1) return `Formula ${formula}, Base ${value} ticks`;
  if (ticks === 0) return 'Instant';

  const seconds = ticks * 6;
  if (seconds < 60) return `${seconds}s`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60 > 0 ? (seconds % 60) + 's' : ''}`.trim();
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  return `${hours}h ${mins > 0 ? mins + 'm' : ''}`.trim();
}

function calculateDurationTicks(formula: number, value: number): number {
  // Returns duration in ticks (1 tick = 6 seconds)
  // Some formulas depend on caster level, so we use max level (125) as estimate
  const level = 125;
  switch (formula) {
    case 0: return 0;
    case 1: return Math.min(Math.ceil(level / 2), value || 999);
    case 2: return Math.min(Math.ceil(level * 0.6), value || 999);
    case 3: return Math.min(level * 30, value || 999);
    case 4: return value || 50;
    case 5: return value || 2;
    case 6: return Math.min(Math.ceil(level / 2) + 2, value || 999);
    case 7: return Math.min(level, value || 999);
    case 8: return Math.min(level + 10, value || 999);
    case 9: return Math.min(2 * level + 10, value || 999);
    case 10: return Math.min(3 * level + 10, value || 999);
    case 11: return Math.min(Math.ceil(level / 4), value || 999);
    case 12: return value;
    case 15: return value;
    case 50: return 72000; // permanent (effectively)
    case 51: return 72000; // permanent
    default: return value || -1;
  }
}

function buildLocalSpellData(spell: LocalSpell): SpellData {
  const f = spell.fields;

  // Parse class levels
  const classes: Record<string, number> = {};
  for (let i = 0; i < 16; i++) {
    const level = parseInt(f[SF.CLASS_LEVEL_START + i]);
    if (!isNaN(level) && level !== 255 && level > 0) {
      classes[CLASS_IDS[i + 1]] = level;
    }
  }

  // Parse basic fields
  const mana = parseInt(f[SF.MANA]);
  const castTime = parseInt(f[SF.CAST_TIME]);
  const recoveryTime = parseInt(f[SF.RECOVERY_TIME]);
  const recastTime = parseInt(f[SF.RECAST_TIME]);
  const range = parseInt(f[SF.RANGE]);
  const aeRange = parseInt(f[SF.AE_RANGE]);
  const targetType = parseInt(f[SF.TARGET_TYPE]);
  const resistType = parseInt(f[SF.RESIST_TYPE]);
  const durationFormula = parseInt(f[SF.DURATION_FORMULA]);
  const durationValue = parseInt(f[SF.DURATION_VALUE]);
  const beneficial = f[SF.BENEFICIAL] === '1';

  // Parse effects
  const effects = parseSpellEffects(f);

  const spellData: SpellData = {
    name: spell.name,
    id: spell.id.toString(),
    source: 'Local Game Data',
    classes: Object.keys(classes).length > 0 ? classes : undefined,
    effects: effects.length > 0 ? effects : undefined,
  };

  if (!isNaN(mana) && mana > 0) spellData.mana = mana;

  const endurance = parseInt(f[SF.ENDURANCE]);
  if (!isNaN(endurance) && endurance > 0) spellData.endurance = endurance;

  if (!isNaN(castTime) && castTime > 0) {
    spellData.castTime = `${(castTime / 1000).toFixed(1)}s`;
  }

  if (!isNaN(recoveryTime) && recoveryTime > 0) {
    spellData.recoveryTime = `${(recoveryTime / 1000).toFixed(1)}s`;
  }

  if (!isNaN(recastTime) && recastTime > 0) {
    spellData.recastTime = `${(recastTime / 1000).toFixed(1)}s`;
  }

  if (durationFormula > 0 || durationValue > 0) {
    spellData.duration = formatDuration(durationFormula, durationValue);
  }

  if (!isNaN(range) && range > 0) {
    spellData.range = `${range}`;
  }

  if (!isNaN(aeRange) && aeRange > 0) {
    spellData.aeRange = `${aeRange}`;
  }

  if (!isNaN(targetType)) {
    spellData.target = TARGET_TYPES[targetType] || `Type ${targetType}`;
  }

  if (!isNaN(resistType) && resistType > 0) {
    spellData.resist = RESIST_TYPES[resistType] || `Type ${resistType}`;
  }

  spellData.beneficial = beneficial;

  const pushBack = parseInt(f[SF.PUSH_BACK]);
  const pushUp = parseInt(f[SF.PUSH_UP]);
  if (!isNaN(pushBack) && pushBack > 0) spellData.pushBack = pushBack;
  if (!isNaN(pushUp) && pushUp > 0) spellData.pushUp = pushUp;

  // Reuse timer group
  const timerId = parseInt(f[SF.TIMER_ID]);
  if (!isNaN(timerId) && timerId > 0) spellData.timerId = timerId;

  // Spell category/subcategory
  const catId = parseInt(f[SF.CATEGORY]);
  const subCatId = parseInt(f[SF.SUBCATEGORY]);
  if (!isNaN(catId) && catId > 0 && spellCategories) {
    spellData.category = spellCategories.get(catId) || undefined;
  }
  if (!isNaN(subCatId) && subCatId > 0 && subCatId !== catId && spellCategories) {
    spellData.subcategory = spellCategories.get(subCatId) || undefined;
  }

  // Recourse spell (cast on caster when spell lands on target)
  const recourseId = parseInt(f[SF.RECOURSE]);
  if (!isNaN(recourseId) && recourseId > 0 && recourseId !== parseInt(f[SF.ID])) {
    spellData.recourseId = recourseId;
    const recourseSpell = spells?.get(recourseId);
    if (recourseSpell) {
      spellData.recourseName = recourseSpell.name;
    }
  }

  // Teleport zone (for teleport/translocate spells; filter out pet model names)
  const teleportZone = f[SF.TELEPORT_ZONE]?.trim();
  if (teleportZone && /^[a-z_]+[a-z0-9_]*$/.test(teleportZone)) {
    spellData.teleportZone = teleportZone;
  }

  return spellData;
}

// ============ ZONE PARSER ============

async function loadZones(): Promise<void> {
  if (zones !== null) return;

  if (!isGameDataAvailable()) {
    zones = new Map();
    zoneNameIndex = new Map();
    return;
  }

  console.error('[LocalData] Loading ZoneNames.txt...');
  const data = await readGameFile(join('Resources', 'ZoneNames.txt'));
  const lines = data.split('\n');

  zones = new Map();
  zoneNameIndex = new Map();

  for (const line of lines) {
    if (!line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 4) continue;

    const id = parseInt(fields[0]);
    const name = fields[1];
    const levelMin = parseInt(fields[2]) || 0;
    const levelMax = parseInt(fields[3]) || 0;
    if (isNaN(id) || !name) continue;

    zones.set(id, { id, name, levelMin, levelMax });

    const lowerName = name.toLowerCase();
    const existing = zoneNameIndex.get(lowerName) || [];
    existing.push(id);
    zoneNameIndex.set(lowerName, existing);
  }

  console.error(`[LocalData] Loaded ${zones.size} zones`);
}

// ============ SKILL CAPS PARSER ============

async function loadSkillCaps(): Promise<void> {
  if (skillCaps !== null) return;

  if (!isGameDataAvailable()) {
    skillCaps = [];
    return;
  }

  console.error('[LocalData] Loading skillcaps.txt...');
  const data = await readGameFile(join('Resources', 'skillcaps.txt'));
  const lines = data.split('\n');

  skillCaps = [];

  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 4) continue;

    const classId = parseInt(fields[0]);
    const skillId = parseInt(fields[1]);
    const level = parseInt(fields[2]);
    const cap = parseInt(fields[3]);
    if (isNaN(classId) || isNaN(skillId) || isNaN(level) || isNaN(cap)) continue;

    skillCaps.push({ classId, skillId, level, cap });
  }

  console.error(`[LocalData] Loaded ${skillCaps.length} skill cap entries`);
}

// ============ BASE STATS PARSER ============

async function loadBaseStats(): Promise<void> {
  if (baseStats !== null) return;

  if (!isGameDataAvailable()) {
    baseStats = [];
    return;
  }

  console.error('[LocalData] Loading basedata.txt...');
  const data = await readGameFile(join('Resources', 'basedata.txt'));
  const lines = data.split('\n');

  baseStats = [];

  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 10) continue;

    const level = parseInt(fields[0]);
    const classId = parseInt(fields[1]);
    const hp = parseInt(fields[2]);
    const mana = parseInt(fields[3]);
    const endurance = parseInt(fields[4]);
    const unknown1 = parseInt(fields[5]);
    const unknown2 = parseInt(fields[6]);
    const hpRegen = parseFloat(fields[7]);
    const manaRegen = parseFloat(fields[8]);
    const enduranceRegen = parseFloat(fields[9]);

    if (isNaN(level) || isNaN(classId)) continue;

    baseStats.push({
      level, classId, hp, mana, endurance,
      unknown1, unknown2, hpRegen, manaRegen, enduranceRegen,
    });
  }

  console.error(`[LocalData] Loaded ${baseStats.length} base stat entries`);
}

// ============ ACHIEVEMENT PARSER ============

async function loadAchievements(): Promise<void> {
  if (achievements !== null) return;

  if (!isGameDataAvailable()) {
    achievements = new Map();
    achievementNameIndex = new Map();
    return;
  }

  console.error('[LocalData] Loading AchievementsClient.txt...');
  const data = await readGameFile(join('Resources', 'Achievements', 'AchievementsClient.txt'));
  const lines = data.split('\n');

  achievements = new Map();
  achievementNameIndex = new Map();

  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 5) continue;

    const id = parseInt(fields[0]);
    const name = fields[1];
    const description = fields[2];
    const rewardId = parseInt(fields[3]) || 0;
    const points = parseInt(fields[4]) || 0;
    const hidden = fields[5] === '1';
    const locked = fields[6] === '1';
    if (isNaN(id) || !name) continue;

    achievements.set(id, { id, name, description, rewardId, points, hidden, locked });

    const lowerName = name.toLowerCase();
    const existing = achievementNameIndex.get(lowerName) || [];
    existing.push(id);
    achievementNameIndex.set(lowerName, existing);
  }

  console.error(`[LocalData] Loaded ${achievements.size} achievements`);
}

// ============ SPELL STACKING PARSER ============

async function loadSpellStacking(): Promise<void> {
  if (spellStacking !== null) return;

  if (!isGameDataAvailable()) {
    spellStacking = new Map();
    return;
  }

  console.error('[LocalData] Loading SpellStackingGroups.txt...');
  const data = await readGameFile(join('Resources', 'SpellStackingGroups.txt'));
  const lines = data.split('\n');

  spellStacking = new Map();

  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 4) continue;

    const spellId = parseInt(fields[0]);
    const stackingGroup = parseInt(fields[1]);
    const rank = parseInt(fields[2]);
    const stackingType = parseInt(fields[3]);
    if (isNaN(spellId)) continue;

    const entry: SpellStackEntry = { spellId, stackingGroup, rank, stackingType };
    const existing = spellStacking.get(spellId) || [];
    existing.push(entry);
    spellStacking.set(spellId, existing);
  }

  console.error(`[LocalData] Loaded stacking data for ${spellStacking.size} spells`);

  // Load spell group names from dbstr
  await loadDbStrings([DBSTR_TYPES.SPELL_GROUP_NAME]);
  spellGroupNames = dbStrings?.get(DBSTR_TYPES.SPELL_GROUP_NAME) || new Map();
  console.error(`[LocalData] Loaded ${spellGroupNames.size} spell group names`);
}

async function loadBonusAndAugmentData(): Promise<void> {
  if (bonusDescriptions !== null) return;

  bonusDescriptions = new Map();
  augmentGroups = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([DBSTR_TYPES.BONUS_DESCRIPTION, DBSTR_TYPES.AUGMENT_GROUP]);
  const bonuses = dbStrings?.get(DBSTR_TYPES.BONUS_DESCRIPTION) || new Map();
  const augs = dbStrings?.get(DBSTR_TYPES.AUGMENT_GROUP) || new Map();

  for (const [id, desc] of bonuses) bonusDescriptions.set(id, desc);
  for (const [id, name] of augs) augmentGroups.set(id, name);

  console.error(`[LocalData] Loaded ${bonusDescriptions.size} bonus descriptions, ${augmentGroups.size} augment groups`);
}

// ============ ITEM EFFECT DESCRIPTION LOADER ============

async function loadItemEffects(): Promise<void> {
  if (itemEffectDescs !== null) return;

  itemEffectDescs = new Map();
  itemEffectIndex = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([DBSTR_TYPES.ITEM_EFFECT_DESC]);
  const descs = dbStrings?.get(DBSTR_TYPES.ITEM_EFFECT_DESC) || new Map();

  for (const [id, rawDesc] of descs) {
    const desc = stripHtmlTags(rawDesc);
    itemEffectDescs.set(id, desc);

    // Build word index for searching
    const words = desc.toLowerCase().split(/\s+/);
    for (const word of words) {
      if (word.length < 3) continue;
      const existing = itemEffectIndex!.get(word) || [];
      if (existing.length < 50) { // Limit index entries per word
        existing.push(id);
        itemEffectIndex!.set(word, existing);
      }
    }
  }

  console.error(`[LocalData] Loaded ${itemEffectDescs.size} item effect descriptions`);
}

// ============ BANNER/CAMPSITE CATEGORY LOADER ============

async function loadBannerCategories(): Promise<void> {
  if (bannerCategories !== null) return;

  bannerCategories = new Map();
  campsiteCategories = new Map();
  if (!isGameDataAvailable()) return;

  try {
    const bannerData = await readGameFile(join('Resources', 'bannercategories.txt'));
    for (const line of bannerData.split('\n')) {
      if (!line.trim() || line.startsWith('#') || line.startsWith('CATEGORY_ID')) continue;
      const fields = line.split('^');
      if (fields.length < 2) continue;
      const id = parseInt(fields[0]);
      const desc = fields[1].trim();
      if (!isNaN(id) && desc) bannerCategories.set(id, desc);
    }
  } catch { /* ignore */ }

  try {
    const campsiteData = await readGameFile(join('Resources', 'campsitecategories.txt'));
    for (const line of campsiteData.split('\n')) {
      if (!line.trim() || line.startsWith('#') || line.startsWith('CATEGORY_ID')) continue;
      const fields = line.split('^');
      if (fields.length < 2) continue;
      const id = parseInt(fields[0]);
      const desc = fields[1].trim();
      if (!isNaN(id) && desc) campsiteCategories.set(id, desc);
    }
  } catch { /* ignore */ }

  console.error(`[LocalData] Loaded ${bannerCategories.size} banner categories, ${campsiteCategories.size} campsite categories`);
}

// ============ AC MITIGATION PARSER ============

async function loadACMitigation(): Promise<void> {
  if (acMitigation !== null) return;

  if (!isGameDataAvailable()) {
    acMitigation = [];
    return;
  }

  console.error('[LocalData] Loading ACMitigation.txt...');
  const data = await readGameFile(join('Resources', 'ACMitigation.txt'));
  const lines = data.split('\n');

  acMitigation = [];

  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 4) continue;

    const classId = parseInt(fields[0]);
    const level = parseInt(fields[1]);
    const acCap = parseInt(fields[2]);
    const softCapMultiplier = parseFloat(fields[3]);
    if (isNaN(classId) || isNaN(level)) continue;

    acMitigation.push({ classId, level, acCap, softCapMultiplier });
  }

  console.error(`[LocalData] Loaded ${acMitigation.length} AC mitigation entries`);
}

// ============ SPELL REQUIREMENTS PARSER ============

async function loadSpellRequirements(): Promise<void> {
  if (spellRequirements !== null) return;

  if (!isGameDataAvailable()) {
    spellRequirements = new Map();
    return;
  }

  console.error('[LocalData] Loading spellrequirementassociations.txt...');
  const data = await readGameFile(join('Resources', 'spellrequirementassociations.txt'));
  const lines = data.split('\n');

  spellRequirements = new Map();

  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 4) continue;

    const spellAssocId = parseInt(fields[0]);
    const subId = parseInt(fields[1]);
    const reqId = parseInt(fields[2]);
    const failureStringId = parseInt(fields[3]);
    if (isNaN(spellAssocId)) continue;

    const existing = spellRequirements.get(spellAssocId) || [];
    existing.push({ subId, reqId, failureStringId });
    spellRequirements.set(spellAssocId, existing);
  }

  console.error(`[LocalData] Loaded requirements for ${spellRequirements.size} spell associations`);
}

// ============ DBSTR_US.TXT PARSER ============

// String types in dbstr_us.txt: object_id^string_type^text^extra^
const DBSTR_TYPES = {
  AA_NAME: 1,
  AA_DESCRIPTION: 4,
  SPELL_CATEGORY: 5,
  SPELL_DESCRIPTION: 6,
  COMBAT_ABILITY: 27,
  BONUS_DESCRIPTION: 34,
  SPELL_GROUP_NAME: 40,
  FACTION_NAME: 45,
  AUGMENT_GROUP: 46,
  OVERSEER_MINION_SHORT: 52,
  OVERSEER_MINION_FULL: 53,
  OVERSEER_TRAIT: 54,
  OVERSEER_QUEST_NAME: 56,
  OVERSEER_QUEST_DESC: 57,
  OVERSEER_MINION_BIO: 61,
  MERCENARY_TIER: 22,
  MERCENARY_DESC: 23,
  MERCENARY_STANCE_NAME: 24,
  MERCENARY_STANCE_DESC: 25,
  MERCENARY_STANCE_SHORT: 26,
  MERCENARY_TYPE: 36,
  MERCENARY_ABILITY_NAME: 37,
  MERCENARY_ABILITY_DESC: 38,
  RACE_NAME: 11,
  RACE_DESCRIPTION: 8,
  CLASS_DESCRIPTION: 9,
  DEITY_DESCRIPTION: 14,
  ALT_CURRENCY: 17,
  ALT_CURRENCY_DESC: 47,
  TRIBUTE_NAME: 48,
  TRIBUTE_DESC: 49,
  GUILD_TRIBUTE_NAME: 50,
  GUILD_TRIBUTE_DESC: 51,
  OVERSEER_TRAIT_DESC: 55,
  OVERSEER_JOB_NAME: 62,
  OVERSEER_JOB_DESC: 63,
  OVERSEER_ARCHETYPE_NAME: 64,
  OVERSEER_INCAP_NAME: 58,
  OVERSEER_INCAP_DESC: 59,
  OVERSEER_DIFFICULTY: 66,
  OVERSEER_QUEST_CATEGORY: 67,
  ITEM_EFFECT_DESC: 43,
  RESIST_TYPE: 39,
  CURRENCY_NAME: 44,
  BANNER_CATEGORY: 32,
  EXPANSION_NAME: 20,
  EVENT_BANNER: 30,
  EVENT_DESCRIPTION: 31,
  OVERSEER_SUCCESS: 68,
  OVERSEER_FAILURE: 69,
  CREATURE_RACE: 12,
  STARTING_CITY: 15,
  OVERSEER_JOB_CLASS_DESC: 65,
  AUGMENT_SLOT_TYPE: 16,
  ITEM_LORE_GROUP: 7,
};

const OVERSEER_RARITIES: Record<number, string> = {
  1: 'Common',
  2: 'Uncommon',
  3: 'Rare',
  4: 'Elite',
  5: 'Legendary',
};

async function loadDbStrings(types: number[]): Promise<void> {
  if (dbStrings === null) {
    dbStrings = new Map();
  }

  // Check which types still need loading
  const needed = types.filter(t => !dbStrings!.has(t));
  if (needed.length === 0) return;

  if (!isGameDataAvailable()) return;

  try {
    console.error(`[LocalData] Loading dbstr_us.txt for types: ${needed.join(', ')}...`);
    const data = await readGameFile('dbstr_us.txt');
    const lines = data.split('\n');

    // Initialize maps for needed types
    const neededSet = new Set(needed);
    for (const t of needed) {
      dbStrings.set(t, new Map());
    }

    for (const line of lines) {
      if (!line.trim()) continue;
      const fields = line.split('^');
      if (fields.length < 3) continue;

      const id = parseInt(fields[0]);
      const type = parseInt(fields[1]);
      const text = fields[2];

      if (isNaN(id) || isNaN(type) || !text) continue;
      if (!neededSet.has(type)) continue;

      dbStrings.get(type)!.set(id, text);
    }

    for (const t of needed) {
      console.error(`[LocalData] Loaded ${dbStrings.get(t)!.size} strings for type ${t}`);
    }
  } catch {
    console.error('[LocalData] Could not load dbstr_us.txt');
    for (const t of needed) {
      if (!dbStrings.has(t)) dbStrings.set(t, new Map());
    }
  }
}

// ============ SPELL DESCRIPTIONS PARSER ============

async function loadSpellDescriptions(): Promise<void> {
  if (spellDescriptions !== null) return;

  await loadDbStrings([DBSTR_TYPES.SPELL_DESCRIPTION, DBSTR_TYPES.SPELL_CATEGORY]);
  spellDescriptions = dbStrings?.get(DBSTR_TYPES.SPELL_DESCRIPTION) || new Map();
  spellCategories = dbStrings?.get(DBSTR_TYPES.SPELL_CATEGORY) || new Map();
  console.error(`[LocalData] ${spellDescriptions.size} spell descriptions, ${spellCategories.size} spell categories available`);
}

// ============ FACTION PARSER ============

async function loadFactions(): Promise<void> {
  if (factions !== null) return;

  if (!isGameDataAvailable()) {
    factions = new Map();
    factionNameIndex = new Map();
    return;
  }

  // Load faction names from dbstr_us.txt
  await loadDbStrings([DBSTR_TYPES.FACTION_NAME]);
  const factionNames = dbStrings?.get(DBSTR_TYPES.FACTION_NAME) || new Map();

  // Load faction base data
  console.error('[LocalData] Loading FactionBaseData.txt...');
  factions = new Map();
  factionNameIndex = new Map();

  try {
    const data = await readGameFile(join('Resources', 'Faction', 'FactionBaseData.txt'));
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 3) continue;

      const id = parseInt(fields[0]);
      const minValue = parseInt(fields[1]) || -2000;
      const maxValue = parseInt(fields[2]) || 2000;
      if (isNaN(id)) continue;

      const name = factionNames.get(id) || `Faction ${id}`;
      factions.set(id, { id, name, minValue, maxValue });

      // Build name index
      const lowerName = name.toLowerCase();
      const existing = factionNameIndex!.get(lowerName) || [];
      existing.push(id);
      factionNameIndex!.set(lowerName, existing);
    }

    console.error(`[LocalData] Loaded ${factions.size} factions (${factionNames.size} with names)`);
  } catch {
    console.error('[LocalData] Could not load FactionBaseData.txt');
  }

  // Load faction window categories (expansion groupings)
  factionCategories = new Map();
  try {
    const catData = await readGameFile(join('Resources', 'Faction', 'FactionWindowCategories.txt'));
    for (const line of catData.split('\n')) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 2) continue;
      const id = parseInt(fields[0]);
      const name = fields[1];
      if (!isNaN(id) && name) factionCategories.set(id, name);
    }

    // Load category-to-faction associations
    const assocData = await readGameFile(join('Resources', 'Faction', 'FactionWindowCategoryAssociations.txt'));
    for (const line of assocData.split('\n')) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 2) continue;
      const catId = parseInt(fields[0]);
      const factionId = parseInt(fields[1]);
      if (isNaN(catId) || isNaN(factionId)) continue;

      const faction = factions.get(factionId);
      if (faction && factionCategories.has(catId)) {
        faction.category = factionCategories.get(catId);
      }
    }
    console.error(`[LocalData] Loaded ${factionCategories.size} faction categories`);
  } catch {
    console.error('[LocalData] Could not load faction categories');
  }

  // Load faction associations (starting faction values by race/class)
  factionModifierNames = new Map();
  // Modifier names come from type 45: IDs 1-16 = classes, 51+ = races
  for (const [id, name] of factionNames) {
    if (id <= 16 || (id >= 51 && id <= 62) || name.startsWith('Race:') || name.startsWith('Class:')) {
      factionModifierNames.set(id, name);
    }
  }

  try {
    const assocData = await readGameFile(join('Resources', 'Faction', 'FactionAssociations.txt'));
    for (const line of assocData.split('\n')) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 3) continue;
      const factionId = parseInt(fields[0]);
      const modifierId = parseInt(fields[1]);
      const value = parseInt(fields[2]);
      if (isNaN(factionId) || isNaN(modifierId) || isNaN(value)) continue;

      const faction = factions.get(factionId);
      if (faction) {
        if (!faction.startingValues) faction.startingValues = [];
        faction.startingValues.push({ modifierId, value });
      }
    }
    const withStarting = [...factions.values()].filter(f => f.startingValues && f.startingValues.length > 0).length;
    console.error(`[LocalData] Loaded faction starting values (${withStarting} factions with race/class adjustments)`);
  } catch {
    console.error('[LocalData] Could not load faction associations');
  }
}

// ============ AA ABILITY PARSER ============

async function loadAAAbilities(): Promise<void> {
  if (aaAbilities !== null) return;

  if (!isGameDataAvailable()) {
    aaAbilities = new Map();
    aaNameIndex = new Map();
    return;
  }

  // Load AA names and descriptions from dbstr_us.txt
  await loadDbStrings([DBSTR_TYPES.AA_NAME, DBSTR_TYPES.AA_DESCRIPTION]);
  const aaNames = dbStrings?.get(DBSTR_TYPES.AA_NAME) || new Map();
  const aaDescs = dbStrings?.get(DBSTR_TYPES.AA_DESCRIPTION) || new Map();

  aaAbilities = new Map();
  aaNameIndex = new Map();

  for (const [id, name] of aaNames) {
    const description = aaDescs.get(id) || '';
    aaAbilities.set(id, { id, name, description });

    const lowerName = name.toLowerCase();
    const existing = aaNameIndex.get(lowerName) || [];
    existing.push(id);
    aaNameIndex.set(lowerName, existing);
  }

  console.error(`[LocalData] Loaded ${aaAbilities.size} AA abilities`);
}

// ============ LORE/STORYLINE PARSER ============

function stripHtmlTags(text: string): string {
  return text
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<[^>]+>/g, '')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

async function loadLore(): Promise<void> {
  if (loreEntries !== null) return;

  if (!isGameDataAvailable()) {
    loreEntries = [];
    loreNameIndex = new Map();
    return;
  }

  const storyDir = gamePath('Storyline');
  if (!existsSync(storyDir)) {
    console.error('[LocalData] Storyline directory not found');
    loreEntries = [];
    loreNameIndex = new Map();
    return;
  }

  console.error('[LocalData] Loading Storyline files...');
  loreEntries = [];
  loreNameIndex = new Map();

  try {
    const files = await readdir(storyDir);
    const storyFiles = files.filter(f => f.startsWith('story') && f.endsWith('.txt') && !f.endsWith('.txt:crc'));

    for (const file of storyFiles.sort()) {
      try {
        const content = await readFile(join(storyDir, file), 'utf-8');
        const lines = content.split('\n');
        const title = lines[0]?.trim() || file.replace('.txt', '');
        const body = stripHtmlTags(lines.slice(1).join('\n'));

        const index = loreEntries.length;
        loreEntries.push({ filename: file, title, content: body });
        loreNameIndex!.set(title.toLowerCase(), index);
      } catch {
        // Skip unreadable files
      }
    }

    console.error(`[LocalData] Loaded ${loreEntries.length} lore stories`);
  } catch {
    console.error('[LocalData] Could not read Storyline directory');
  }
}

// ============ ENHANCED ACHIEVEMENT DATA ============

async function loadAchievementCategories(): Promise<void> {
  if (achievementCategories !== null) return;

  if (!isGameDataAvailable()) {
    achievementCategories = new Map();
    achievementToCategories = new Map();
    categoryToAchievements = new Map();
    return;
  }

  console.error('[LocalData] Loading AchievementCategories.txt...');
  achievementCategories = new Map();

  try {
    const data = await readGameFile(join('Resources', 'Achievements', 'AchievementCategories.txt'));
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 6) continue;

      const parentId = fields[0] ? parseInt(fields[0]) : 0; // 0 = top-level
      const order = parseInt(fields[1]);
      const id = parseInt(fields[2]);
      const name = fields[3] || '';
      const description = fields[4] || '';
      if (isNaN(id)) continue;

      achievementCategories.set(id, { id, parentId, order, name, description });
    }

    console.error(`[LocalData] Loaded ${achievementCategories.size} achievement categories`);
  } catch {
    console.error('[LocalData] Could not load AchievementCategories.txt');
  }

  // Load category-to-achievement associations
  console.error('[LocalData] Loading AchievementCategoryAssociationsClient.txt...');
  achievementToCategories = new Map();
  categoryToAchievements = new Map();

  try {
    const data = await readGameFile(join('Resources', 'Achievements', 'AchievementCategoryAssociationsClient.txt'));
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 3) continue;

      const categoryId = parseInt(fields[0]);
      const achievementId = parseInt(fields[2]);
      if (isNaN(categoryId) || isNaN(achievementId)) continue;

      // achievement -> categories (existing)
      const existing = achievementToCategories.get(achievementId) || [];
      existing.push(categoryId);
      achievementToCategories.set(achievementId, existing);

      // category -> achievements (reverse map)
      const catAchs = categoryToAchievements.get(categoryId) || [];
      catAchs.push(achievementId);
      categoryToAchievements.set(categoryId, catAchs);
    }

    console.error(`[LocalData] Loaded category associations for ${achievementToCategories.size} achievements`);
  } catch {
    console.error('[LocalData] Could not load AchievementCategoryAssociationsClient.txt');
  }
}

async function loadAchievementComponents(): Promise<void> {
  if (achievementComponents !== null) return;

  if (!isGameDataAvailable()) {
    achievementComponents = new Map();
    return;
  }

  console.error('[LocalData] Loading AchievementComponentsClient.txt...');
  achievementComponents = new Map();

  try {
    const data = await readGameFile(join('Resources', 'Achievements', 'AchievementComponentsClient.txt'));
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 5) continue;

      const achievementId = parseInt(fields[0]);
      const componentNum = parseInt(fields[1]);
      const type = parseInt(fields[2]);
      const requirement = parseInt(fields[3]);
      const description = fields[4] || '';
      if (isNaN(achievementId)) continue;

      const component: AchievementComponent = { achievementId, componentNum, type, requirement, description };
      const existing = achievementComponents.get(achievementId) || [];
      existing.push(component);
      achievementComponents.set(achievementId, existing);
    }

    console.error(`[LocalData] Loaded components for ${achievementComponents.size} achievements`);
  } catch {
    console.error('[LocalData] Could not load AchievementComponentsClient.txt');
  }
}

// ============ GAME STRINGS PARSER (eqstr_us.txt) ============

async function loadGameStrings(): Promise<void> {
  if (gameStrings !== null) return;

  if (!isGameDataAvailable()) {
    gameStrings = new Map();
    return;
  }

  console.error('[LocalData] Loading eqstr_us.txt...');
  gameStrings = new Map();

  try {
    const data = await readGameFile('eqstr_us.txt');
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim()) continue;
      // Format: ID SPACE TEXT (first space separates ID from text)
      const spaceIdx = line.indexOf(' ');
      if (spaceIdx === -1) continue;

      const id = parseInt(line.substring(0, spaceIdx));
      const text = line.substring(spaceIdx + 1).trim();
      if (isNaN(id) || !text) continue;

      gameStrings.set(id, text);
    }

    console.error(`[LocalData] Loaded ${gameStrings.size} game strings`);
  } catch {
    console.error('[LocalData] Could not load eqstr_us.txt');
  }
}

// ============ OVERSEER SYSTEM PARSER ============

async function loadOverseerMinions(): Promise<void> {
  if (overseerMinions !== null) return;

  if (!isGameDataAvailable()) {
    overseerMinions = new Map();
    overseerMinionNameIndex = new Map();
    return;
  }

  // Load minion names and bios from dbstr_us.txt
  await loadDbStrings([DBSTR_TYPES.OVERSEER_MINION_SHORT, DBSTR_TYPES.OVERSEER_MINION_FULL, DBSTR_TYPES.OVERSEER_TRAIT, DBSTR_TYPES.OVERSEER_MINION_BIO]);
  const shortNames = dbStrings?.get(DBSTR_TYPES.OVERSEER_MINION_SHORT) || new Map();
  const fullNames = dbStrings?.get(DBSTR_TYPES.OVERSEER_MINION_FULL) || new Map();
  const traitNames = dbStrings?.get(DBSTR_TYPES.OVERSEER_TRAIT) || new Map();
  const bios = dbStrings?.get(DBSTR_TYPES.OVERSEER_MINION_BIO) || new Map();

  console.error('[LocalData] Loading OvrMiniClient.txt...');
  overseerMinions = new Map();
  overseerMinionNameIndex = new Map();

  try {
    const data = await readGameFile(join('Resources', 'OvrMiniClient.txt'));
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 3) continue;

      const id = parseInt(fields[0]);
      const rarity = parseInt(fields[1]);
      if (isNaN(id)) continue;

      const shortName = shortNames.get(id) || `Minion ${id}`;
      const fullName = fullNames.get(id) || shortName;
      const bio = bios.get(id) || '';

      overseerMinions.set(id, { id, rarity, shortName, fullName, bio, traits: [], traitIds: [], jobs: [] });

      const lowerName = fullName.toLowerCase();
      const existing = overseerMinionNameIndex!.get(lowerName) || [];
      existing.push(id);
      overseerMinionNameIndex!.set(lowerName, existing);
    }

    // Load minion traits from OvrMiniTraitClient.txt
    try {
      const traitData = await readGameFile(join('Resources', 'OvrMiniTraitClient.txt'));
      const traitLines = traitData.split('\n');

      for (const line of traitLines) {
        if (!line.trim() || line.startsWith('#')) continue;
        const fields = line.split('^');
        if (fields.length < 2) continue;

        const minionId = parseInt(fields[0]);
        const traitId = parseInt(fields[1]);
        if (isNaN(minionId) || isNaN(traitId)) continue;

        const minion = overseerMinions.get(minionId);
        const traitName = traitNames.get(traitId);
        if (minion && traitName && !minion.traits.includes(traitName)) {
          minion.traits.push(traitName);
          minion.traitIds.push(traitId);
        }
      }
    } catch {
      console.error('[LocalData] Could not load OvrMiniTraitClient.txt');
    }

    // Load agent jobs from OvrJobClient.txt
    try {
      const jobData = await readGameFile(join('Resources', 'OvrJobClient.txt'));
      const jobLines = jobData.split('\n');

      for (const line of jobLines) {
        if (!line.trim() || line.startsWith('#')) continue;
        const fields = line.split('^');
        if (fields.length < 7) continue;

        const jobTypeId = parseInt(fields[0]);
        const minionId = parseInt(fields[1]);
        const level = parseInt(fields[5]);
        if (isNaN(jobTypeId) || isNaN(minionId)) continue;

        const minion = overseerMinions.get(minionId);
        if (minion) {
          // Only add if not already present
          if (!minion.jobs.some(j => j.jobTypeId === jobTypeId)) {
            minion.jobs.push({ jobTypeId, level: isNaN(level) ? 1 : level });
          }
        }
      }
    } catch {
      console.error('[LocalData] Could not load OvrJobClient.txt');
    }

    console.error(`[LocalData] Loaded ${overseerMinions.size} Overseer minions`);
  } catch {
    console.error('[LocalData] Could not load OvrMiniClient.txt');
  }
}

async function loadOverseerQuests(): Promise<void> {
  if (overseerQuests !== null) return;

  if (!isGameDataAvailable()) {
    overseerQuests = new Map();
    overseerQuestNameIndex = new Map();
    return;
  }

  // Load quest names from dbstr_us.txt
  await loadDbStrings([DBSTR_TYPES.OVERSEER_QUEST_NAME, DBSTR_TYPES.OVERSEER_QUEST_DESC]);
  const questNames = dbStrings?.get(DBSTR_TYPES.OVERSEER_QUEST_NAME) || new Map();
  const questDescs = dbStrings?.get(DBSTR_TYPES.OVERSEER_QUEST_DESC) || new Map();

  console.error('[LocalData] Loading OvrQstClient.txt...');
  overseerQuests = new Map();
  overseerQuestNameIndex = new Map();

  try {
    const data = await readGameFile(join('Resources', 'OvrQstClient.txt'));
    const lines = data.split('\n');

    for (const line of lines) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 5) continue;

      const id = parseInt(fields[0]);
      const categoryId = parseInt(fields[1]);
      const difficulty = parseInt(fields[2]);
      const duration = parseInt(fields[3]);
      if (isNaN(id)) continue;

      const name = questNames.get(id) || '';
      if (!name) continue; // Skip quests without names (internal/system quests)

      const rawDesc = questDescs.get(id) || '';
      const description = stripHtmlTags(rawDesc.replace(/<c\s+"[^"]*">/gi, '').replace(/<\/c>/gi, ''));

      overseerQuests.set(id, { id, categoryId, name, description, difficulty, duration, requiredSlots: 0, optionalSlots: 0, slotDetails: [] });

      const lowerName = name.toLowerCase();
      const existing = overseerQuestNameIndex!.get(lowerName) || [];
      existing.push(id);
      overseerQuestNameIndex!.set(lowerName, existing);
    }

    // Load slot data: slot definitions, quest-slot associations, slot-trait mappings, trait groups
    try {
      // 1. Parse slot definitions: slotId -> { jobTypeId, isRequired }
      const slotData = await readGameFile(join('Resources', 'OvrQstMinionSlotClient.txt'));
      const slotInfo = new Map<number, { jobTypeId: number; isRequired: boolean }>();

      for (const line of slotData.split('\n')) {
        if (!line.trim() || line.startsWith('#')) continue;
        const fields = line.split('^');
        if (fields.length < 5) continue;
        const slotId = parseInt(fields[0]);
        const jobTypeId = parseInt(fields[1]);
        const required = fields[4] === '1';
        if (!isNaN(slotId)) slotInfo.set(slotId, { jobTypeId, isRequired: required });
      }

      // 2. Parse trait groups: traitGroupId -> traitId[] (bonus traits)
      const traitGroupData = await readGameFile(join('Resources', 'OvrQstTraitClient.txt'));
      const traitGroups = new Map<number, number[]>();
      for (const line of traitGroupData.split('\n')) {
        if (!line.trim() || line.startsWith('#')) continue;
        const fields = line.split('^');
        if (fields.length < 3) continue;
        const groupId = parseInt(fields[0]);
        const traitId = parseInt(fields[1]);
        if (isNaN(groupId) || isNaN(traitId)) continue;
        const existing = traitGroups.get(groupId) || [];
        if (!existing.includes(traitId)) existing.push(traitId);
        traitGroups.set(groupId, existing);
      }

      // 3. Parse slot -> trait group mappings
      const slotTraitData = await readGameFile(join('Resources', 'OvrQstSlotTraitGroup.txt'));
      const slotTraits = new Map<number, number[]>(); // slotId -> traitId[]
      for (const line of slotTraitData.split('\n')) {
        if (!line.trim() || line.startsWith('#')) continue;
        const fields = line.split('^');
        if (fields.length < 2) continue;
        const slotId = parseInt(fields[0]);
        const traitGroupId = parseInt(fields[1]);
        if (isNaN(slotId) || isNaN(traitGroupId)) continue;
        const traits = traitGroups.get(traitGroupId) || [];
        const existing = slotTraits.get(slotId) || [];
        for (const t of traits) {
          if (!existing.includes(t)) existing.push(t);
        }
        slotTraits.set(slotId, existing);
      }

      // 4. Associate slots to quests
      const assocData = await readGameFile(join('Resources', 'OvrQstMinionSlotAssoc.txt'));
      for (const line of assocData.split('\n')) {
        if (!line.trim() || line.startsWith('#')) continue;
        const fields = line.split('^');
        if (fields.length < 3) continue;
        const questId = parseInt(fields[0]);
        const slotId = parseInt(fields[1]);
        if (isNaN(questId) || isNaN(slotId)) continue;

        const quest = overseerQuests.get(questId);
        const slot = slotInfo.get(slotId);
        if (quest && slot) {
          if (slot.isRequired) {
            quest.requiredSlots++;
          } else {
            quest.optionalSlots++;
          }
          quest.slotDetails.push({
            slotId,
            jobTypeId: slot.jobTypeId,
            isRequired: slot.isRequired,
            bonusTraitIds: slotTraits.get(slotId) || [],
          });
        }
      }
    } catch {
      console.error('[LocalData] Could not load Overseer slot data');
    }

    console.error(`[LocalData] Loaded ${overseerQuests.size} Overseer quests`);
  } catch {
    console.error('[LocalData] Could not load OvrQstClient.txt');
  }
}

// ============ COMBAT ABILITIES PARSER ============

async function loadCombatAbilities(): Promise<void> {
  if (combatAbilities !== null) return;

  if (!isGameDataAvailable()) {
    combatAbilities = new Map();
    combatAbilityNameIndex = new Map();
    return;
  }

  await loadDbStrings([DBSTR_TYPES.COMBAT_ABILITY]);
  const abilityNames = dbStrings?.get(DBSTR_TYPES.COMBAT_ABILITY) || new Map();

  console.error('[LocalData] Loading combat abilities...');
  combatAbilities = new Map();
  combatAbilityNameIndex = new Map();

  for (const [id, name] of abilityNames) {
    combatAbilities.set(id, name);

    const lowerName = name.toLowerCase();
    const existing = combatAbilityNameIndex.get(lowerName) || [];
    existing.push(id);
    combatAbilityNameIndex.set(lowerName, existing);
  }

  console.error(`[LocalData] Loaded ${combatAbilities.size} combat abilities`);
}

// ============ MERCENARY PARSER ============

async function loadMercenaries(): Promise<void> {
  if (mercenaries !== null) return;

  if (!isGameDataAvailable()) {
    mercenaries = new Map();
    mercenaryNameIndex = new Map();
    return;
  }

  await loadDbStrings([DBSTR_TYPES.MERCENARY_TIER, DBSTR_TYPES.MERCENARY_DESC]);
  const tiers = dbStrings?.get(DBSTR_TYPES.MERCENARY_TIER) || new Map();
  const descs = dbStrings?.get(DBSTR_TYPES.MERCENARY_DESC) || new Map();

  console.error('[LocalData] Loading mercenary data...');
  mercenaries = new Map();
  mercenaryNameIndex = new Map();

  for (const [id, rawDesc] of descs) {
    const tier = tiers.get(id) || '';
    const cleanDesc = stripHtmlTags(rawDesc);

    // Parse structured fields from description
    const raceMatch = cleanDesc.match(/Race:\s*([^\n]+)/);
    const typeMatch = cleanDesc.match(/Type:\s*([^\n]+)/);
    const confMatch = cleanDesc.match(/Confidence:\s*([^\n]+)/);
    const profMatch = cleanDesc.match(/Proficiency:\s*([^\n,]+)/);

    const race = raceMatch?.[1]?.trim() || 'Unknown';
    const type = typeMatch?.[1]?.trim() || 'Unknown';
    const confidence = confMatch?.[1]?.trim() || '';
    const proficiency = profMatch?.[1]?.trim() || '';

    const entry: MercenaryEntry = { id, tier, description: cleanDesc, race, type, confidence, proficiency };
    mercenaries.set(id, entry);

    // Index by race and type for searching
    const searchKey = `${race} ${type}`.toLowerCase();
    const existing = mercenaryNameIndex.get(searchKey) || [];
    existing.push(id);
    mercenaryNameIndex.set(searchKey, existing);
  }

  console.error(`[LocalData] Loaded ${mercenaries.size} mercenary types`);
}

async function loadMercenaryStances(): Promise<void> {
  if (mercenaryStances !== null) return;

  if (!isGameDataAvailable()) {
    mercenaryStances = new Map();
    mercenaryTypes = new Map();
    mercenaryAbilities = new Map();
    return;
  }

  await loadDbStrings([
    DBSTR_TYPES.MERCENARY_STANCE_NAME,
    DBSTR_TYPES.MERCENARY_STANCE_DESC,
    DBSTR_TYPES.MERCENARY_STANCE_SHORT,
    DBSTR_TYPES.MERCENARY_TYPE,
    DBSTR_TYPES.MERCENARY_ABILITY_NAME,
    DBSTR_TYPES.MERCENARY_ABILITY_DESC,
  ]);

  const stanceNames = dbStrings?.get(DBSTR_TYPES.MERCENARY_STANCE_NAME) || new Map();
  const stanceDescs = dbStrings?.get(DBSTR_TYPES.MERCENARY_STANCE_DESC) || new Map();
  const stanceShorts = dbStrings?.get(DBSTR_TYPES.MERCENARY_STANCE_SHORT) || new Map();
  const types = dbStrings?.get(DBSTR_TYPES.MERCENARY_TYPE) || new Map();
  const abilNames = dbStrings?.get(DBSTR_TYPES.MERCENARY_ABILITY_NAME) || new Map();
  const abilDescs = dbStrings?.get(DBSTR_TYPES.MERCENARY_ABILITY_DESC) || new Map();

  mercenaryStances = new Map();
  for (const [id, name] of stanceNames) {
    mercenaryStances.set(id, {
      id,
      name,
      description: stanceDescs.get(id) || '',
      shortDesc: stanceShorts.get(id) || '',
    });
  }

  mercenaryTypes = new Map();
  for (const [id, name] of types) {
    mercenaryTypes.set(id, name);
  }

  mercenaryAbilities = new Map();
  for (const [id, name] of abilNames) {
    mercenaryAbilities.set(id, {
      id,
      name,
      description: stripHtmlTags(abilDescs.get(id) || ''),
    });
  }

  console.error(`[LocalData] Loaded ${mercenaryStances.size} mercenary stances, ${mercenaryTypes.size} types, ${mercenaryAbilities.size} abilities`);
}

// ============ RACE & CLASS INFO PARSER ============

// eqstr_us.txt IDs for race descriptions (longer, lore-rich)
const EQSTR_RACE_DESC: Record<number, number> = {
  2: 3239,   // Barbarian
  6: 3240,   // Dark Elf
  8: 3241,   // Dwarf
  3: 3242,   // Erudite
  7: 3243,   // Half Elf
  11: 3244,  // Halfling
  5: 3245,   // High Elf
  1: 3246,   // Human
  128: 3247, // Iksar
  10: 3248,  // Ogre
  9: 3249,   // Troll
  130: 3273, // Vah Shir
  4: 3274,   // Wood Elf
  330: 3316, // Froglok
  12: 3339,  // Gnome
};

// eqstr_us.txt IDs for class descriptions (longer)
const EQSTR_CLASS_DESC: Record<number, number> = {
  8: 3317,   // Bard
  15: 3318,  // Beastlord
  2: 3319,   // Cleric
  6: 3320,   // Druid
  14: 3321,  // Enchanter
  13: 3322,  // Magician
  7: 3323,   // Monk
  11: 3324,  // Necromancer
  3: 3325,   // Paladin
  4: 3326,   // Ranger
  9: 3327,   // Rogue
  5: 3328,   // Shadow Knight
  10: 3329,  // Shaman
  1: 3330,   // Warrior
  12: 3331,  // Wizard
};

// eqstr_us.txt IDs for stat descriptions
const EQSTR_STAT_DESC: Record<string, number> = {
  'Strength': 3332,
  'Stamina': 3333,
  'Agility': 3334,
  'Dexterity': 3335,
  'Wisdom': 3336,
  'Intelligence': 3337,
  'Charisma': 3338,
};

async function loadRaceClassInfo(): Promise<void> {
  if (raceDescriptions !== null) return;

  raceDescriptions = new Map();
  classDescriptions = new Map();
  statDescriptions = new Map();
  deityNames = new Map();

  if (!isGameDataAvailable()) return;

  console.error('[LocalData] Loading race/class info...');

  deityDescriptions = new Map();

  // Load short descriptions from dbstr_us.txt (types 8, 9, and 14 for deities)
  await loadDbStrings([DBSTR_TYPES.RACE_DESCRIPTION, DBSTR_TYPES.CLASS_DESCRIPTION, DBSTR_TYPES.DEITY_DESCRIPTION]);
  const shortRaceDescs = dbStrings?.get(DBSTR_TYPES.RACE_DESCRIPTION) || new Map();
  const shortClassDescs = dbStrings?.get(DBSTR_TYPES.CLASS_DESCRIPTION) || new Map();

  // Load long descriptions and other data from eqstr_us.txt
  await loadGameStrings();

  // Build race descriptions
  for (const [raceId, raceName] of Object.entries(RACE_IDS)) {
    const id = parseInt(raceId);
    const shortRaw = shortRaceDescs.get(id) || '';
    const short = stripHtmlTags(shortRaw);

    let long = '';
    const eqstrId = EQSTR_RACE_DESC[id];
    if (eqstrId && gameStrings) {
      const raw = gameStrings.get(eqstrId) || '';
      long = stripHtmlTags(raw);
    }

    raceDescriptions.set(id, { short: short || long, long: long || short });
  }

  // Build class descriptions
  for (const [classId, className] of Object.entries(CLASS_IDS)) {
    const id = parseInt(classId);
    const shortRaw = shortClassDescs.get(id) || '';
    const short = stripHtmlTags(shortRaw);

    let long = '';
    const eqstrId = EQSTR_CLASS_DESC[id];
    if (eqstrId && gameStrings) {
      const raw = gameStrings.get(eqstrId) || '';
      long = stripHtmlTags(raw);
    }

    classDescriptions.set(id, { short: short || long, long: long || short });
  }

  // Load stat descriptions
  if (gameStrings) {
    for (const [statName, eqstrId] of Object.entries(EQSTR_STAT_DESC)) {
      const raw = gameStrings.get(eqstrId) || '';
      statDescriptions.set(statName, stripHtmlTags(raw));
    }
  }

  // Load deity names
  if (gameStrings) {
    for (const [eqstrId, deityId] of Object.entries(DEITY_IDS)) {
      const name = gameStrings.get(parseInt(eqstrId));
      if (name) {
        deityNames.set(deityId, name);
      }
    }
  }

  // Load deity descriptions from dbstr type 14
  const deityDescs = dbStrings?.get(DBSTR_TYPES.DEITY_DESCRIPTION) || new Map();
  for (const [deityId, rawDesc] of deityDescs) {
    deityDescriptions!.set(deityId, stripHtmlTags(rawDesc));
  }

  console.error(`[LocalData] Loaded ${raceDescriptions.size} races, ${classDescriptions.size} classes, ${deityDescriptions!.size} deities`);
}

// ============ ALTERNATE CURRENCY PARSER ============

async function loadAltCurrencies(): Promise<void> {
  if (altCurrencies !== null) return;

  altCurrencies = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([DBSTR_TYPES.ALT_CURRENCY, DBSTR_TYPES.ALT_CURRENCY_DESC]);
  const names = dbStrings?.get(DBSTR_TYPES.ALT_CURRENCY) || new Map();
  const descs = dbStrings?.get(DBSTR_TYPES.ALT_CURRENCY_DESC) || new Map();

  for (const [id, name] of names) {
    altCurrencies.set(id, {
      name,
      description: stripHtmlTags(descs.get(id) || ''),
    });
  }

  console.error(`[LocalData] Loaded ${altCurrencies.size} alternate currencies`);
}

// ============ TRIBUTE PARSER ============

async function loadTributes(): Promise<void> {
  if (tributes !== null) return;

  tributes = new Map();
  tributeNameIndex = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([
    DBSTR_TYPES.TRIBUTE_NAME, DBSTR_TYPES.TRIBUTE_DESC,
    DBSTR_TYPES.GUILD_TRIBUTE_NAME, DBSTR_TYPES.GUILD_TRIBUTE_DESC,
  ]);
  const personalNames = dbStrings?.get(DBSTR_TYPES.TRIBUTE_NAME) || new Map();
  const personalDescs = dbStrings?.get(DBSTR_TYPES.TRIBUTE_DESC) || new Map();
  const guildNames = dbStrings?.get(DBSTR_TYPES.GUILD_TRIBUTE_NAME) || new Map();
  const guildDescs = dbStrings?.get(DBSTR_TYPES.GUILD_TRIBUTE_DESC) || new Map();

  // Personal tributes (use IDs as-is)
  for (const [id, name] of personalNames) {
    const desc = stripHtmlTags(personalDescs.get(id) || '');
    tributes.set(id, { id, name, description: desc, isGuild: false });
    const lower = name.toLowerCase();
    const existing = tributeNameIndex.get(lower) || [];
    existing.push(id);
    tributeNameIndex.set(lower, existing);
  }

  // Guild tributes (offset IDs by 100000 to avoid collisions)
  for (const [id, name] of guildNames) {
    const offsetId = 100000 + id;
    const desc = stripHtmlTags(guildDescs.get(id) || '');
    tributes.set(offsetId, { id: offsetId, name, description: desc, isGuild: true });
    const lower = name.toLowerCase();
    const existing = tributeNameIndex.get(lower) || [];
    existing.push(offsetId);
    tributeNameIndex.set(lower, existing);
  }

  console.error(`[LocalData] Loaded ${tributes.size} tributes (${personalNames.size} personal, ${guildNames.size} guild)`);
}

// ============ OVERSEER ENHANCEMENT LOADER ============

async function loadOverseerEnhancements(): Promise<void> {
  if (overseerCategories !== null) return;

  overseerCategories = new Map();
  overseerDifficulties = new Map();
  overseerTraitDescs = new Map();
  overseerIncapNames = new Map();
  overseerIncapDescs = new Map();
  overseerJobNames = new Map();
  overseerArchetypeNames = new Map();
  overseerJobClassDescs = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([
    DBSTR_TYPES.OVERSEER_QUEST_CATEGORY, DBSTR_TYPES.OVERSEER_DIFFICULTY,
    DBSTR_TYPES.OVERSEER_TRAIT_DESC, DBSTR_TYPES.OVERSEER_INCAP_NAME,
    DBSTR_TYPES.OVERSEER_INCAP_DESC, DBSTR_TYPES.OVERSEER_JOB_NAME,
    DBSTR_TYPES.OVERSEER_SUCCESS, DBSTR_TYPES.OVERSEER_FAILURE,
    DBSTR_TYPES.OVERSEER_ARCHETYPE_NAME, DBSTR_TYPES.OVERSEER_JOB_CLASS_DESC,
  ]);
  const cats = dbStrings?.get(DBSTR_TYPES.OVERSEER_QUEST_CATEGORY) || new Map();
  const diffs = dbStrings?.get(DBSTR_TYPES.OVERSEER_DIFFICULTY) || new Map();
  const traitDs = dbStrings?.get(DBSTR_TYPES.OVERSEER_TRAIT_DESC) || new Map();
  const incapNs = dbStrings?.get(DBSTR_TYPES.OVERSEER_INCAP_NAME) || new Map();
  const incapDs = dbStrings?.get(DBSTR_TYPES.OVERSEER_INCAP_DESC) || new Map();
  const jobNs = dbStrings?.get(DBSTR_TYPES.OVERSEER_JOB_NAME) || new Map();
  const archNs = dbStrings?.get(DBSTR_TYPES.OVERSEER_ARCHETYPE_NAME) || new Map();
  const jobCDs = dbStrings?.get(DBSTR_TYPES.OVERSEER_JOB_CLASS_DESC) || new Map();

  for (const [id, name] of cats) overseerCategories.set(id, name);
  for (const [id, name] of diffs) overseerDifficulties.set(id, name);
  for (const [id, desc] of traitDs) overseerTraitDescs.set(id, desc);
  for (const [id, name] of incapNs) overseerIncapNames.set(id, name);
  for (const [id, desc] of incapDs) overseerIncapDescs.set(id, desc);
  for (const [id, name] of jobNs) overseerJobNames.set(id, name);
  for (const [id, name] of archNs) overseerArchetypeNames.set(id, name);
  for (const [id, desc] of jobCDs) overseerJobClassDescs.set(id, desc);

  // Load incapacitation durations from OvrQstIncapClient.txt
  overseerIncapDurations = new Map();
  try {
    const incapPath = join(EQ_GAME_PATH, 'Resources', 'OvrQstIncapClient.txt');
    const incapData = await readFile(incapPath, 'latin1');
    for (const line of incapData.split('\n')) {
      const parts = line.trim().split('^');
      if (parts.length >= 3) {
        const entryId = parseInt(parts[0]);
        const jobType = parseInt(parts[1]);
        const duration = parseInt(parts[2]);
        if (!isNaN(entryId) && !isNaN(jobType) && !isNaN(duration)) {
          overseerIncapDurations.set(entryId, { jobType, duration });
        }
      }
    }
  } catch {
    // File may not exist
  }

  console.error(`[LocalData] Loaded ${overseerCategories.size} categories, ${overseerDifficulties.size} difficulties, ${overseerIncapNames.size} incapacitations, ${overseerJobNames.size} job types, ${overseerArchetypeNames.size} archetypes`);
}

// ============ MAP POI PARSER (On-Demand) ============

function parseMapFile(data: string): MapPOI[] {
  const lines = data.split('\n');
  const pois: MapPOI[] = [];

  for (const line of lines) {
    if (!line.startsWith('P ')) continue;
    // Format: P x, y, z, r, g, b, size, label
    const parts = line.substring(2).split(',').map(s => s.trim());
    if (parts.length < 8) continue;

    const x = parseFloat(parts[0]);
    const y = parseFloat(parts[1]);
    const z = parseFloat(parts[2]);
    const r = parseInt(parts[3]);
    const g = parseInt(parts[4]);
    const b = parseInt(parts[5]);
    // parts[6] is size
    const label = parts.slice(7).join(',').trim();

    if (!isNaN(x) && !isNaN(y) && label) {
      pois.push({ x, y, z: isNaN(z) ? 0 : z, label, r, g, b });
    }
  }

  return pois;
}

// Map directory index: shortname -> directory path
let mapDirIndex: Map<string, string> | null = null;

async function buildMapDirIndex(): Promise<void> {
  if (mapDirIndex !== null) return;
  mapDirIndex = new Map();

  const mapsDirs = [
    gamePath('maps', 'Brewall'),
    gamePath('maps'),
  ];

  for (const mapsDir of mapsDirs) {
    if (!existsSync(mapsDir)) continue;
    try {
      const files = await readdir(mapsDir);
      for (const f of files) {
        if (!f.endsWith('.txt')) continue;
        const shortName = f.replace(/(_\d+)?\.txt$/i, '').toLowerCase();
        // Prefer Brewall (first in list) - don't overwrite if already found
        if (!mapDirIndex.has(shortName)) {
          mapDirIndex.set(shortName, mapsDir);
        }
      }
    } catch {
      continue;
    }
  }
  console.error(`[LocalData] Map directory index: ${mapDirIndex.size} zones`);
}

// Try to find the zone short name from a display name
function deriveShortName(displayName: string): string[] {
  const candidates: string[] = [];
  const lower = displayName.toLowerCase();

  // Direct: remove non-alphanumeric, strip "the"
  const stripped = lower.replace(/[^a-z0-9]/g, '').replace(/^the/, '');
  candidates.push(stripped);

  // Common EQ abbreviations - order matters, more specific first
  const abbrevs: [RegExp, string][] = [
    [/^the plane of /i, 'po'],
    [/^plane of /i, 'po'],
    [/^the ruins of /i, ''],
    [/^ruins of /i, ''],
    [/^the tower of /i, 'tower'],
    [/^tower of /i, 'tower'],
    [/^the city of /i, ''],
    [/^city of /i, ''],
    [/^the temple of /i, 'temple'],
    [/^temple of /i, 'temple'],
    [/^the mines of /i, ''],
    [/^mines of /i, ''],
    [/^the crypt of /i, ''],
    [/^crypt of /i, ''],
    [/^the halls of /i, ''],
    [/^halls of /i, ''],
    [/^the caverns of /i, ''],
    [/^caverns of /i, ''],
    [/^the lair of /i, ''],
    [/^lair of /i, ''],
    [/^north /i, 'n'],
    [/^south /i, 's'],
    [/^east /i, 'e'],
    [/^west /i, 'w'],
    [/^the /i, ''],
  ];

  for (const [pattern, prefix] of abbrevs) {
    if (pattern.test(lower)) {
      const rest = lower.replace(pattern, '').replace(/[^a-z0-9]/g, '');
      candidates.push(prefix + rest);
    }
  }

  // Also try just the first significant word
  const words = lower.replace(/^the /, '').split(/\s+/);
  if (words.length > 0) {
    candidates.push(words[0].replace(/[^a-z0-9]/g, ''));
  }

  return [...new Set(candidates)];
}

async function loadMapPOIs(zoneName: string): Promise<MapPOI[]> {
  const key = zoneName.toLowerCase();
  if (mapCache.has(key)) return mapCache.get(key)!;

  if (!isGameDataAvailable()) return [];

  await buildMapDirIndex();
  if (!mapDirIndex || mapDirIndex.size === 0) {
    mapCache.set(key, []);
    return [];
  }

  // Try to find the matching map shortname
  const candidates = deriveShortName(zoneName);
  let matchedShortName: string | null = null;
  let matchedDir: string | null = null;

  // First try exact matches
  for (const candidate of candidates) {
    if (mapDirIndex.has(candidate)) {
      matchedShortName = candidate;
      matchedDir = mapDirIndex.get(candidate)!;
      break;
    }
  }

  // If no exact match, try substring matching against index
  if (!matchedShortName) {
    for (const candidate of candidates) {
      if (candidate.length < 4) continue;
      for (const [shortName, dir] of mapDirIndex) {
        if (shortName.includes(candidate) || candidate.includes(shortName)) {
          matchedShortName = shortName;
          matchedDir = dir;
          break;
        }
      }
      if (matchedShortName) break;
    }
  }

  if (!matchedShortName || !matchedDir) {
    mapCache.set(key, []);
    return [];
  }

  // Load all matching map files (including layered files _1, _2, etc.)
  const allPois: MapPOI[] = [];
  try {
    const files = await readdir(matchedDir);
    const zoneFiles = files.filter(f => {
      const base = f.replace(/(_\d+)?\.txt$/i, '').toLowerCase();
      return base === matchedShortName;
    }).sort();

    for (const zoneFile of zoneFiles) {
      const data = await readFile(join(matchedDir, zoneFile), 'utf-8');
      allPois.push(...parseMapFile(data));
    }
  } catch {
    // ignore errors
  }

  // Deduplicate POIs by label (keep first occurrence)
  const seen = new Set<string>();
  const deduped = allPois.filter(poi => {
    const labelKey = poi.label.toLowerCase();
    if (seen.has(labelKey)) return false;
    seen.add(labelKey);
    return true;
  });

  mapCache.set(key, deduped);
  return deduped;
}

// ============ PUBLIC API: SPELL FUNCTIONS ============

export async function searchLocalSpells(query: string): Promise<SearchResult[]> {
  await loadSpells();
  if (!spells || spells.size === 0) return [];

  const normalized = normalizeQuery(query).toLowerCase();
  const results: SearchResult[] = [];
  const maxResults = 25;

  // First pass: exact name match
  for (const [id, spell] of spells) {
    if (spell.name.toLowerCase() === normalized) {
      results.push({
        name: spell.name,
        type: 'spell',
        id: id.toString(),
        url: `local://spell/${id}`,
        source: 'Local Game Data',
      });
    }
  }

  // Second pass: starts-with match
  if (results.length < maxResults) {
    for (const [id, spell] of spells) {
      if (results.length >= maxResults) break;
      if (results.some(r => r.id === id.toString())) continue;
      if (spell.name.toLowerCase().startsWith(normalized)) {
        results.push({
          name: spell.name,
          type: 'spell',
          id: id.toString(),
          url: `local://spell/${id}`,
          source: 'Local Game Data',
        });
      }
    }
  }

  // Third pass: contains match
  if (results.length < maxResults) {
    for (const [id, spell] of spells) {
      if (results.length >= maxResults) break;
      if (results.some(r => r.id === id.toString())) continue;
      if (spell.name.toLowerCase().includes(normalized)) {
        results.push({
          name: spell.name,
          type: 'spell',
          id: id.toString(),
          url: `local://spell/${id}`,
          source: 'Local Game Data',
        });
      }
    }
  }

  return results;
}

export async function searchSpellsByName(query: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const normalized = query.toLowerCase();
  const matches: { id: number; name: string; level: number; classes: string[] }[] = [];

  // Search by name
  for (const [id, spell] of spells) {
    const f = spell.fields;
    const spellName = spell.name;
    const lowerName = spellName.toLowerCase();

    let match = false;
    if (lowerName === normalized) match = true;
    else if (lowerName.startsWith(normalized)) match = true;
    else if (lowerName.includes(normalized)) match = true;

    if (match) {
      // Get class info
      const classes: string[] = [];
      let minLevel = 255;
      const CLASS_NAMES_SHORT = ['WAR','CLR','PAL','RNG','SHD','DRU','MNK','BRD','ROG','SHM','NEC','WIZ','MAG','ENC','BST','BER'];
      for (let c = 0; c < 16; c++) {
        const lvl = parseInt(f[SF.CLASS_LEVEL_START + c]);
        if (!isNaN(lvl) && lvl > 0 && lvl < 255) {
          classes.push(`${CLASS_NAMES_SHORT[c]}(${lvl})`);
          if (lvl < minLevel) minLevel = lvl;
        }
      }
      matches.push({ id, name: spellName, level: minLevel < 255 ? minLevel : 0, classes });
    }

    if (matches.length >= 50) break;
  }

  if (matches.length === 0) {
    return `No spells found matching "${query}".`;
  }

  // Sort: exact match first, then by name, then by ID
  matches.sort((a, b) => {
    const aExact = a.name.toLowerCase() === normalized ? 0 : 1;
    const bExact = b.name.toLowerCase() === normalized ? 0 : 1;
    if (aExact !== bExact) return aExact - bExact;
    return a.name.localeCompare(b.name) || a.id - b.id;
  });

  const lines = [`## Spells matching "${query}"`, '', `**Found:** ${matches.length} spell${matches.length !== 1 ? 's' : ''}`, ''];

  for (const m of matches) {
    const classStr = m.classes.length > 0 ? m.classes.join(', ') : 'No class';
    lines.push(`- **${m.name}** [ID: ${m.id}] - ${classStr}`);
  }

  if (matches.length >= 50) {
    lines.push('', '*Results limited to 50. Use a more specific search term.*');
  }

  return lines.join('\n');
}

export async function searchSpellsByResist(resistType: string, className?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve resist type
  const lowerResist = resistType.toLowerCase();
  let resistTypeId: number | undefined;
  for (const [id, name] of Object.entries(RESIST_TYPES)) {
    if (name.toLowerCase() === lowerResist || name.toLowerCase().startsWith(lowerResist)) {
      resistTypeId = parseInt(id);
      break;
    }
  }
  if (resistTypeId === undefined) {
    const validResists = Object.values(RESIST_TYPES).join(', ');
    return `Unknown resist type: "${resistType}". Valid types: ${validResists}`;
  }

  // Optional class filter
  let classId: number | undefined;
  let classIndex: number | undefined;
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classIndex = classId - 1;
  }

  const CLASS_NAMES_SHORT = ['WAR','CLR','PAL','RNG','SHD','DRU','MNK','BRD','ROG','SHM','NEC','WIZ','MAG','ENC','BST','BER'];
  const matches: { id: number; name: string; level: number; classes: string[]; category?: string; beneficial: boolean }[] = [];

  for (const [id, spell] of spells) {
    const f = spell.fields;

    // Resist type filter
    const spellResist = parseInt(f[SF.RESIST_TYPE]);
    if (spellResist !== resistTypeId) continue;

    // Class filter
    let classLevel = 0;
    if (classIndex !== undefined) {
      const lvl = parseInt(f[SF.CLASS_LEVEL_START + classIndex]);
      if (isNaN(lvl) || lvl === 255 || lvl <= 0) continue;
      classLevel = lvl;
    }

    // Get class info
    const classes: string[] = [];
    let minLevel = 255;
    for (let c = 0; c < 16; c++) {
      const lvl = parseInt(f[SF.CLASS_LEVEL_START + c]);
      if (!isNaN(lvl) && lvl > 0 && lvl < 255) {
        classes.push(`${CLASS_NAMES_SHORT[c]}(${lvl})`);
        if (lvl < minLevel) minLevel = lvl;
      }
    }

    let category: string | undefined;
    if (spellCategories) {
      const catId = parseInt(f[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) category = spellCategories.get(catId);
    }

    matches.push({
      id,
      name: spell.name,
      level: classLevel || (minLevel < 255 ? minLevel : 0),
      classes,
      category,
      beneficial: f[SF.BENEFICIAL] === '1',
    });

    if (matches.length >= 100) break;
  }

  if (matches.length === 0) {
    const classLabel = classId ? ` for ${CLASS_IDS[classId]}` : '';
    return `No ${RESIST_TYPES[resistTypeId]} spells found${classLabel}.`;
  }

  // Sort by level then name
  matches.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  const classLabel = classId ? ` - ${CLASS_IDS[classId]}` : '';
  const lines = [
    `## ${RESIST_TYPES[resistTypeId]} Spells${classLabel}`,
    `*${matches.length} spells found${matches.length >= 100 ? ' (limited to 100)' : ''}*`,
    '',
  ];

  for (const m of matches) {
    const catStr = m.category ? ` [${m.category}]` : '';
    const classStr = !classId && m.classes.length > 0 ? ` - ${m.classes.join(', ')}` : '';
    lines.push(`- **${m.name}** (ID: ${m.id})${catStr}${classStr}`);
  }

  return lines.join('\n');
}

export async function searchSpellsByTarget(targetType: string, className?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve target type - support common aliases
  const lowerTarget = targetType.toLowerCase();
  const TARGET_ALIASES: Record<string, number[]> = {
    'single': [5],
    'self': [6],
    'group': [3, 41],
    'ae': [4, 8, 2, 40, 42, 44, 46],
    'pb ae': [4], 'pbae': [4], 'pbaoe': [4],
    'targeted ae': [8], 'target ae': [8], 'rain': [8],
    'directional': [42], 'cone': [42],
    'beam': [44],
    'target ring': [46], 'ring': [46],
    'pet': [14],
    'corpse': [15],
    'undead': [10],
    'animal': [9],
    'lifetap': [13],
    'free target': [36],
    'los': [1], 'line of sight': [1],
  };

  let targetIds: number[] | undefined;
  // Check aliases first
  for (const [alias, ids] of Object.entries(TARGET_ALIASES)) {
    if (alias === lowerTarget || alias.startsWith(lowerTarget)) {
      targetIds = ids;
      break;
    }
  }
  // Also check TARGET_TYPES names directly
  if (!targetIds) {
    for (const [id, name] of Object.entries(TARGET_TYPES)) {
      if (name.toLowerCase().includes(lowerTarget)) {
        targetIds = targetIds || [];
        targetIds.push(parseInt(id));
      }
    }
  }
  if (!targetIds || targetIds.length === 0) {
    const validTypes = ['Single', 'Self', 'Group', 'AE (all AE types)', 'PB AE', 'Targeted AE', 'Directional/Cone', 'Beam', 'Target Ring', 'Pet', 'Corpse', 'Undead', 'Animal', 'Lifetap'];
    return `Unknown target type: "${targetType}". Valid types: ${validTypes.join(', ')}`;
  }

  const targetIdSet = new Set(targetIds);

  // Optional class filter
  let classId: number | undefined;
  let classIndex: number | undefined;
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classIndex = classId - 1;
  }

  const CLASS_NAMES_SHORT = ['WAR','CLR','PAL','RNG','SHD','DRU','MNK','BRD','ROG','SHM','NEC','WIZ','MAG','ENC','BST','BER'];
  const matches: { id: number; name: string; level: number; classes: string[]; category?: string; targetName: string }[] = [];

  for (const [id, spell] of spells) {
    const f = spell.fields;

    // Target type filter
    const spellTarget = parseInt(f[SF.TARGET_TYPE]);
    if (!targetIdSet.has(spellTarget)) continue;

    // Class filter
    let classLevel = 0;
    if (classIndex !== undefined) {
      const lvl = parseInt(f[SF.CLASS_LEVEL_START + classIndex]);
      if (isNaN(lvl) || lvl === 255 || lvl <= 0) continue;
      classLevel = lvl;
    }

    // Get class info
    const classes: string[] = [];
    let minLevel = 255;
    for (let c = 0; c < 16; c++) {
      const lvl = parseInt(f[SF.CLASS_LEVEL_START + c]);
      if (!isNaN(lvl) && lvl > 0 && lvl < 255) {
        classes.push(`${CLASS_NAMES_SHORT[c]}(${lvl})`);
        if (lvl < minLevel) minLevel = lvl;
      }
    }

    let category: string | undefined;
    if (spellCategories) {
      const catId = parseInt(f[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) category = spellCategories.get(catId);
    }

    matches.push({
      id,
      name: spell.name,
      level: classLevel || (minLevel < 255 ? minLevel : 0),
      classes,
      category,
      targetName: TARGET_TYPES[spellTarget] || `Type ${spellTarget}`,
    });

    if (matches.length >= 100) break;
  }

  if (matches.length === 0) {
    const classLabel = classId ? ` for ${CLASS_IDS[classId]}` : '';
    return `No spells found with target type "${targetType}"${classLabel}.`;
  }

  // Sort by level then name
  matches.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  const classLabel = classId ? ` - ${CLASS_IDS[classId]}` : '';
  const targetLabel = targetIds.length === 1
    ? (TARGET_TYPES[targetIds[0]] || targetType)
    : targetType.charAt(0).toUpperCase() + targetType.slice(1);
  const lines = [
    `## ${targetLabel} Spells${classLabel}`,
    `*${matches.length} spells found${matches.length >= 100 ? ' (limited to 100)' : ''}*`,
    '',
  ];

  for (const m of matches) {
    const catStr = m.category ? ` [${m.category}]` : '';
    const targetStr = targetIds.length > 1 ? ` {${m.targetName}}` : '';
    const classStr = !classId && m.classes.length > 0 ? ` - ${m.classes.join(', ')}` : '';
    lines.push(`- **${m.name}** (ID: ${m.id})${catStr}${targetStr}${classStr}`);
  }

  return lines.join('\n');
}

export async function searchSpellsByDescription(query: string, className?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';
  if (!spellDescriptions || spellDescriptions.size === 0) return 'Spell descriptions not available.';

  const normalized = query.toLowerCase();

  // Optional class filter
  let classId: number | undefined;
  let classIndex: number | undefined;
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classIndex = classId - 1;
  }

  const CLASS_NAMES_SHORT = ['WAR','CLR','PAL','RNG','SHD','DRU','MNK','BRD','ROG','SHM','NEC','WIZ','MAG','ENC','BST','BER'];
  const matches: { id: number; name: string; desc: string; classes: string[] }[] = [];

  for (const [spellId, desc] of spellDescriptions) {
    if (!desc.toLowerCase().includes(normalized)) continue;

    const spell = spells.get(spellId);
    if (!spell) continue;

    // Class filter
    if (classIndex !== undefined) {
      const lvl = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
      if (isNaN(lvl) || lvl === 255 || lvl <= 0) continue;
    }

    // Get class info
    const classes: string[] = [];
    for (let c = 0; c < 16; c++) {
      const lvl = parseInt(spell.fields[SF.CLASS_LEVEL_START + c]);
      if (!isNaN(lvl) && lvl > 0 && lvl < 255) {
        classes.push(`${CLASS_NAMES_SHORT[c]}(${lvl})`);
      }
    }

    // Truncate description for display
    const shortDesc = desc.length > 100 ? desc.substring(0, 100) + '...' : desc;

    matches.push({ id: spellId, name: spell.name, desc: shortDesc, classes });
    if (matches.length >= 50) break;
  }

  if (matches.length === 0) {
    const classLabel = classId ? ` for ${CLASS_IDS[classId]}` : '';
    return `No spells found with description matching "${query}"${classLabel}.`;
  }

  matches.sort((a, b) => a.name.localeCompare(b.name));

  const classLabel = classId ? ` - ${CLASS_IDS[classId]}` : '';
  const lines = [
    `## Spells with description matching "${query}"${classLabel}`,
    `*${matches.length} spells found${matches.length >= 50 ? ' (limited to 50)' : ''}*`,
    '',
  ];

  for (const m of matches) {
    const classStr = !classId && m.classes.length > 0 ? ` - ${m.classes.join(', ')}` : '';
    lines.push(`- **${m.name}** (ID: ${m.id})${classStr}`);
    lines.push(`  *${m.desc}*`);
  }

  return lines.join('\n');
}

export async function searchTimerGroup(timerGroupOrSpell: string, className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let timerId: number;

  // Try parsing as a number first
  const parsed = parseInt(timerGroupOrSpell);
  if (!isNaN(parsed) && parsed > 0) {
    timerId = parsed;
  } else {
    // Try finding the spell by name and getting its timer group
    const normalized = timerGroupOrSpell.toLowerCase();
    let foundTimer: number | undefined;
    for (const [, spell] of spells) {
      if (spell.name.toLowerCase() === normalized) {
        const t = parseInt(spell.fields[SF.TIMER_ID]);
        if (!isNaN(t) && t > 0) {
          foundTimer = t;
          break;
        }
      }
    }
    if (!foundTimer) {
      // Fuzzy search
      for (const [, spell] of spells) {
        if (spell.name.toLowerCase().includes(normalized)) {
          const t = parseInt(spell.fields[SF.TIMER_ID]);
          if (!isNaN(t) && t > 0) {
            foundTimer = t;
            break;
          }
        }
      }
    }
    if (!foundTimer) {
      return `No timer group found for "${timerGroupOrSpell}". Provide a timer group number (1-22) or a spell/discipline name that uses a timer group.`;
    }
    timerId = foundTimer;
  }

  // Optional class filter
  let classId: number | undefined;
  let classIndex: number | undefined;
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classIndex = classId - 1;
  }

  const CLASS_NAMES_SHORT = ['WAR','CLR','PAL','RNG','SHD','DRU','MNK','BRD','ROG','SHM','NEC','WIZ','MAG','ENC','BST','BER'];
  const matches: { id: number; name: string; level: number; recast: number; classes: string[] }[] = [];

  for (const [spellId, spell] of spells) {
    const t = parseInt(spell.fields[SF.TIMER_ID]);
    if (t !== timerId) continue;

    // Class filter
    if (classIndex !== undefined) {
      const lvl = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
      if (isNaN(lvl) || lvl === 255 || lvl <= 0) continue;
    }

    // Get class info and min level
    const classes: string[] = [];
    let minLevel = 999;
    for (let c = 0; c < 16; c++) {
      const lvl = parseInt(spell.fields[SF.CLASS_LEVEL_START + c]);
      if (!isNaN(lvl) && lvl > 0 && lvl < 255) {
        classes.push(`${CLASS_NAMES_SHORT[c]}(${lvl})`);
        if (lvl < minLevel) minLevel = lvl;
      }
    }

    const recast = parseInt(spell.fields[SF.RECAST_TIME]) || 0;

    matches.push({ id: spellId, name: spell.name, level: minLevel, recast, classes });
  }

  if (matches.length === 0) {
    const classLabel = classId ? ` for ${CLASS_IDS[classId]}` : '';
    return `No spells found on timer group ${timerId}${classLabel}.`;
  }

  // Sort by level then name
  matches.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  const classLabel = classId ? ` - ${CLASS_IDS[classId]}` : '';
  const lines = [
    `## Timer Group ${timerId}${classLabel}`,
    `*${matches.length} spells/abilities share this reuse timer*`,
    '',
  ];

  const shown = matches.slice(0, 100);
  for (const m of shown) {
    const recastStr = m.recast > 0 ? ` — recast ${(m.recast / 1000).toFixed(0)}s` : '';
    const classStr = !classId && m.classes.length > 0 && m.classes.length <= 8 ? ` — ${m.classes.join(', ')}` : '';
    lines.push(`- **${m.name}** (ID: ${m.id})${recastStr}${classStr}`);
  }

  if (matches.length > 100) {
    lines.push(`*...and ${matches.length - 100} more*`);
  }

  return lines.join('\n');
}

export async function compareSpells(spell1: string, spell2: string): Promise<string> {
  await loadSpells();
  await loadSpellStrings();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve both spells (by ID or name)
  const resolve = (input: string): LocalSpell | null => {
    const id = parseInt(input);
    if (!isNaN(id) && spells!.has(id)) return spells!.get(id) || null;
    // Search by name (exact first, then case-insensitive)
    const lower = input.toLowerCase();
    for (const [, sp] of spells!) {
      if (sp.name === input) return sp;
    }
    for (const [, sp] of spells!) {
      if (sp.name.toLowerCase() === lower) return sp;
    }
    return null;
  };

  const s1 = resolve(spell1);
  const s2 = resolve(spell2);

  if (!s1) return `Spell not found: "${spell1}"`;
  if (!s2) return `Spell not found: "${spell2}"`;

  const d1 = buildLocalSpellData(s1);
  const d2 = buildLocalSpellData(s2);

  // Collect spell strings
  const str1 = spellStrings?.get(s1.id);
  const str2 = spellStrings?.get(s2.id);

  // Spell descriptions
  const desc1 = spellDescriptions?.get(s1.id) || '';
  const desc2 = spellDescriptions?.get(s2.id) || '';

  const lines = [
    `## Spell Comparison`,
    '',
    `| Property | ${d1.name} | ${d2.name} |`,
    '|----------|' + '-'.repeat(d1.name.length + 2) + '|' + '-'.repeat(d2.name.length + 2) + '|',
    `| **ID** | ${d1.id} | ${d2.id} |`,
  ];

  // Helper to add comparison row with diff marking
  const addRow = (label: string, v1: string | number | undefined, v2: string | number | undefined) => {
    const s1v = v1 !== undefined ? String(v1) : '—';
    const s2v = v2 !== undefined ? String(v2) : '—';
    const marker = s1v !== s2v ? ' ⚡' : '';
    lines.push(`| **${label}** | ${s1v} | ${s2v}${marker} |`);
  };

  addRow('Mana', d1.mana, d2.mana);
  addRow('Endurance', d1.endurance, d2.endurance);
  addRow('Cast Time', d1.castTime, d2.castTime);
  addRow('Recast', d1.recastTime, d2.recastTime);
  addRow('Recovery', d1.recoveryTime, d2.recoveryTime);
  addRow('Duration', d1.duration, d2.duration);
  addRow('Range', d1.range, d2.range);
  addRow('AE Range', d1.aeRange, d2.aeRange);
  addRow('Target', d1.target, d2.target);
  addRow('Resist', d1.resist, d2.resist);
  addRow('Beneficial', d1.beneficial ? 'Yes' : 'No', d2.beneficial ? 'Yes' : 'No');
  addRow('Category', d1.category, d2.category);
  addRow('Timer Group', d1.timerId, d2.timerId);
  if (d1.pushBack || d2.pushBack) addRow('Push Back', d1.pushBack, d2.pushBack);
  if (d1.recourseId || d2.recourseId) {
    addRow('Recourse', d1.recourseName ? `${d1.recourseName} [${d1.recourseId}]` : d1.recourseId, d2.recourseName ? `${d2.recourseName} [${d2.recourseId}]` : d2.recourseId);
  }
  if (d1.teleportZone || d2.teleportZone) addRow('Teleport Zone', d1.teleportZone, d2.teleportZone);

  // Classes comparison
  const allClasses = new Set<string>();
  if (d1.classes) Object.keys(d1.classes).forEach(c => allClasses.add(c));
  if (d2.classes) Object.keys(d2.classes).forEach(c => allClasses.add(c));

  if (allClasses.size > 0) {
    lines.push('', '### Class Levels');
    lines.push(`| Class | ${d1.name} | ${d2.name} |`);
    lines.push('|-------|' + '-'.repeat(d1.name.length + 2) + '|' + '-'.repeat(d2.name.length + 2) + '|');
    for (const cls of [...allClasses].sort()) {
      const l1 = d1.classes?.[cls];
      const l2 = d2.classes?.[cls];
      const diff = (l1 || 0) !== (l2 || 0) ? ' ⚡' : '';
      lines.push(`| ${cls} | ${l1 || '—'} | ${l2 || '—'}${diff} |`);
    }
  }

  // Effects comparison
  if (d1.effects || d2.effects) {
    lines.push('', '### Effects');
    const e1 = d1.effects || [];
    const e2 = d2.effects || [];
    const maxLen = Math.max(e1.length, e2.length);
    for (let i = 0; i < maxLen; i++) {
      const eff1 = e1[i] || '—';
      const eff2 = e2[i] || '—';
      const diff = eff1 !== eff2 ? ' ⚡' : '';
      lines.push(`- **${d1.name}:** ${eff1}`);
      lines.push(`  **${d2.name}:** ${eff2}${diff}`);
      if (i < maxLen - 1) lines.push('');
    }
  }

  // Descriptions
  if (desc1 || desc2) {
    lines.push('', '### Descriptions');
    if (desc1) lines.push(`**${d1.name}:** ${desc1}`);
    if (desc2) lines.push(`**${d2.name}:** ${desc2}`);
  }

  // Cast messages
  if (str1 || str2) {
    const msgs1 = str1 ? [str1.casterMe, str1.castedMe].filter(Boolean) : [];
    const msgs2 = str2 ? [str2.casterMe, str2.castedMe].filter(Boolean) : [];
    if (msgs1.length > 0 || msgs2.length > 0) {
      lines.push('', '### Cast Messages');
      if (msgs1.length > 0) lines.push(`**${d1.name}:** ${msgs1.join(' / ')}`);
      if (msgs2.length > 0) lines.push(`**${d2.name}:** ${msgs2.join(' / ')}`);
    }
  }

  return lines.join('\n');
}

export async function getLocalSpell(id: string): Promise<SpellData | null> {
  await loadSpells();
  await loadSpellStrings();
  await loadSpellDescriptions();
  if (!spells) return null;

  const spellId = parseInt(id);
  const spell = spells.get(spellId);
  if (!spell) return null;

  const data = buildLocalSpellData(spell);

  // Add spell description from dbstr_us.txt with placeholder resolution
  const desc = spellDescriptions?.get(spellId);
  if (desc) {
    data.description = resolveSpellDescription(desc, spell.fields, data.duration);
  }

  // Add spell strings if available
  const strings = spellStrings?.get(spellId);
  if (strings) {
    const msgs: string[] = [];
    if (strings.castedMe) msgs.push(`You: ${strings.castedMe}`);
    if (strings.castedOther) msgs.push(`Others see: ${strings.castedOther}`);
    if (strings.spellGone) msgs.push(`Fades: ${strings.spellGone}`);
    if (msgs.length > 0) {
      data.raw = msgs.join('\n');
    }
  }

  // Add stacking info if available
  await loadSpellStacking();
  const stackInfo = spellStacking?.get(spellId);
  if (stackInfo && stackInfo.length > 0) {
    const stackEffects = stackInfo.map(s => {
      const groupName = spellGroupNames?.get(s.stackingGroup);
      const groupLabel = groupName ? `${groupName} (Group ${s.stackingGroup})` : `Group ${s.stackingGroup}`;
      return `${groupLabel}, Rank ${s.rank}, Type ${s.stackingType}`;
    });
    data.effects = [...(data.effects || []), ...stackEffects.map(s => `[Stacking] ${s}`)];
  }

  return data;
}

export async function getLocalSpellByName(name: string): Promise<SpellData | null> {
  await loadSpells();
  if (!spells || !spellNameIndex) return null;

  const lowerName = name.toLowerCase();
  const ids = spellNameIndex.get(lowerName);
  if (ids && ids.length > 0) {
    return getLocalSpell(ids[0].toString());
  }

  // Fuzzy fallback
  for (const [key, ids] of spellNameIndex) {
    if (fuzzyMatch(name, key)) {
      return getLocalSpell(ids[0].toString());
    }
  }

  return null;
}

// ============ PUBLIC API: ZONE FUNCTIONS ============

export async function searchLocalZones(query: string): Promise<SearchResult[]> {
  await loadZones();
  if (!zones || zones.size === 0) return [];

  const normalized = normalizeQuery(query).toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, zone] of zones) {
    if (results.length >= 20) break;
    if (zone.name.toLowerCase().includes(normalized) ||
        fuzzyMatch(query, zone.name)) {
      const levelStr = zone.levelMin > 0 || zone.levelMax > 0
        ? ` (${zone.levelMin}-${zone.levelMax})`
        : '';
      results.push({
        name: zone.name,
        type: 'zone',
        id: id.toString(),
        url: `local://zone/${id}`,
        source: 'Local Game Data',
        description: `Level${levelStr}`,
      });
    }
  }

  // Sort: exact > starts-with > contains
  const lower = normalized.toLowerCase();
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aExact = aName === lower ? 3 : aName.startsWith(lower) ? 2 : 1;
    const bExact = bName === lower ? 3 : bName.startsWith(lower) ? 2 : 1;
    return bExact - aExact;
  });

  return results;
}

export async function getLocalZone(id: string): Promise<ZoneData | null> {
  await loadZones();
  if (!zones) return null;

  const zoneId = parseInt(id);
  const zone = zones.get(zoneId);
  if (!zone) return null;

  const levelRange = zone.levelMin > 0 || zone.levelMax > 0
    ? `${zone.levelMin}-${zone.levelMax}`
    : undefined;

  // Try to load map POIs for this zone (pass original display name for smart matching)
  const pois = await loadMapPOIs(zone.name);

  const data: ZoneData = {
    name: zone.name,
    id: zoneId.toString(),
    source: 'Local Game Data',
    levelRange,
  };

  if (pois.length > 0) {
    data.notableLocations = pois.map(poi => ({
      name: poi.label,
      coordinates: { x: poi.x, y: poi.y, z: poi.z },
    }));
  }

  return data;
}

// ============ PUBLIC API: SKILL CAPS ============

export async function getSkillCaps(className: string, level?: number, skillName?: string): Promise<string> {
  await loadSkillCaps();
  if (!skillCaps || skillCaps.length === 0) return 'Skill cap data not available.';

  // Resolve class ID
  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  // Resolve skill ID if provided
  let targetSkillId: number | undefined;
  if (skillName) {
    const lowerSkill = skillName.toLowerCase();
    for (const [id, name] of Object.entries(SKILL_NAMES)) {
      if (name.toLowerCase() === lowerSkill || name.toLowerCase().includes(lowerSkill)) {
        targetSkillId = parseInt(id);
        break;
      }
    }
    if (targetSkillId === undefined) {
      return `Unknown skill: "${skillName}". Some skills: ${Object.values(SKILL_NAMES).slice(0, 20).join(', ')}...`;
    }
  }

  // Filter entries
  let entries = skillCaps.filter(e => e.classId === classId);
  if (targetSkillId !== undefined) {
    entries = entries.filter(e => e.skillId === targetSkillId);
  }
  if (level !== undefined) {
    entries = entries.filter(e => e.level === level);
  }

  if (entries.length === 0) {
    return `No skill cap data found for ${CLASS_IDS[classId]}${level ? ` level ${level}` : ''}${skillName ? ` ${skillName}` : ''}.`;
  }

  const lines = [`## Skill Caps: ${CLASS_IDS[classId]}${level ? ` (Level ${level})` : ''}`, ''];

  if (targetSkillId !== undefined) {
    // Show all levels for one skill
    lines.push(`### ${SKILL_NAMES[targetSkillId] || `Skill ${targetSkillId}`}`);
    lines.push('| Level | Cap |');
    lines.push('|-------|-----|');
    for (const entry of entries.sort((a, b) => a.level - b.level)) {
      if (entry.cap > 0) {
        lines.push(`| ${entry.level} | ${entry.cap} |`);
      }
    }
  } else if (level !== undefined) {
    // Show all skills for one level
    lines.push('| Skill | Cap |');
    lines.push('|-------|-----|');
    for (const entry of entries.sort((a, b) => a.skillId - b.skillId)) {
      if (entry.cap > 0) {
        const sName = SKILL_NAMES[entry.skillId] || `Skill ${entry.skillId}`;
        lines.push(`| ${sName} | ${entry.cap} |`);
      }
    }
  } else {
    // Show summary: max cap for each skill
    const skillMaxes: Record<number, number> = {};
    for (const entry of entries) {
      if (!skillMaxes[entry.skillId] || entry.cap > skillMaxes[entry.skillId]) {
        skillMaxes[entry.skillId] = entry.cap;
      }
    }

    lines.push('| Skill | Max Cap |');
    lines.push('|-------|---------|');
    for (const [sid, cap] of Object.entries(skillMaxes).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
      if (cap > 0) {
        const sName = SKILL_NAMES[parseInt(sid)] || `Skill ${sid}`;
        lines.push(`| ${sName} | ${cap} |`);
      }
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: BASE STATS ============

export async function getBaseStats(className: string, level?: number): Promise<string> {
  await loadBaseStats();
  if (!baseStats || baseStats.length === 0) return 'Base stat data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  let entries = baseStats.filter(e => e.classId === classId);
  if (level !== undefined) {
    entries = entries.filter(e => e.level === level);
  }

  if (entries.length === 0) {
    return `No base stat data found for ${CLASS_IDS[classId]}${level ? ` level ${level}` : ''}.`;
  }

  const lines = [`## Base Stats: ${CLASS_IDS[classId]}${level ? ` (Level ${level})` : ''}`, ''];

  lines.push('| Level | HP | Mana | Endurance | HP Regen | Mana Regen | End Regen |');
  lines.push('|-------|-----|------|-----------|----------|------------|-----------|');

  const displayEntries = level ? entries : entries.filter((_, i) => i % 5 === 0 || i === entries.length - 1);
  for (const e of displayEntries.sort((a, b) => a.level - b.level)) {
    lines.push(`| ${e.level} | ${e.hp} | ${e.mana} | ${e.endurance} | ${e.hpRegen.toFixed(3)} | ${e.manaRegen.toFixed(3)} | ${e.enduranceRegen.toFixed(3)} |`);
  }

  if (!level) {
    lines.push('', `*Showing every 5th level. Total entries: ${entries.length}*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: ACHIEVEMENTS ============

export async function searchAchievements(query: string, category?: string): Promise<SearchResult[]> {
  await loadAchievements();
  await loadAchievementCategories();
  if (!achievements || achievements.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  // If category filter specified, find matching category IDs
  let filterCategoryIds: Set<number> | null = null;
  if (category && achievementCategories && categoryToAchievements) {
    const catNorm = category.toLowerCase();
    filterCategoryIds = new Set<number>();
    for (const [catId, cat] of achievementCategories) {
      if (cat.name.toLowerCase().includes(catNorm) || cat.description.toLowerCase().includes(catNorm)) {
        // Add this category's achievements
        const achIds = categoryToAchievements.get(catId);
        if (achIds) achIds.forEach(id => filterCategoryIds!.add(id));
        // Also add achievements from child categories
        for (const [childId, childCat] of achievementCategories) {
          if (childCat.parentId === catId) {
            const childAchIds = categoryToAchievements.get(childId);
            if (childAchIds) childAchIds.forEach(id => filterCategoryIds!.add(id));
          }
        }
      }
    }
  }

  for (const [id, ach] of achievements) {
    if (results.length >= 25) break;
    // Apply category filter if specified
    if (filterCategoryIds && !filterCategoryIds.has(id)) continue;
    if (ach.name.toLowerCase().includes(normalized) ||
        ach.description.toLowerCase().includes(normalized)) {
      results.push({
        name: ach.name,
        type: 'quest' as const,
        id: id.toString(),
        url: `local://achievement/${id}`,
        source: 'Local Game Data',
        description: ach.description.substring(0, 100) + (ach.description.length > 100 ? '...' : ''),
      });
    }
  }

  return results;
}

export async function getAchievement(id: string): Promise<string> {
  await loadAchievements();
  await loadAchievementCategories();
  await loadAchievementComponents();
  if (!achievements) return 'Achievement data not available.';

  const achId = parseInt(id);
  const ach = achievements.get(achId);
  if (!ach) return `Achievement with ID ${id} not found.`;

  const lines = [
    `## ${ach.name}`,
    '',
    ach.description,
    '',
    `**Points:** ${ach.points}`,
  ];

  if (ach.hidden) lines.push(`**Hidden:** Yes`);
  if (ach.locked) lines.push(`**Locked:** Yes`);

  if (ach.rewardId > 0) {
    lines.push(`**Reward ID:** ${ach.rewardId}`);
  }

  // Add category path
  const categoryIds = achievementToCategories?.get(achId);
  if (categoryIds && categoryIds.length > 0 && achievementCategories) {
    const categoryPaths: string[] = [];
    for (const catId of categoryIds) {
      const parts: string[] = [];
      let current = achievementCategories.get(catId);
      while (current) {
        parts.unshift(current.name);
        current = current.parentId ? achievementCategories.get(current.parentId) : undefined;
      }
      if (parts.length > 0) categoryPaths.push(parts.join(' > '));
    }
    if (categoryPaths.length > 0) {
      lines.push(`**Category:** ${categoryPaths.join('; ')}`);
    }
  }

  // Add components/steps
  const components = achievementComponents?.get(achId);
  if (components && components.length > 0) {
    lines.push('', '### Steps');
    for (const comp of components.sort((a, b) => a.componentNum - b.componentNum)) {
      lines.push(`${comp.componentNum}. ${comp.description}`);
    }
  }

  return lines.join('\n');
}

export async function listAchievementCategories(): Promise<string> {
  await loadAchievementCategories();
  await loadAchievements();
  if (!achievementCategories || achievementCategories.size === 0) return 'Achievement category data not available.';

  // Build top-level -> subcategory tree
  const topLevel: AchievementCategory[] = [];
  const children: Map<number, AchievementCategory[]> = new Map();

  for (const [, cat] of achievementCategories) {
    if (!cat.parentId) {
      topLevel.push(cat);
    } else {
      const existing = children.get(cat.parentId) || [];
      existing.push(cat);
      children.set(cat.parentId, existing);
    }
  }

  // Sort top-level by order
  topLevel.sort((a, b) => a.order - b.order);

  const lines = ['## Achievement Categories', ''];

  for (const top of topLevel) {
    // Count achievements in this top-level category (sum of all subcategories)
    let totalCount = 0;
    const subs = children.get(top.id) || [];
    subs.sort((a, b) => a.order - b.order);

    // Count direct achievements in top-level category
    const directCount = categoryToAchievements?.get(top.id)?.length || 0;
    totalCount += directCount;
    for (const sub of subs) {
      totalCount += categoryToAchievements?.get(sub.id)?.length || 0;
    }

    lines.push(`### ${top.name} (ID: ${top.id}) — ${totalCount} achievements`);
    if (subs.length > 0) {
      for (const sub of subs) {
        const count = categoryToAchievements?.get(sub.id)?.length || 0;
        lines.push(`  - ${sub.name} (ID: ${sub.id}) — ${count} achievements`);
      }
    }
    lines.push('');
  }

  lines.push(`*${achievementCategories.size} total categories, ${achievements?.size || 0} total achievements*`);
  return lines.join('\n');
}

export async function getAchievementsByCategory(categoryId: string): Promise<string> {
  await loadAchievementCategories();
  await loadAchievements();
  if (!achievementCategories || !achievements) return 'Achievement data not available.';

  const catId = parseInt(categoryId);
  const cat = achievementCategories.get(catId);
  if (!cat) return `Achievement category with ID ${categoryId} not found.`;

  const lines = [`## ${cat.name}`];
  if (cat.description && cat.description !== cat.name) {
    lines.push(`*${cat.description}*`);
  }
  lines.push('');

  // Check if this is a top-level category with subcategories
  const subs: AchievementCategory[] = [];
  for (const [, c] of achievementCategories) {
    if (c.parentId === catId) subs.push(c);
  }

  if (subs.length > 0) {
    // Top-level category: show subcategories with their achievements
    subs.sort((a, b) => a.order - b.order);
    for (const sub of subs) {
      const achIds = categoryToAchievements?.get(sub.id) || [];
      lines.push(`### ${sub.name} (ID: ${sub.id}) — ${achIds.length} achievements`);
      // Show first 15 achievements per subcategory
      const shown = achIds.slice(0, 15);
      for (const achId of shown) {
        const ach = achievements.get(achId);
        if (ach) {
          lines.push(`- **${ach.name}** (ID: ${achId}) — ${ach.points} pts`);
        }
      }
      if (achIds.length > 15) {
        lines.push(`  *...and ${achIds.length - 15} more*`);
      }
      lines.push('');
    }
  }

  // Also show direct achievements in this category
  const directAchIds = categoryToAchievements?.get(catId) || [];
  if (directAchIds.length > 0) {
    if (subs.length > 0) {
      lines.push('### Direct Achievements');
    }
    lines.push(`*${directAchIds.length} achievements*`, '');
    const shown = directAchIds.slice(0, 50);
    for (const achId of shown) {
      const ach = achievements.get(achId);
      if (ach) {
        const desc = ach.description.length > 80 ? ach.description.substring(0, 80) + '...' : ach.description;
        lines.push(`- **${ach.name}** (ID: ${achId}) — ${ach.points} pts — ${desc}`);
      }
    }
    if (directAchIds.length > 50) {
      lines.push(`*...and ${directAchIds.length - 50} more*`);
    }
  }

  if (subs.length === 0 && directAchIds.length === 0) {
    lines.push('No achievements found in this category.');
  }

  return lines.join('\n');
}

// ============ PUBLIC API: AC MITIGATION ============

export async function getACMitigation(className: string, level?: number): Promise<string> {
  await loadACMitigation();
  if (!acMitigation || acMitigation.length === 0) return 'AC mitigation data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  let entries = acMitigation.filter(e => e.classId === classId);
  if (level !== undefined) {
    entries = entries.filter(e => e.level === level);
  }

  if (entries.length === 0) {
    return `No AC mitigation data found for ${CLASS_IDS[classId]}${level ? ` level ${level}` : ''}.`;
  }

  const lines = [
    `## AC Mitigation: ${CLASS_IDS[classId]}${level ? ` (Level ${level})` : ''}`,
    '',
    'AC Soft Cap is where AC returns diminish. Above the cap, additional AC is multiplied by the soft cap multiplier.',
    '',
    '| Level | AC Soft Cap | Soft Cap Multiplier |',
    '|-------|-------------|---------------------|',
  ];

  const displayEntries = level ? entries : entries.filter((_, i) => i % 10 === 0 || i === entries.length - 1);
  for (const e of displayEntries.sort((a, b) => a.level - b.level)) {
    lines.push(`| ${e.level} | ${e.acCap} | ${(e.softCapMultiplier * 100).toFixed(0)}% |`);
  }

  if (!level) {
    lines.push('', `*Showing every 10th level. Total entries: ${entries.length}*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL STACKING ============

export async function getSpellStackingInfo(spellId: string): Promise<string> {
  await loadSpellStacking();
  await loadSpells();
  if (!spellStacking) return 'Spell stacking data not available.';

  const id = parseInt(spellId);
  const entries = spellStacking.get(id);
  const spell = spells?.get(id);

  if (!entries || entries.length === 0) {
    return `No stacking data found for spell ID ${spellId}${spell ? ` (${spell.name})` : ''}.`;
  }

  const lines = [
    `## Spell Stacking: ${spell?.name || `Spell ${spellId}`}`,
    '',
  ];

  for (const entry of entries) {
    // Find other spells in the same stacking group
    const groupMembers: string[] = [];
    if (spellStacking && spells) {
      for (const [sid, sEntries] of spellStacking) {
        for (const se of sEntries) {
          if (se.stackingGroup === entry.stackingGroup && sid !== id) {
            const memberSpell = spells.get(sid);
            if (memberSpell) {
              groupMembers.push(`${memberSpell.name} (Rank ${se.rank})`);
            }
          }
        }
      }
    }

    const groupName = spellGroupNames?.get(entry.stackingGroup);
    const groupTitle = groupName
      ? `${groupName} (Group ${entry.stackingGroup})`
      : `Stacking Group ${entry.stackingGroup}`;
    lines.push(`### ${groupTitle}`);
    lines.push(`- **Rank:** ${entry.rank}`);
    lines.push(`- **Type:** ${entry.stackingType}`);

    if (groupMembers.length > 0) {
      lines.push(`- **Other spells in group:** ${groupMembers.slice(0, 10).join(', ')}${groupMembers.length > 10 ? ` ... and ${groupMembers.length - 10} more` : ''}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELLS BY CLASS ============

export async function searchSpellStackingGroups(query: string): Promise<string> {
  await loadSpellStacking();
  await loadSpells();
  if (!spellStacking || !spellGroupNames || spellGroupNames.size === 0) return 'Spell stacking data not available.';

  const normalized = query.toLowerCase();
  const matchingGroups: { groupId: number; name: string; spells: { id: number; name: string; rank: number }[] }[] = [];

  // Find matching group names
  for (const [groupId, groupName] of spellGroupNames) {
    if (groupName.toLowerCase().includes(normalized)) {
      // Find all spells in this group
      const groupSpells: { id: number; name: string; rank: number }[] = [];
      if (spellStacking && spells) {
        for (const [spellId, entries] of spellStacking) {
          for (const entry of entries) {
            if (entry.stackingGroup === groupId) {
              const spell = spells.get(spellId);
              if (spell) {
                groupSpells.push({ id: spellId, name: spell.name, rank: entry.rank });
              }
            }
          }
        }
      }
      groupSpells.sort((a, b) => a.rank - b.rank || a.name.localeCompare(b.name));
      matchingGroups.push({ groupId, name: groupName, spells: groupSpells });
    }
  }

  if (matchingGroups.length === 0) {
    return `No spell stacking groups match "${query}". Use list_spell_categories for spell category names.`;
  }

  matchingGroups.sort((a, b) => a.name.localeCompare(b.name));

  const lines = [`## Spell Stacking Groups matching "${query}"`, '', `*${matchingGroups.length} group${matchingGroups.length !== 1 ? 's' : ''} found*`, ''];

  for (const group of matchingGroups.slice(0, 10)) {
    lines.push(`### ${group.name} (Group ${group.groupId})`);
    lines.push(`*${group.spells.length} spells in group*`);
    for (const s of group.spells.slice(0, 20)) {
      lines.push(`- ${s.name} (ID: ${s.id}, Rank: ${s.rank})`);
    }
    if (group.spells.length > 20) {
      lines.push(`*... and ${group.spells.length - 20} more spells*`);
    }
    lines.push('');
  }

  if (matchingGroups.length > 10) {
    lines.push(`*... and ${matchingGroups.length - 10} more groups*`);
  }

  return lines.join('\n');
}

export async function getSpellsByClass(className: string, level?: number, category?: string, resistType?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions(); // For category data
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  // Resolve resist type filter
  let resistTypeId: number | undefined;
  if (resistType) {
    const lowerResist = resistType.toLowerCase();
    for (const [id, name] of Object.entries(RESIST_TYPES)) {
      if (name.toLowerCase() === lowerResist || name.toLowerCase().startsWith(lowerResist)) {
        resistTypeId = parseInt(id);
        break;
      }
    }
    if (resistTypeId === undefined) {
      const validResists = Object.values(RESIST_TYPES).filter(r => r !== 'Unresistable').join(', ');
      return `Unknown resist type: "${resistType}". Valid types: ${validResists}`;
    }
  }

  const classIndex = classId - 1; // 0-based index into class level fields
  const matchingSpells: { id: number; name: string; level: number; category?: string }[] = [];

  // Normalize category filter
  const lowerCategory = category?.toLowerCase();

  for (const [id, spell] of spells) {
    const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
    if (isNaN(classLevel) || classLevel === 255 || classLevel <= 0) continue;

    if (level !== undefined && classLevel !== level) continue;

    // Resist type filter
    if (resistTypeId !== undefined) {
      const spellResist = parseInt(spell.fields[SF.RESIST_TYPE]);
      if (spellResist !== resistTypeId) continue;
    }

    // Category filter
    let spellCat: string | undefined;
    let spellSubCat: string | undefined;
    if (spellCategories) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      const subCatId = parseInt(spell.fields[SF.SUBCATEGORY]);
      if (!isNaN(catId) && catId > 0) spellCat = spellCategories.get(catId);
      if (!isNaN(subCatId) && subCatId > 0 && subCatId !== catId) spellSubCat = spellCategories.get(subCatId);
    }

    if (lowerCategory) {
      const catMatch = spellCat?.toLowerCase().includes(lowerCategory) || spellSubCat?.toLowerCase().includes(lowerCategory);
      if (!catMatch) continue;
    }

    matchingSpells.push({ id, name: spell.name, level: classLevel, category: spellCat });
  }

  matchingSpells.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  const resistLabel = resistType ? ` - ${RESIST_TYPES[resistTypeId!] || resistType}` : '';
  if (matchingSpells.length === 0) {
    return `No spells found for ${CLASS_IDS[classId]}${level ? ` at level ${level}` : ''}${category ? ` in category "${category}"` : ''}${resistLabel}.`;
  }

  const catLabel = category ? ` - ${category}` : '';
  const lines = [
    `## ${CLASS_IDS[classId]} Spells${level ? ` (Level ${level})` : ''}${catLabel}${resistLabel}`,
    `*${matchingSpells.length} spells found*`,
    '',
  ];

  if (level) {
    // Show all spells at that level
    for (const s of matchingSpells) {
      const catSuffix = s.category && !category ? ` [${s.category}]` : '';
      lines.push(`- **${s.name}** (ID: ${s.id})${catSuffix}`);
    }
  } else {
    // Group by level
    let currentLevel = -1;
    let count = 0;
    for (const s of matchingSpells) {
      if (count >= 200) {
        lines.push(`\n*... and ${matchingSpells.length - count} more spells*`);
        break;
      }
      if (s.level !== currentLevel) {
        currentLevel = s.level;
        lines.push(`\n### Level ${currentLevel}`);
      }
      const catSuffix = s.category && !category ? ` [${s.category}]` : '';
      lines.push(`- ${s.name} (ID: ${s.id})${catSuffix}`);
      count++;
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELLS BY EFFECT ============

export async function searchSpellsByEffect(effectName: string, className?: string, maxResults: number = 50): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions(); // For category matching
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Find matching SPA codes
  const lowerEffect = effectName.toLowerCase();
  const matchingSPAs: number[] = [];
  for (const [spa, name] of Object.entries(SPA_NAMES)) {
    if (name.toLowerCase().includes(lowerEffect)) {
      matchingSPAs.push(parseInt(spa));
    }
  }

  // Also check spell categories as fallback/supplement
  const matchingCategoryIds: number[] = [];
  if (spellCategories) {
    for (const [catId, catName] of spellCategories) {
      if (catName.toLowerCase().includes(lowerEffect)) {
        matchingCategoryIds.push(catId);
      }
    }
  }

  if (matchingSPAs.length === 0 && matchingCategoryIds.length === 0) {
    const commonEffects = ['HP', 'Haste', 'Stun', 'Charm', 'Fear', 'Mesmerize', 'Root', 'Snare',
      'Slow', 'Levitate', 'Invisibility', 'Gate', 'Resurrection', 'Heal', 'Damage Shield',
      'Fire Resist', 'Cold Resist', 'Poison Resist', 'Disease Resist', 'Magic Resist',
      'Melee Haste', 'Spell Crit', 'Melee Crit', 'Regen', 'Mana Regen'];
    return `No spell effects or categories match "${effectName}".\n\nCommon effect names: ${commonEffects.join(', ')}`;
  }

  const spaSet = new Set(matchingSPAs);
  const catIdSet = new Set(matchingCategoryIds);

  // Optional class filter
  let classId: number | undefined;
  let classIndex: number | undefined;
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (classId) classIndex = classId - 1;
  }

  const results: { id: number; name: string; level?: number; effectDesc: string }[] = [];

  for (const [id, spell] of spells) {
    // Class filter
    if (classIndex !== undefined) {
      const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
      if (isNaN(classLevel) || classLevel === 255 || classLevel <= 0) continue;
    }

    // Check effects by SPA code - scan backward to find the effect data field
    let matched = false;
    let effectDesc = '';

    if (spaSet.size > 0) {
      let effectField = '';
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i].includes('|')) {
          effectField = spell.fields[i];
          break;
        }
      }
      if (effectField) {
        const slots = effectField.split('$');
        for (const slot of slots) {
          const parts = slot.split('|');
          if (parts.length < 3) continue;
          const spa = parseInt(parts[1]);
          if (spaSet.has(spa)) {
            matched = true;
            const spaName = SPA_NAMES[spa] || `SPA ${spa}`;
            const base1 = parseInt(parts[2]);
            effectDesc = `${spaName}${!isNaN(base1) && base1 !== 0 ? ` ${base1 > 0 ? '+' : ''}${base1}` : ''}`;
            break;
          }
        }
      }
    }

    // Also check spell category/subcategory as fallback
    if (!matched && catIdSet.size > 0) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      const subCatId = parseInt(spell.fields[SF.SUBCATEGORY]);
      if (catIdSet.has(catId) || catIdSet.has(subCatId)) {
        matched = true;
        const catName = spellCategories?.get(catId) || '';
        const subCatName = spellCategories?.get(subCatId) || '';
        effectDesc = subCatName && subCatName !== catName ? `${catName} > ${subCatName}` : catName;
      }
    }

    if (!matched) continue;

    let level: number | undefined;
    if (classIndex !== undefined) {
      level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
    }

    results.push({ id, name: spell.name, level, effectDesc });
    if (results.length >= maxResults) break;
  }

  if (results.length === 0) {
    const spaNames = matchingSPAs.map(s => SPA_NAMES[s]).join(', ');
    const catNames = matchingCategoryIds.map(id => spellCategories?.get(id) || `${id}`).join(', ');
    const matchInfo = [spaNames, catNames].filter(Boolean).join('; categories: ');
    return `No spells found with "${effectName}" (matched: ${matchInfo})${className ? ` for class ${className}` : ''}.`;
  }

  const spaNames = matchingSPAs.map(s => SPA_NAMES[s]);
  const catNames = matchingCategoryIds.map(id => spellCategories?.get(id) || '').filter(Boolean);
  // Deduplicate names across SPA and categories
  const allNames = [...new Set([...spaNames, ...catNames])];
  const label = allNames.join(', ');
  const classLabel = classId ? ` for ${CLASS_IDS[classId]}` : '';
  const lines = [
    `## Spells with ${label}${classLabel}`,
    `*${results.length}${results.length >= maxResults ? '+' : ''} spells found*`,
    '',
  ];

  if (classIndex !== undefined) {
    results.sort((a, b) => (a.level || 0) - (b.level || 0));
    for (const r of results) {
      lines.push(`- **${r.name}** (Lv${r.level}, ID: ${r.id}) — ${r.effectDesc}`);
    }
  } else {
    for (const r of results) {
      lines.push(`- **${r.name}** (ID: ${r.id}) — ${r.effectDesc}`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: FACTIONS ============

export async function searchFactions(query: string): Promise<SearchResult[]> {
  await loadFactions();
  if (!factions || factions.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, faction] of factions) {
    if (results.length >= 25) break;
    if (faction.name.toLowerCase().includes(normalized) ||
        (faction.category && faction.category.toLowerCase().includes(normalized))) {
      const catInfo = faction.category ? ` [${faction.category}]` : '';
      results.push({
        name: faction.name,
        type: 'unknown' as const,
        id: id.toString(),
        url: `local://faction/${id}`,
        source: 'Local Game Data',
        description: `Range: ${faction.minValue} to ${faction.maxValue}${catInfo}${faction.startingValues ? `, ${faction.startingValues.length} race/class modifiers` : ''}`,
      });
    }
  }

  // Sort: exact > starts-with > contains
  const lower = normalized.toLowerCase();
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aScore = aName === lower ? 3 : aName.startsWith(lower) ? 2 : 1;
    const bScore = bName === lower ? 3 : bName.startsWith(lower) ? 2 : 1;
    return bScore - aScore;
  });

  return results;
}

export async function getFaction(id: string): Promise<string> {
  await loadFactions();
  if (!factions) return 'Faction data not available.';

  const factionId = parseInt(id);
  const faction = factions.get(factionId);
  if (!faction) return `Faction with ID ${id} not found.`;

  const lines = [
    `## ${faction.name}`,
    '',
    `**Faction ID:** ${faction.id}`,
    `**Value Range:** ${faction.minValue} to ${faction.maxValue}`,
  ];

  if (faction.category) {
    lines.push(`**Expansion:** ${faction.category}`);
  }

  lines.push(
    '',
    '### Faction Standing Thresholds',
    '| Standing | Min Value |',
    '|----------|-----------|',
    '| Ally | 1100+ |',
    '| Warmly | 750 to 1099 |',
    '| Kindly | 500 to 749 |',
    '| Amiable | 100 to 499 |',
    '| Indifferent | 0 to 99 |',
    '| Apprehensive | -100 to -1 |',
    '| Dubious | -500 to -101 |',
    '| Threatening | -750 to -501 |',
    '| Scowling | Below -750 |',
  );

  // Show starting faction values by race/class
  if (faction.startingValues && faction.startingValues.length > 0) {
    const raceEntries = faction.startingValues.filter(sv =>
      factionModifierNames?.get(sv.modifierId)?.startsWith('Race:') ||
      PLAYABLE_RACE_MODIFIER_IDS.has(sv.modifierId)
    );
    const classEntries = faction.startingValues.filter(sv =>
      sv.modifierId >= 1 && sv.modifierId <= 16 &&
      !factionModifierNames?.get(sv.modifierId)?.startsWith('Race:')
    );

    if (raceEntries.length > 0) {
      lines.push('', '### Starting Faction by Race');

      // Sort by value (most friendly first)
      const sorted = [...raceEntries].sort((a, b) => b.value - a.value);
      for (const sv of sorted) {
        const name = factionModifierNames?.get(sv.modifierId) || `Modifier ${sv.modifierId}`;
        const raceName = name.replace(/^Race:\s*/, '');
        const standing = sv.value >= 1100 ? 'Ally' :
          sv.value >= 750 ? 'Warmly' :
          sv.value >= 500 ? 'Kindly' :
          sv.value >= 100 ? 'Amiable' :
          sv.value >= 0 ? 'Indifferent' :
          sv.value >= -100 ? 'Apprehensive' :
          sv.value >= -500 ? 'Dubious' :
          sv.value >= -750 ? 'Threatening' : 'Scowling';
        lines.push(`- **${raceName}:** ${sv.value} (${standing})`);
      }
    }

    if (classEntries.length > 0) {
      lines.push('', '### Starting Faction by Class');
      const sorted = [...classEntries].sort((a, b) => b.value - a.value);
      for (const sv of sorted) {
        const name = factionModifierNames?.get(sv.modifierId) || `Class ${sv.modifierId}`;
        const standing = sv.value >= 1100 ? 'Ally' :
          sv.value >= 750 ? 'Warmly' :
          sv.value >= 500 ? 'Kindly' :
          sv.value >= 100 ? 'Amiable' :
          sv.value >= 0 ? 'Indifferent' :
          sv.value >= -100 ? 'Apprehensive' :
          sv.value >= -500 ? 'Dubious' :
          sv.value >= -750 ? 'Threatening' : 'Scowling';
        lines.push(`- **${name}:** ${sv.value} (${standing})`);
      }
    }

    // Deity adjustments
    const deityEntries = faction.startingValues.filter(sv => DEITY_MODIFIER_IDS.has(sv.modifierId));
    if (deityEntries.length > 0) {
      lines.push('', '### Starting Faction by Deity');
      const sorted = [...deityEntries].sort((a, b) => b.value - a.value);
      for (const sv of sorted) {
        const name = factionModifierNames?.get(sv.modifierId) || `Deity ${sv.modifierId}`;
        const standing = sv.value >= 1100 ? 'Ally' :
          sv.value >= 750 ? 'Warmly' :
          sv.value >= 500 ? 'Kindly' :
          sv.value >= 100 ? 'Amiable' :
          sv.value >= 0 ? 'Indifferent' :
          sv.value >= -100 ? 'Apprehensive' :
          sv.value >= -500 ? 'Dubious' :
          sv.value >= -750 ? 'Threatening' : 'Scowling';
        lines.push(`- **${name}:** ${sv.value} (${standing})`);
      }
    }
  }

  return lines.join('\n');
}

export async function getFactionsByRace(raceName: string): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const modId = RACE_TO_FACTION_MODIFIER[raceName.toLowerCase()];
  if (!modId) {
    return `Unknown race: "${raceName}". Valid races: ${Object.keys(RACE_IDS).map(id => RACE_IDS[parseInt(id)]).join(', ')}`;
  }

  // Find the display name
  const displayRace = factionModifierNames?.get(modId)?.replace(/^Race:\s*/, '') || raceName;

  // Collect all factions with starting values for this race
  const factionStandings: { id: number; name: string; value: number; standing: string; category?: string }[] = [];

  for (const [id, faction] of factions) {
    if (!faction.startingValues) continue;
    for (const sv of faction.startingValues) {
      if (sv.modifierId === modId) {
        const standing = sv.value >= 1100 ? 'Ally' :
          sv.value >= 750 ? 'Warmly' :
          sv.value >= 500 ? 'Kindly' :
          sv.value >= 100 ? 'Amiable' :
          sv.value >= 0 ? 'Indifferent' :
          sv.value >= -100 ? 'Apprehensive' :
          sv.value >= -500 ? 'Dubious' :
          sv.value >= -750 ? 'Threatening' : 'Scowling';
        factionStandings.push({ id, name: faction.name, value: sv.value, standing, category: faction.category });
        break;
      }
    }
  }

  if (factionStandings.length === 0) {
    return `No faction starting values found for ${displayRace}.`;
  }

  // Sort: most hostile first (lowest value)
  factionStandings.sort((a, b) => a.value - b.value);

  const hostile = factionStandings.filter(f => f.value < 0);
  const friendly = factionStandings.filter(f => f.value >= 0);

  const lines = [
    `## Faction Standings for ${displayRace}`,
    `*${factionStandings.length} factions with starting values*`,
    '',
  ];

  if (hostile.length > 0) {
    lines.push(`### Hostile Factions (${hostile.length})`);
    for (const f of hostile) {
      const cat = f.category ? ` [${f.category}]` : '';
      lines.push(`- **${f.name}** (ID: ${f.id}) — ${f.value} (${f.standing})${cat}`);
    }
    lines.push('');
  }

  if (friendly.length > 0) {
    lines.push(`### Friendly Factions (${friendly.length})`);
    // Sort friendly highest first
    friendly.sort((a, b) => b.value - a.value);
    for (const f of friendly) {
      const cat = f.category ? ` [${f.category}]` : '';
      lines.push(`- **${f.name}** (ID: ${f.id}) — ${f.value} (${f.standing})${cat}`);
    }
  }

  return lines.join('\n');
}

export async function getFactionsByDeity(deityName: string): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const modId = DEITY_TO_FACTION_MODIFIER[deityName.toLowerCase()];
  if (!modId) {
    const deities = [...new Set(Object.values(DEITY_TO_FACTION_MODIFIER))];
    const deityNames = Object.entries(DEITY_TO_FACTION_MODIFIER)
      .filter(([, v]) => deities.includes(v))
      .map(([k]) => k)
      .filter(k => k.length > 4) // skip short aliases
      .sort();
    return `Unknown deity: "${deityName}". Valid deities: ${deityNames.join(', ')}`;
  }

  const displayDeity = factionModifierNames?.get(modId) || deityName;

  const factionStandings: { id: number; name: string; value: number; standing: string; category?: string }[] = [];

  for (const [id, faction] of factions) {
    if (!faction.startingValues) continue;
    for (const sv of faction.startingValues) {
      if (sv.modifierId === modId) {
        const standing = sv.value >= 1100 ? 'Ally' :
          sv.value >= 750 ? 'Warmly' :
          sv.value >= 500 ? 'Kindly' :
          sv.value >= 100 ? 'Amiable' :
          sv.value >= 0 ? 'Indifferent' :
          sv.value >= -100 ? 'Apprehensive' :
          sv.value >= -500 ? 'Dubious' :
          sv.value >= -750 ? 'Threatening' : 'Scowling';
        factionStandings.push({ id, name: faction.name, value: sv.value, standing, category: faction.category });
        break;
      }
    }
  }

  if (factionStandings.length === 0) {
    return `No faction starting values found for followers of ${displayDeity}.`;
  }

  factionStandings.sort((a, b) => a.value - b.value);

  const hostile = factionStandings.filter(f => f.value < 0);
  const friendly = factionStandings.filter(f => f.value >= 0);

  const lines = [
    `## Faction Standings for followers of ${displayDeity}`,
    `*${factionStandings.length} factions affected by deity choice*`,
    '',
  ];

  if (hostile.length > 0) {
    lines.push(`### Hostile Factions (${hostile.length})`);
    for (const f of hostile) {
      const cat = f.category ? ` [${f.category}]` : '';
      lines.push(`- **${f.name}** (ID: ${f.id}) — ${f.value} (${f.standing})${cat}`);
    }
    lines.push('');
  }

  if (friendly.length > 0) {
    lines.push(`### Friendly Factions (${friendly.length})`);
    friendly.sort((a, b) => b.value - a.value);
    for (const f of friendly) {
      const cat = f.category ? ` [${f.category}]` : '';
      lines.push(`- **${f.name}** (ID: ${f.id}) — ${f.value} (${f.standing})${cat}`);
    }
  }

  return lines.join('\n');
}

export async function getFactionsByClass(className: string): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId || classId < 1 || classId > 16) {
    const validClasses = Object.values(CLASS_IDS).sort();
    return `Unknown class: "${className}". Valid classes: ${validClasses.join(', ')}`;
  }

  const displayClass = CLASS_IDS[classId];
  const modId = classId; // Class modifier IDs are same as class IDs (1-16)

  const factionStandings: { id: number; name: string; value: number; standing: string; category?: string }[] = [];

  for (const [id, faction] of factions) {
    if (!faction.startingValues) continue;
    for (const sv of faction.startingValues) {
      if (sv.modifierId === modId) {
        const standing = sv.value >= 1100 ? 'Ally' :
          sv.value >= 750 ? 'Warmly' :
          sv.value >= 500 ? 'Kindly' :
          sv.value >= 100 ? 'Amiable' :
          sv.value >= 0 ? 'Indifferent' :
          sv.value >= -100 ? 'Apprehensive' :
          sv.value >= -500 ? 'Dubious' :
          sv.value >= -750 ? 'Threatening' : 'Scowling';
        factionStandings.push({ id, name: faction.name, value: sv.value, standing, category: faction.category });
        break;
      }
    }
  }

  if (factionStandings.length === 0) {
    return `No faction starting values found for ${displayClass} class.`;
  }

  factionStandings.sort((a, b) => a.value - b.value);

  const hostile = factionStandings.filter(f => f.value < 0);
  const friendly = factionStandings.filter(f => f.value >= 0);

  const lines = [
    `## Faction Standings for ${displayClass} class`,
    `*${factionStandings.length} factions affected by class choice*`,
    '',
  ];

  if (hostile.length > 0) {
    lines.push(`### Hostile Factions (${hostile.length})`);
    for (const f of hostile) {
      const cat = f.category ? ` [${f.category}]` : '';
      lines.push(`- **${f.name}** (ID: ${f.id}) — ${f.value} (${f.standing})${cat}`);
    }
    lines.push('');
  }

  if (friendly.length > 0) {
    lines.push(`### Friendly Factions (${friendly.length})`);
    friendly.sort((a, b) => b.value - a.value);
    for (const f of friendly) {
      const cat = f.category ? ` [${f.category}]` : '';
      lines.push(`- **${f.name}** (ID: ${f.id}) — ${f.value} (${f.standing})${cat}`);
    }
  }

  return lines.join('\n');
}

export async function getCharacterFactions(race: string, deity?: string, className?: string): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  // Resolve race
  const raceModId = RACE_TO_FACTION_MODIFIER[race.toLowerCase()];
  if (!raceModId) {
    const raceNames = Object.keys(RACE_TO_FACTION_MODIFIER)
      .filter(k => k.length > 3)
      .sort();
    return `Unknown race: "${race}". Valid races: ${raceNames.join(', ')}`;
  }
  const displayRace = factionModifierNames?.get(raceModId) || race;

  // Resolve deity (optional)
  let deityModId: number | undefined;
  let displayDeity: string | undefined;
  if (deity) {
    deityModId = DEITY_TO_FACTION_MODIFIER[deity.toLowerCase()];
    if (!deityModId) {
      const deityNames = Object.entries(DEITY_TO_FACTION_MODIFIER)
        .map(([k]) => k)
        .filter(k => k.length > 4)
        .sort();
      return `Unknown deity: "${deity}". Valid deities: ${deityNames.join(', ')}`;
    }
    displayDeity = factionModifierNames?.get(deityModId) || deity;
  }

  // Resolve class (optional)
  let classModId: number | undefined;
  let displayClass: string | undefined;
  if (className) {
    const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId || classId < 1 || classId > 16) {
      return `Unknown class: "${className}". Valid: ${Object.values(CLASS_IDS).sort().join(', ')}`;
    }
    classModId = classId;
    displayClass = CLASS_IDS[classId];
  }

  // Collect modifier IDs to sum
  const modIds = [raceModId];
  if (deityModId) modIds.push(deityModId);
  if (classModId) modIds.push(classModId);

  // Aggregate faction values across all modifiers
  const factionTotals = new Map<number, { name: string; total: number; breakdown: { source: string; value: number }[]; category?: string }>();

  for (const [id, faction] of factions) {
    if (!faction.startingValues) continue;
    for (const sv of faction.startingValues) {
      if (modIds.includes(sv.modifierId)) {
        let entry = factionTotals.get(id);
        if (!entry) {
          entry = { name: faction.name, total: 0, breakdown: [], category: faction.category };
          factionTotals.set(id, entry);
        }
        entry.total += sv.value;
        const source = sv.modifierId === raceModId ? displayRace :
          sv.modifierId === deityModId ? (displayDeity || '') :
          sv.modifierId === classModId ? (displayClass || '') : `Mod ${sv.modifierId}`;
        entry.breakdown.push({ source, value: sv.value });
      }
    }
  }

  if (factionTotals.size === 0) {
    return 'No faction starting values found for this combination.';
  }

  // Build title
  const titleParts = [displayRace];
  if (displayClass) titleParts.push(displayClass);
  if (displayDeity) titleParts.push(`follower of ${displayDeity}`);
  const title = titleParts.join(' ');

  const entries = [...factionTotals.entries()].map(([id, e]) => {
    const standing = e.total >= 1100 ? 'Ally' :
      e.total >= 750 ? 'Warmly' :
      e.total >= 500 ? 'Kindly' :
      e.total >= 100 ? 'Amiable' :
      e.total >= 0 ? 'Indifferent' :
      e.total >= -100 ? 'Apprehensive' :
      e.total >= -500 ? 'Dubious' :
      e.total >= -750 ? 'Threatening' : 'Scowling';
    return { id, ...e, standing };
  });

  entries.sort((a, b) => a.total - b.total);

  const hostile = entries.filter(f => f.total < 0);
  const friendly = entries.filter(f => f.total >= 0);

  const lines = [
    `## Combined Faction Standings: ${title}`,
    `*${entries.length} factions affected*`,
    '',
  ];

  const showBreakdown = modIds.length > 1;

  if (hostile.length > 0) {
    lines.push(`### Hostile Factions (${hostile.length})`);
    for (const f of hostile) {
      const cat = f.category ? ` [${f.category}]` : '';
      let line = `- **${f.name}** (ID: ${f.id}) — ${f.total} (${f.standing})${cat}`;
      if (showBreakdown && f.breakdown.length > 1) {
        line += ` [${f.breakdown.map(b => `${b.source}: ${b.value >= 0 ? '+' : ''}${b.value}`).join(', ')}]`;
      }
      lines.push(line);
    }
    lines.push('');
  }

  if (friendly.length > 0) {
    lines.push(`### Friendly Factions (${friendly.length})`);
    friendly.sort((a, b) => b.total - a.total);
    for (const f of friendly) {
      const cat = f.category ? ` [${f.category}]` : '';
      let line = `- **${f.name}** (ID: ${f.id}) — ${f.total} (${f.standing})${cat}`;
      if (showBreakdown && f.breakdown.length > 1) {
        line += ` [${f.breakdown.map(b => `${b.source}: ${b.value >= 0 ? '+' : ''}${b.value}`).join(', ')}]`;
      }
      lines.push(line);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: AA ABILITIES ============

export async function searchAAAbilities(query: string): Promise<SearchResult[]> {
  await loadAAAbilities();
  if (!aaAbilities || aaAbilities.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  // First pass: exact name match
  for (const [id, aa] of aaAbilities) {
    if (aa.name.toLowerCase() === normalized) {
      results.push({
        name: aa.name,
        type: 'spell' as const,
        id: id.toString(),
        url: `local://aa/${id}`,
        source: 'Local Game Data',
        description: aa.description.substring(0, 100) + (aa.description.length > 100 ? '...' : ''),
      });
    }
  }

  // Second pass: starts-with and contains
  if (results.length < 25) {
    for (const [id, aa] of aaAbilities) {
      if (results.length >= 25) break;
      if (results.some(r => r.id === id.toString())) continue;
      if (aa.name.toLowerCase().startsWith(normalized) ||
          aa.name.toLowerCase().includes(normalized) ||
          aa.description.toLowerCase().includes(normalized)) {
        results.push({
          name: aa.name,
          type: 'spell' as const,
          id: id.toString(),
          url: `local://aa/${id}`,
          source: 'Local Game Data',
          description: aa.description.substring(0, 100) + (aa.description.length > 100 ? '...' : ''),
        });
      }
    }
  }

  return results;
}

export async function getAAAbility(id: string): Promise<string> {
  await loadAAAbilities();
  if (!aaAbilities) return 'AA ability data not available.';

  const aaId = parseInt(id);
  const aa = aaAbilities.get(aaId);
  if (!aa) return `AA ability with ID ${id} not found.`;

  const lines = [
    `## ${aa.name}`,
    '',
    aa.description,
  ];

  return lines.join('\n');
}

// ============ PUBLIC API: LORE/STORYLINE ============

export async function searchLore(query: string): Promise<SearchResult[]> {
  await loadLore();
  if (!loreEntries || loreEntries.length === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (let i = 0; i < loreEntries.length; i++) {
    if (results.length >= 20) break;
    const entry = loreEntries[i];
    if (entry.title.toLowerCase().includes(normalized) ||
        entry.content.toLowerCase().includes(normalized)) {
      results.push({
        name: entry.title,
        type: 'guide' as const,
        id: entry.filename,
        url: `local://lore/${entry.filename}`,
        source: 'Local Game Data',
        description: entry.content.substring(0, 120).replace(/\n/g, ' ') + '...',
      });
    }
  }

  // Sort: title matches first
  results.sort((a, b) => {
    const aTitle = a.name.toLowerCase().includes(normalized) ? 1 : 0;
    const bTitle = b.name.toLowerCase().includes(normalized) ? 1 : 0;
    return bTitle - aTitle;
  });

  return results;
}

export async function getLore(filenameOrTitle: string): Promise<string> {
  await loadLore();
  if (!loreEntries || loreEntries.length === 0) return 'Lore data not available.';

  // Try exact filename match
  let entry = loreEntries.find(e => e.filename === filenameOrTitle);

  // Try title match
  if (!entry) {
    const lower = filenameOrTitle.toLowerCase();
    entry = loreEntries.find(e => e.title.toLowerCase() === lower);
  }

  // Try partial title match
  if (!entry) {
    const lower = filenameOrTitle.toLowerCase();
    entry = loreEntries.find(e => e.title.toLowerCase().includes(lower));
  }

  if (!entry) return `Lore entry "${filenameOrTitle}" not found.`;

  return `## ${entry.title}\n\n${entry.content}`;
}

// ============ PUBLIC API: GAME STRINGS ============

export async function searchGameStrings(query: string): Promise<SearchResult[]> {
  await loadGameStrings();
  if (!gameStrings || gameStrings.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, text] of gameStrings) {
    if (results.length >= 25) break;
    if (text.toLowerCase().includes(normalized)) {
      results.push({
        name: `String ${id}`,
        type: 'unknown' as const,
        id: id.toString(),
        url: `local://gamestring/${id}`,
        source: 'Local Game Data',
        description: text.substring(0, 120) + (text.length > 120 ? '...' : ''),
      });
    }
  }

  return results;
}

export async function getGameString(id: string): Promise<string> {
  await loadGameStrings();
  if (!gameStrings) return 'Game string data not available.';

  const stringId = parseInt(id);
  const text = gameStrings.get(stringId);
  if (!text) return `Game string with ID ${id} not found.`;

  return `## Game String #${id}\n\n${text}`;
}

// ============ PUBLIC API: OVERSEER SYSTEM ============

export async function searchOverseerMinions(query: string): Promise<SearchResult[]> {
  await loadOverseerMinions();
  if (!overseerMinions || overseerMinions.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, minion] of overseerMinions) {
    if (results.length >= 25) break;
    if (minion.fullName.toLowerCase().includes(normalized) ||
        minion.shortName.toLowerCase().includes(normalized)) {
      results.push({
        name: minion.fullName,
        type: 'npc' as const,
        id: id.toString(),
        url: `local://overseer/minion/${id}`,
        source: 'Local Game Data',
        description: `${OVERSEER_RARITIES[minion.rarity] || 'Unknown'} Agent`,
      });
    }
  }

  // Sort: exact > starts-with > contains
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aScore = aName === normalized ? 3 : aName.startsWith(normalized) ? 2 : 1;
    const bScore = bName === normalized ? 3 : bName.startsWith(normalized) ? 2 : 1;
    return bScore - aScore;
  });

  return results;
}

export async function getOverseerMinion(id: string): Promise<string> {
  await loadOverseerMinions();
  await loadOverseerEnhancements();
  if (!overseerMinions) return 'Overseer minion data not available.';

  const minionId = parseInt(id);
  const minion = overseerMinions.get(minionId);
  if (!minion) return `Overseer minion with ID ${id} not found.`;

  const lines = [
    `## ${minion.fullName}`,
    '',
    `**Rarity:** ${OVERSEER_RARITIES[minion.rarity] || 'Unknown'}`,
  ];

  // Determine archetype from first job (jobs 1-3=Fighter, 4-6=Worker, 7-9=Traveler)
  if (minion.jobs.length > 0) {
    const firstJobId = minion.jobs[0].jobTypeId;
    if (firstJobId >= 1 && firstJobId <= 9) {
      const archetypeId = Math.ceil(firstJobId / 3);
      const archetypeName = overseerArchetypeNames?.get(archetypeId);
      if (archetypeName) {
        lines.push(`**Archetype:** ${archetypeName}`);
        const classDesc = overseerJobClassDescs?.get(archetypeId);
        if (classDesc) lines.push(`*${classDesc}*`);
      }
    }
  }

  // Show jobs this agent can perform
  if (minion.jobs.length > 0) {
    const jobNames = minion.jobs
      .map(j => {
        const name = overseerJobNames?.get(j.jobTypeId) || `Job ${j.jobTypeId}`;
        return `${name} (Lv${j.level})`;
      })
      .join(', ');
    lines.push(`**Jobs:** ${jobNames}`);
  }

  if (minion.traits.length > 0) {
    lines.push('', '### Traits');
    for (let i = 0; i < minion.traits.length; i++) {
      const traitName = minion.traits[i];
      const traitId = minion.traitIds[i];
      const traitDesc = traitId !== undefined ? overseerTraitDescs?.get(traitId) : undefined;
      if (traitDesc) {
        lines.push(`- **${traitName}** - ${stripHtmlTags(traitDesc)}`);
      } else {
        lines.push(`- **${traitName}**`);
      }
    }
  }

  if (minion.bio) {
    lines.push('', minion.bio);
  }

  return lines.join('\n');
}

export async function searchOverseerQuests(query: string): Promise<SearchResult[]> {
  await loadOverseerQuests();
  if (!overseerQuests || overseerQuests.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, quest] of overseerQuests) {
    if (results.length >= 25) break;
    if (quest.name.toLowerCase().includes(normalized) ||
        quest.description.toLowerCase().includes(normalized)) {
      results.push({
        name: quest.name,
        type: 'quest' as const,
        id: id.toString(),
        url: `local://overseer/quest/${id}`,
        source: 'Local Game Data',
        description: quest.description.substring(0, 100) + (quest.description.length > 100 ? '...' : ''),
      });
    }
  }

  return results;
}

export async function getOverseerQuest(id: string): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerEnhancements();
  await loadOverseerMinions(); // for trait names
  if (!overseerQuests) return 'Overseer quest data not available.';

  const questId = parseInt(id);
  const quest = overseerQuests.get(questId);
  if (!quest) return `Overseer quest with ID ${id} not found.`;

  const categoryName = overseerCategories?.get(quest.categoryId) || `Category ${quest.categoryId}`;
  const difficultyName = overseerDifficulties?.get(quest.difficulty) || `${quest.difficulty}`;

  // Get trait names from dbstr
  const traitNames = dbStrings?.get(DBSTR_TYPES.OVERSEER_TRAIT) || new Map<number, string>();

  const lines = [
    `## ${quest.name}`,
    '',
    quest.description,
    '',
    `**Category:** ${categoryName}`,
    `**Difficulty:** ${difficultyName}`,
    `**Duration:** ${quest.duration}h`,
    `**Agent Slots:** ${quest.requiredSlots} required${quest.optionalSlots > 0 ? `, ${quest.optionalSlots} optional` : ''}`,
  ];

  // Show slot details with job types and bonus traits
  if (quest.slotDetails.length > 0) {
    lines.push('', '### Agent Slot Details');
    let slotNum = 1;
    for (const slot of quest.slotDetails) {
      const jobName = overseerJobNames?.get(slot.jobTypeId) || `Job ${slot.jobTypeId}`;
      const reqLabel = slot.isRequired ? 'Required' : 'Optional';
      let slotLine = `${slotNum}. **${jobName}** (${reqLabel})`;

      if (slot.bonusTraitIds.length > 0) {
        const traitNamesList = slot.bonusTraitIds
          .map(tid => traitNames.get(tid) || `Trait ${tid}`)
          .slice(0, 5);
        slotLine += ` — Bonus: ${traitNamesList.join(', ')}`;
        if (slot.bonusTraitIds.length > 5) {
          slotLine += ` +${slot.bonusTraitIds.length - 5} more`;
        }
      }

      lines.push(slotLine);
      slotNum++;
    }
  }

  // Show primary incapacitation risk based on quest category
  const categoryIncapMap: Record<string, string> = {
    'Plunder': 'Wounded', 'Stealth': 'Captured', 'Military': 'Shaken',
    'Crafting': 'Discouraged', 'Harvesting': 'Exhausted', 'Research': 'Discredited',
    'Diplomacy': 'Banished', 'Merchant': 'Blacklisted', 'Exploration': 'Missing',
  };
  const primaryIncap = categoryIncapMap[categoryName];
  if (primaryIncap && overseerIncapNames) {
    // Find the description for this incapacitation type
    for (const [incapId, incapName] of overseerIncapNames) {
      if (incapName === primaryIncap) {
        const incapDesc = overseerIncapDescs?.get(incapId) || '';
        lines.push('', `**Primary Risk:** ${primaryIncap} — ${stripHtmlTags(incapDesc)}`);
        break;
      }
    }
  }

  // Success/failure outcome messages
  const successMsgs = dbStrings?.get(DBSTR_TYPES.OVERSEER_SUCCESS);
  const failureMsgs = dbStrings?.get(DBSTR_TYPES.OVERSEER_FAILURE);
  const rawSuccess = successMsgs?.get(questId);
  const rawFailure = failureMsgs?.get(questId);
  if (rawSuccess || rawFailure) {
    lines.push('', '### Outcomes');
    if (rawSuccess) {
      const success = stripHtmlTags(rawSuccess.replace(/<c\s+"[^"]*">/gi, '').replace(/<\/c>/gi, ''));
      lines.push(`**Success:** ${success}`);
    }
    if (rawFailure) {
      const failure = stripHtmlTags(rawFailure.replace(/<c\s+"[^"]*">/gi, '').replace(/<\/c>/gi, ''));
      lines.push(`**Failure:** ${failure}`);
    }
  }

  return lines.join('\n');
}

export async function getOverseerIncapacitations(): Promise<string> {
  await loadOverseerEnhancements();
  if (!overseerIncapNames || overseerIncapNames.size === 0) return 'Overseer incapacitation data not available.';

  const JOB_TYPE_NAMES: Record<number, string> = {
    1: 'Marauder (Plunder)', 2: 'Spy (Stealth)', 3: 'Soldier (Military)',
    4: 'Artisan (Crafting)', 5: 'Harvester (Harvesting)', 6: 'Scholar (Research)',
    7: 'Diplomat (Diplomacy)', 8: 'Merchant (Merchant)', 9: 'Explorer (Exploration)',
  };

  const lines = ['## Overseer Incapacitation Types', ''];

  // Group incapacitations by job type (1-9), showing unique types with durations
  const seen = new Set<number>();
  for (let jobType = 1; jobType <= 9; jobType++) {
    if (seen.has(jobType)) continue;
    seen.add(jobType);

    // Find the first entry with this job type
    const firstId = jobType; // IDs 1-9 are the first tier
    const name = overseerIncapNames.get(firstId);
    if (!name) continue;

    const desc = overseerIncapDescs?.get(firstId) || '';
    const jobName = JOB_TYPE_NAMES[jobType] || `Job ${jobType}`;

    lines.push(`### ${name}`);
    lines.push(`**Job Type:** ${jobName}`);
    lines.push(stripHtmlTags(desc));

    // Show durations across tiers
    if (overseerIncapDurations && overseerIncapDurations.size > 0) {
      const durations: number[] = [];
      for (const [, entry] of overseerIncapDurations) {
        if (entry.jobType === jobType && entry.duration > 0) {
          durations.push(entry.duration);
        }
      }
      if (durations.length > 0) {
        const uniqueDurations = [...new Set(durations)].sort((a, b) => a - b);
        const formatted = uniqueDurations.map(d => {
          const hours = d / 3600;
          if (hours >= 24) return `${(hours / 24).toFixed(1)}d`;
          return `${hours.toFixed(1)}h`;
        });
        lines.push(`**Durations:** ${formatted.join(', ')}`);
      }
    }
    lines.push('');
  }

  // Show "Released" if it exists (job type 10)
  const releasedName = overseerIncapNames.get(10);
  if (releasedName) {
    const releasedDesc = overseerIncapDescs?.get(10) || '';
    lines.push(`### ${releasedName}`);
    lines.push(stripHtmlTags(releasedDesc));
    lines.push('**Duration:** Instant (0)');
    lines.push('');
  }

  return lines.join('\n');
}

// ============ PUBLIC API: BONUS DESCRIPTIONS & AUGMENT GROUPS ============

export async function getHotZoneBonuses(): Promise<string> {
  await loadBonusAndAugmentData();
  if (!bonusDescriptions || bonusDescriptions.size === 0) return 'Bonus description data not available.';

  const lines = ['## Hot Zone / Bonus Effects', ''];

  const bonusTypes = [
    { id: 0, label: 'General Description' },
    { id: 1, label: 'Experience Bonus' },
    { id: 2, label: 'Loot Multiplier' },
    { id: 3, label: 'Faction Bonus' },
    { id: 4, label: 'Ability Experience' },
    { id: 5, label: 'Coin Multiplier' },
    { id: 6, label: 'Increased Spawns' },
    { id: 7, label: 'Currency Multiplier' },
    { id: 8, label: 'Tribute Potency' },
    { id: 9, label: 'Rare Spawns' },
    { id: 10, label: 'Item Experience' },
    { id: 11, label: 'Proficiency Rate' },
    { id: 12, label: 'Enhanced Tribute' },
    { id: 13, label: 'Collection Multiplier' },
    { id: 14, label: 'Mercenary Experience' },
    { id: 15, label: 'Fortune Bonus' },
  ];

  for (const bt of bonusTypes) {
    const desc = bonusDescriptions.get(bt.id);
    if (desc) {
      lines.push(`### ${bt.label}`);
      lines.push(desc);
      lines.push('');
    }
  }

  return lines.join('\n');
}

export async function searchAugmentGroups(query: string): Promise<SearchResult[]> {
  await loadBonusAndAugmentData();
  if (!augmentGroups || augmentGroups.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, name] of augmentGroups) {
    if (results.length >= 25) break;
    if (name.toLowerCase().includes(normalized)) {
      results.push({
        name,
        type: 'unknown' as const,
        id: id.toString(),
        url: `local://auggroup/${id}`,
        source: 'Local Game Data',
        description: `Augmentation group ID: ${id}`,
      });
    }
  }

  return results;
}

// ============ PUBLIC API: COMBAT ABILITIES ============

export async function searchCombatAbilities(query: string): Promise<SearchResult[]> {
  await loadCombatAbilities();
  if (!combatAbilities || combatAbilities.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, name] of combatAbilities) {
    if (results.length >= 25) break;
    if (name.toLowerCase().includes(normalized)) {
      results.push({
        name,
        type: 'spell' as const,
        id: id.toString(),
        url: `local://combat_ability/${id}`,
        source: 'Local Game Data',
        description: 'Combat Ability / Discipline',
      });
    }
  }

  // Sort: exact > starts-with > contains
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aScore = aName === normalized ? 3 : aName.startsWith(normalized) ? 2 : 1;
    const bScore = bName === normalized ? 3 : bName.startsWith(normalized) ? 2 : 1;
    return bScore - aScore;
  });

  return results;
}

// ============ PUBLIC API: MERCENARIES ============

export async function searchMercenaries(query: string): Promise<SearchResult[]> {
  await loadMercenaries();
  if (!mercenaries || mercenaries.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];
  const seen = new Set<string>();

  for (const [id, merc] of mercenaries) {
    if (results.length >= 25) break;
    if (merc.race.toLowerCase().includes(normalized) ||
        merc.type.toLowerCase().includes(normalized) ||
        merc.proficiency.toLowerCase().includes(normalized) ||
        merc.description.toLowerCase().includes(normalized)) {
      // Deduplicate by race+type+proficiency+tier combo
      const key = `${merc.race}|${merc.type}|${merc.proficiency}|${merc.tier}`;
      if (seen.has(key)) continue;
      seen.add(key);

      results.push({
        name: `${merc.race} ${merc.type} (${merc.proficiency}, ${merc.tier})`,
        type: 'npc' as const,
        id: id.toString(),
        url: `local://mercenary/${id}`,
        source: 'Local Game Data',
        description: `Confidence: ${merc.confidence}`,
      });
    }
  }

  return results;
}

export async function getMercenary(id: string): Promise<string> {
  await loadMercenaries();
  await loadMercenaryStances();
  if (!mercenaries) return 'Mercenary data not available.';

  const mercId = parseInt(id);
  const merc = mercenaries.get(mercId);
  if (!merc) return `Mercenary with ID ${id} not found.`;

  const lines = [
    `## ${merc.race} ${merc.type}`,
    '',
    `**Tier:** ${merc.tier}`,
    `**Proficiency:** ${merc.proficiency}`,
    `**Confidence:** ${merc.confidence}`,
    '',
    merc.description,
  ];

  // Add available stances
  if (mercenaryStances && mercenaryStances.size > 0) {
    lines.push('', '### Available Stances');
    for (const [, stance] of mercenaryStances) {
      lines.push(`- **${stance.name}:** ${stance.shortDesc}`);
    }
  }

  return lines.join('\n');
}

export async function getMercenaryStances(): Promise<string> {
  await loadMercenaryStances();
  if (!mercenaryStances || mercenaryStances.size === 0) return 'Mercenary stance data not available.';

  const lines = ['## Mercenary Stances', ''];

  for (const [, stance] of mercenaryStances) {
    lines.push(`### ${stance.name}`);
    lines.push(stance.description);
    lines.push('');
  }

  if (mercenaryTypes && mercenaryTypes.size > 0) {
    lines.push('## Mercenary Types', '');
    for (const [, name] of mercenaryTypes) {
      lines.push(`- ${name}`);
    }
    lines.push('');
  }

  if (mercenaryAbilities && mercenaryAbilities.size > 0) {
    lines.push('## Mercenary Abilities', '');
    for (const [, ability] of mercenaryAbilities) {
      lines.push(`### ${ability.name}`);
      if (ability.description) lines.push(ability.description);
      lines.push('');
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: RACE & CLASS INFO ============

export async function getRaceInfo(raceName: string): Promise<string> {
  await loadRaceClassInfo();
  await loadStartingCityLore();
  if (!raceDescriptions) return 'Race data not available.';

  // Resolve race ID
  const raceId = RACE_NAME_TO_ID[raceName.toLowerCase()];
  if (!raceId && raceId !== 0) {
    return `Unknown race: "${raceName}". Valid races: ${Object.values(RACE_IDS).join(', ')}`;
  }

  const name = RACE_IDS[raceId];
  const desc = raceDescriptions.get(raceId);
  if (!desc) return `No data found for race: ${name}`;

  const lines = [
    `## ${name}`,
    '',
    desc.long || desc.short,
    '',
  ];

  // Available classes
  const availableClasses = RACE_CLASSES[raceId];
  if (availableClasses) {
    lines.push(`**Available Classes:** ${availableClasses.map(id => CLASS_IDS[id]).join(', ')}`);
  }

  // Starting base stats
  const stats = RACE_BASE_STATS[raceId];
  if (stats) {
    const statStr = STAT_NAMES.map((name, i) => `${name}: ${stats[i]}`).join(', ');
    lines.push(`**Base Stats:** ${statStr}`);
  }

  // Available deities
  const deities = RACE_DEITIES[raceId];
  if (deities) {
    lines.push(`**Available Deities:** ${deities.join(', ')}`);
  }

  // Starting city lore
  const cityIds = RACE_STARTING_CITY_IDS[raceId];
  if (cityIds && startingCityLore) {
    const uniqueLore = new Set<string>();
    for (const cityId of cityIds) {
      const lore = startingCityLore.get(cityId);
      if (lore) uniqueLore.add(lore);
    }
    if (uniqueLore.size > 0) {
      lines.push('', '### Starting City');
      for (const lore of uniqueLore) {
        lines.push(lore);
      }
    }
  }

  // Drakkin heritages
  if (raceId === 522) {
    await loadDrakkinHeritages();
    if (drakkinHeritages && drakkinHeritages.length > 0) {
      lines.push('', '### Dragon Heritages');
      for (const h of drakkinHeritages) {
        const classNames = h.classes.map(c => CLASS_IDS[c]).filter(Boolean).join(', ');
        lines.push(`- **${h.name}** (Heritage ${h.id}) — Classes: ${classNames}`);
      }
    }
  }

  return lines.join('\n');
}

export async function compareRaces(race1: string, race2: string): Promise<string> {
  await loadRaceClassInfo();
  if (!raceDescriptions) return 'Race data not available.';

  const raceId1 = RACE_NAME_TO_ID[race1.toLowerCase()];
  const raceId2 = RACE_NAME_TO_ID[race2.toLowerCase()];

  if (!raceId1 && raceId1 !== 0) {
    return `Unknown race: "${race1}". Valid: ${Object.values(RACE_IDS).join(', ')}`;
  }
  if (!raceId2 && raceId2 !== 0) {
    return `Unknown race: "${race2}". Valid: ${Object.values(RACE_IDS).join(', ')}`;
  }

  const name1 = RACE_IDS[raceId1];
  const name2 = RACE_IDS[raceId2];
  const stats1 = RACE_BASE_STATS[raceId1];
  const stats2 = RACE_BASE_STATS[raceId2];
  const classes1 = new Set(RACE_CLASSES[raceId1] || []);
  const classes2 = new Set(RACE_CLASSES[raceId2] || []);
  const deities1 = new Set(RACE_DEITIES[raceId1] || []);
  const deities2 = new Set(RACE_DEITIES[raceId2] || []);

  const lines = [
    `## Race Comparison: ${name1} vs ${name2}`,
    '',
  ];

  // Stats comparison
  if (stats1 && stats2) {
    lines.push('### Base Stats');
    lines.push(`| Stat | ${name1} | ${name2} | Diff |`);
    lines.push('|------|' + '-'.repeat(name1.length + 2) + '|' + '-'.repeat(name2.length + 2) + '|------|');
    let total1 = 0, total2 = 0;
    for (let i = 0; i < STAT_NAMES.length; i++) {
      const v1 = stats1[i];
      const v2 = stats2[i];
      const diff = v1 - v2;
      const diffStr = diff > 0 ? `+${diff}` : diff < 0 ? `${diff}` : '—';
      lines.push(`| **${STAT_NAMES[i]}** | ${v1} | ${v2} | ${diffStr} |`);
      total1 += v1;
      total2 += v2;
    }
    const totalDiff = total1 - total2;
    const totalDiffStr = totalDiff > 0 ? `+${totalDiff}` : totalDiff < 0 ? `${totalDiff}` : '—';
    lines.push(`| **Total** | **${total1}** | **${total2}** | **${totalDiffStr}** |`);
    lines.push('');
  }

  // Classes comparison
  const allClasses = new Set([...classes1, ...classes2]);
  const sharedClasses: string[] = [];
  const only1Classes: string[] = [];
  const only2Classes: string[] = [];

  for (const cid of [...allClasses].sort()) {
    const cname = CLASS_IDS[cid];
    if (classes1.has(cid) && classes2.has(cid)) {
      sharedClasses.push(cname);
    } else if (classes1.has(cid)) {
      only1Classes.push(cname);
    } else {
      only2Classes.push(cname);
    }
  }

  lines.push('### Available Classes');
  if (sharedClasses.length > 0) {
    lines.push(`**Both:** ${sharedClasses.join(', ')}`);
  }
  if (only1Classes.length > 0) {
    lines.push(`**${name1} only:** ${only1Classes.join(', ')}`);
  }
  if (only2Classes.length > 0) {
    lines.push(`**${name2} only:** ${only2Classes.join(', ')}`);
  }
  lines.push('');

  // Deities comparison
  const allDeities = new Set([...deities1, ...deities2]);
  const sharedDeities: string[] = [];
  const only1Deities: string[] = [];
  const only2Deities: string[] = [];

  for (const deity of [...allDeities].sort()) {
    if (deities1.has(deity) && deities2.has(deity)) {
      sharedDeities.push(deity);
    } else if (deities1.has(deity)) {
      only1Deities.push(deity);
    } else {
      only2Deities.push(deity);
    }
  }

  lines.push('### Available Deities');
  if (sharedDeities.length > 0) {
    lines.push(`**Both:** ${sharedDeities.join(', ')}`);
  }
  if (only1Deities.length > 0) {
    lines.push(`**${name1} only:** ${only1Deities.join(', ')}`);
  }
  if (only2Deities.length > 0) {
    lines.push(`**${name2} only:** ${only2Deities.join(', ')}`);
  }

  return lines.join('\n');
}

export async function getClassInfo(className: string): Promise<string> {
  await loadRaceClassInfo();
  if (!classDescriptions) return 'Class data not available.';

  // Resolve class ID
  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const name = CLASS_IDS[classId];
  const desc = classDescriptions.get(classId);
  if (!desc) return `No data found for class: ${name}`;

  const lines = [
    `## ${name} (${CLASS_SHORT[classId]})`,
    '',
    desc.long || desc.short,
    '',
  ];

  // Available races
  const availableRaces: string[] = [];
  for (const [raceId, classIds] of Object.entries(RACE_CLASSES)) {
    if (classIds.includes(classId)) {
      const raceName = RACE_IDS[parseInt(raceId)];
      if (raceName) availableRaces.push(raceName);
    }
  }
  if (availableRaces.length > 0) {
    lines.push(`**Available Races:** ${availableRaces.join(', ')}`);
  }

  return lines.join('\n');
}

export async function getDeityInfo(deityName: string): Promise<string> {
  await loadRaceClassInfo();

  const normalized = deityName.toLowerCase();

  // Find which races can worship this deity
  const racesForDeity: string[] = [];
  for (const [raceId, deities] of Object.entries(RACE_DEITIES)) {
    for (const d of deities) {
      if (d.toLowerCase().includes(normalized)) {
        const raceName = RACE_IDS[parseInt(raceId)];
        if (raceName) racesForDeity.push(raceName);
        break;
      }
    }
  }

  if (racesForDeity.length === 0) {
    // List all deities
    const allDeities = new Set<string>();
    for (const deities of Object.values(RACE_DEITIES)) {
      for (const d of deities) allDeities.add(d);
    }
    return `Unknown deity: "${deityName}". Valid deities: ${[...allDeities].sort().join(', ')}`;
  }

  // Find the actual deity name (properly cased)
  let properName = deityName;
  for (const deities of Object.values(RACE_DEITIES)) {
    for (const d of deities) {
      if (d.toLowerCase().includes(normalized)) {
        properName = d;
        break;
      }
    }
    if (properName !== deityName) break;
  }

  const lines = [
    `## ${properName}`,
    '',
  ];

  // Find deity lore description from dbstr type 14
  if (deityDescriptions) {
    for (const [deityId, desc] of deityDescriptions) {
      if (desc.toLowerCase().includes(properName.toLowerCase())) {
        lines.push(desc, '');
        break;
      }
    }
  }

  lines.push(`**Races that can worship ${properName}:** ${racesForDeity.join(', ')}`);

  return lines.join('\n');
}

export async function getStatInfo(statName?: string): Promise<string> {
  await loadRaceClassInfo();
  if (!statDescriptions || statDescriptions.size === 0) return 'Stat data not available.';

  if (statName) {
    // Find matching stat
    const normalized = statName.toLowerCase();
    for (const [name, desc] of statDescriptions) {
      if (name.toLowerCase().startsWith(normalized)) {
        return `## ${name}\n\n${desc}`;
      }
    }
    return `Unknown stat: "${statName}". Valid stats: ${[...statDescriptions.keys()].join(', ')}`;
  }

  // Show all stats
  const lines = ['## EverQuest Stats', ''];
  for (const [name, desc] of statDescriptions) {
    lines.push(`### ${name}`, desc, '');
  }
  return lines.join('\n');
}

// ============ PUBLIC API: ALTERNATE CURRENCIES ============

export async function searchAltCurrencies(query: string): Promise<SearchResult[]> {
  await loadAltCurrencies();
  if (!altCurrencies || altCurrencies.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, currency] of altCurrencies) {
    if (results.length >= 25) break;
    if (currency.name.toLowerCase().includes(normalized) ||
        currency.description.toLowerCase().includes(normalized)) {
      results.push({
        name: currency.name,
        type: 'unknown' as const,
        id: id.toString(),
        url: `local://currency/${id}`,
        source: 'Local Game Data',
        description: currency.description ? currency.description.substring(0, 120) + '...' : `Currency ID: ${id}`,
      });
    }
  }

  // Sort: exact > starts-with > contains
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aScore = aName === normalized ? 3 : aName.startsWith(normalized) ? 2 : 1;
    const bScore = bName === normalized ? 3 : bName.startsWith(normalized) ? 2 : 1;
    return bScore - aScore;
  });

  return results;
}

export async function listAltCurrencies(): Promise<string> {
  await loadAltCurrencies();
  if (!altCurrencies || altCurrencies.size === 0) return 'Alternate currency data not available.';

  const lines = ['## EverQuest Alternate Currencies', ''];
  const sorted = [...altCurrencies.entries()].sort((a, b) => a[0] - b[0]);
  for (const [id, currency] of sorted) {
    lines.push(`- **${currency.name}** (ID: ${id})${currency.description ? ` - ${currency.description}` : ''}`);
  }
  lines.push('', `*${altCurrencies.size} currencies total*`);
  return lines.join('\n');
}

// ============ PUBLIC API: TRIBUTES ============

export async function searchTributes(query: string): Promise<SearchResult[]> {
  await loadTributes();
  if (!tributes || tributes.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];

  for (const [id, tribute] of tributes) {
    if (results.length >= 25) break;
    if (tribute.name.toLowerCase().includes(normalized) ||
        tribute.description.toLowerCase().includes(normalized)) {
      results.push({
        name: `${tribute.name}${tribute.isGuild ? ' (Guild)' : ''}`,
        type: 'unknown' as const,
        id: id.toString(),
        url: `local://tribute/${id}`,
        source: 'Local Game Data',
        description: tribute.description.substring(0, 120) + (tribute.description.length > 120 ? '...' : ''),
      });
    }
  }

  // Sort: exact > starts-with > contains
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aScore = aName === normalized ? 3 : aName.startsWith(normalized) ? 2 : 1;
    const bScore = bName === normalized ? 3 : bName.startsWith(normalized) ? 2 : 1;
    return bScore - aScore;
  });

  return results;
}

export async function getTribute(id: string): Promise<string> {
  await loadTributes();
  if (!tributes) return 'Tribute data not available.';

  const tributeId = parseInt(id);
  const tribute = tributes.get(tributeId);
  if (!tribute) return `Tribute with ID ${id} not found.`;

  const lines = [
    `## ${tribute.name}`,
    '',
    `**Type:** ${tribute.isGuild ? 'Guild Tribute' : 'Personal Tribute'}`,
    '',
    tribute.description,
  ];

  return lines.join('\n');
}

// ============ PUBLIC API: ITEM EFFECTS ============

export async function searchItemEffects(query: string): Promise<SearchResult[]> {
  await loadItemEffects();
  if (!itemEffectDescs || itemEffectDescs.size === 0) return [];

  const normalized = query.toLowerCase();
  const results: SearchResult[] = [];
  const seen = new Set<number>();

  // First check word index for quick matches
  const queryWords = normalized.split(/\s+/).filter(w => w.length >= 3);
  if (queryWords.length > 0 && itemEffectIndex) {
    for (const word of queryWords) {
      const ids = itemEffectIndex.get(word) || [];
      for (const id of ids) {
        if (seen.has(id)) continue;
        seen.add(id);
        const desc = itemEffectDescs.get(id)!;
        if (desc.toLowerCase().includes(normalized)) {
          results.push({
            name: `Item Effect ${id}`,
            type: 'item' as const,
            id: id.toString(),
            url: `local://item-effect/${id}`,
            source: 'Local Game Data',
            description: desc.substring(0, 150) + (desc.length > 150 ? '...' : ''),
          });
        }
      }
    }
  }

  // Fall back to full scan if no index matches or too few results
  if (results.length < 10) {
    for (const [id, desc] of itemEffectDescs) {
      if (results.length >= 25) break;
      if (seen.has(id)) continue;
      if (desc.toLowerCase().includes(normalized)) {
        results.push({
          name: `Item Effect ${id}`,
          type: 'item' as const,
          id: id.toString(),
          url: `local://item-effect/${id}`,
          source: 'Local Game Data',
          description: desc.substring(0, 150) + (desc.length > 150 ? '...' : ''),
        });
      }
    }
  }

  return results.slice(0, 25);
}

export async function getItemEffect(id: string): Promise<string> {
  await loadItemEffects();
  if (!itemEffectDescs) return 'Item effect data not available.';

  const effectId = parseInt(id);
  const desc = itemEffectDescs.get(effectId);
  if (!desc) return `Item effect with ID ${id} not found.`;

  return [
    `## Item Effect ${id}`,
    '',
    desc,
  ].join('\n');
}

// ============ PUBLIC API: ZONE MAP POIs ============

export async function getZoneMapPOIs(zoneName: string, query?: string): Promise<string> {
  const pois = await loadMapPOIs(zoneName);

  if (pois.length === 0) {
    return `No map data found for "${zoneName}". Make sure Brewall or standard map files are installed.`;
  }

  let filtered = pois;
  if (query) {
    const lower = query.toLowerCase();
    filtered = pois.filter(p => p.label.toLowerCase().includes(lower));
    if (filtered.length === 0) {
      return `No POIs matching "${query}" found in ${zoneName} (${pois.length} total POIs available).`;
    }
  }

  const lines = [
    `## Map POIs: ${zoneName}`,
    query ? `*Filtered by: "${query}"*` : '',
    '',
    `**Total POIs:** ${query ? `${filtered.length} matching / ${pois.length} total` : pois.length}`,
    '',
  ];

  // Group by label prefix (first word) for organization
  const sorted = [...filtered].sort((a, b) => a.label.localeCompare(b.label));

  for (const poi of sorted.slice(0, 100)) {
    const coords = `(${poi.x.toFixed(0)}, ${poi.y.toFixed(0)}${poi.z ? `, ${poi.z.toFixed(0)}` : ''})`;
    lines.push(`- **${poi.label}** ${coords}`);
  }

  if (sorted.length > 100) {
    lines.push(``, `*... and ${sorted.length - 100} more POIs. Use a search query to filter.*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: LOCAL ZONE SEARCH ============

export async function searchZonesByName(query: string, levelMin?: number, levelMax?: number): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const normalized = query.toLowerCase();
  const matches: LocalZone[] = [];

  for (const [, zone] of zones) {
    const nameMatch = zone.name.toLowerCase().includes(normalized);
    if (!nameMatch) continue;

    // Optional level range filter
    if (levelMin !== undefined && zone.levelMax > 0 && zone.levelMax < levelMin) continue;
    if (levelMax !== undefined && zone.levelMin > 0 && zone.levelMin > levelMax) continue;

    matches.push(zone);
  }

  if (matches.length === 0) {
    return `No zones matching "${query}"${levelMin || levelMax ? ` in level range ${levelMin || 1}-${levelMax || 'max'}` : ''}.`;
  }

  // Sort by level range, then name
  matches.sort((a, b) => (a.levelMin || 0) - (b.levelMin || 0) || a.name.localeCompare(b.name));

  const lines = [`## Zones matching "${query}"`, ''];
  if (levelMin || levelMax) {
    lines.push(`*Level filter: ${levelMin || 1}-${levelMax || 'max'}*`, '');
  }
  lines.push(`**Found:** ${matches.length} zone${matches.length !== 1 ? 's' : ''}`, '');

  for (const zone of matches.slice(0, 50)) {
    const levelStr = zone.levelMin > 0 || zone.levelMax > 0
      ? ` (${zone.levelMin}-${zone.levelMax})`
      : '';
    lines.push(`- **${zone.name}**${levelStr} [ID: ${zone.id}]`);
  }

  if (matches.length > 50) {
    lines.push('', `*... and ${matches.length - 50} more zones. Refine your search.*`);
  }

  return lines.join('\n');
}

export async function searchLocalZonesByLevel(levelMin: number, levelMax: number): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const matches: LocalZone[] = [];

  for (const [, zone] of zones) {
    if (zone.levelMin === 0 && zone.levelMax === 0) continue; // Skip zones without level data
    if (zone.levelMax < levelMin) continue;
    if (zone.levelMin > levelMax) continue;
    matches.push(zone);
  }

  if (matches.length === 0) {
    return `No zones found for level range ${levelMin}-${levelMax}.`;
  }

  matches.sort((a, b) => (a.levelMin || 0) - (b.levelMin || 0) || a.name.localeCompare(b.name));

  const lines = [`## Zones for Level ${levelMin}-${levelMax}`, '', `**Found:** ${matches.length} zone${matches.length !== 1 ? 's' : ''}`, ''];

  for (const zone of matches.slice(0, 50)) {
    lines.push(`- **${zone.name}** (${zone.levelMin}-${zone.levelMax}) [ID: ${zone.id}]`);
  }

  if (matches.length > 50) {
    lines.push('', `*... and ${matches.length - 50} more zones.*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: TELEPORT SPELL SEARCH ============

export async function searchTeleportSpells(zoneName: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const normalized = zoneName.toLowerCase();
  const matches: { id: number; name: string; zone: string }[] = [];

  for (const [id, spell] of spells) {
    const f = spell.fields;
    if (f.length <= 3) continue;
    const tz = f[SF.TELEPORT_ZONE]?.trim();
    if (!tz || !/^[a-z_]+[a-z0-9_]*$/.test(tz)) continue;
    if (tz.includes(normalized) || spell.name.toLowerCase().includes(normalized)) {
      matches.push({ id, name: spell.name, zone: tz });
    }
  }

  if (matches.length === 0) {
    return `No teleport spells found for "${zoneName}".`;
  }

  // Sort by zone then name
  matches.sort((a, b) => a.zone.localeCompare(b.zone) || a.name.localeCompare(b.name));

  const lines = [`## Teleport Spells: "${zoneName}"`, '', `**Found:** ${matches.length} spell${matches.length !== 1 ? 's' : ''}`, ''];

  // Group by zone
  let currentZone = '';
  for (const m of matches.slice(0, 100)) {
    if (m.zone !== currentZone) {
      currentZone = m.zone;
      lines.push(`### ${currentZone}`);
    }
    lines.push(`- ${m.name} [ID: ${m.id}]`);
  }

  if (matches.length > 100) {
    lines.push('', `*... and ${matches.length - 100} more spells.*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: BANNER/CAMPSITE CATEGORIES ============

export async function getBannerCategories(): Promise<string> {
  await loadBannerCategories();

  const lines = ['## Guild Banner & Campsite Categories', ''];

  if (bannerCategories && bannerCategories.size > 0) {
    lines.push('### Guild Banner Categories');
    for (const [id, desc] of bannerCategories) {
      lines.push(`- ${desc} (ID: ${id})`);
    }
    lines.push('');
  }

  if (campsiteCategories && campsiteCategories.size > 0) {
    lines.push('### Fellowship Campsite Categories');
    for (const [id, desc] of campsiteCategories) {
      lines.push(`- ${desc} (ID: ${id})`);
    }
    lines.push('');
  }

  if ((!bannerCategories || bannerCategories.size === 0) && (!campsiteCategories || campsiteCategories.size === 0)) {
    return 'Banner/campsite category data not available.';
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL CATEGORIES ============

export async function listSpellCategories(): Promise<string> {
  await loadSpellDescriptions();
  if (!spellCategories || spellCategories.size === 0) return 'Spell category data not available.';

  const lines = ['## Spell Categories', ''];
  const sorted = [...spellCategories.entries()].sort((a, b) => a[1].localeCompare(b[1]));
  for (const [id, name] of sorted) {
    lines.push(`- ${name} (ID: ${id})`);
  }
  lines.push('', `*${sorted.length} categories total — use with get_spells_by_class category filter*`);
  return lines.join('\n');
}

// ============ PUBLIC API: EXPANSION LIST ============

async function loadExpansions(): Promise<void> {
  if (expansionNames !== null) return;
  await loadDbStrings([DBSTR_TYPES.EXPANSION_NAME]);
  expansionNames = dbStrings?.get(DBSTR_TYPES.EXPANSION_NAME) || new Map();
  console.error(`[LocalData] Loaded ${expansionNames.size} expansion names`);
}

export async function listExpansions(): Promise<string> {
  await loadExpansions();
  if (!expansionNames || expansionNames.size === 0) return 'Expansion data not available.';

  const lines = ['## EverQuest Expansions', ''];
  const sorted = [...expansionNames.entries()].sort((a, b) => a[0] - b[0]);
  for (const [id, name] of sorted) {
    lines.push(`${id}. ${name}`);
  }
  lines.push('', `*${sorted.length} expansions total*`);
  return lines.join('\n');
}

export function getExpansionName(id: number): string | undefined {
  return expansionNames?.get(id);
}

export async function getExpansionContent(expansionQuery: string): Promise<string> {
  await loadExpansions();
  await loadFactions();
  await loadAchievementCategories();

  if (!expansionNames || expansionNames.size === 0) return 'Expansion data not available.';

  // Find matching expansion
  const normalized = expansionQuery.toLowerCase();
  let matchedExpansion: { id: number; name: string } | null = null;

  // Try exact match first
  for (const [id, name] of expansionNames) {
    if (name.toLowerCase() === normalized) {
      matchedExpansion = { id, name };
      break;
    }
  }

  // Try partial match
  if (!matchedExpansion) {
    for (const [id, name] of expansionNames) {
      if (name.toLowerCase().includes(normalized)) {
        matchedExpansion = { id, name };
        break;
      }
    }
  }

  // Try by number
  if (!matchedExpansion) {
    const num = parseInt(expansionQuery);
    if (!isNaN(num) && expansionNames.has(num)) {
      matchedExpansion = { id: num, name: expansionNames.get(num)! };
    }
  }

  if (!matchedExpansion) {
    return `Expansion not found: "${expansionQuery}". Use list_expansions to see all expansions.`;
  }

  const lines = [
    `## ${matchedExpansion.name} (Expansion ${matchedExpansion.id})`,
    '',
  ];

  // Factions for this expansion
  if (factions && factions.size > 0) {
    const expansionFactions: { id: number; name: string }[] = [];
    for (const [id, faction] of factions) {
      if (faction.category && faction.category.toLowerCase() === matchedExpansion.name.toLowerCase()) {
        expansionFactions.push({ id, name: faction.name });
      }
    }
    if (expansionFactions.length > 0) {
      expansionFactions.sort((a, b) => a.name.localeCompare(b.name));
      lines.push(`### Factions (${expansionFactions.length})`);
      for (const f of expansionFactions) {
        lines.push(`- ${f.name} (ID: ${f.id})`);
      }
      lines.push('');
    }
  }

  // Achievement categories for this expansion
  if (achievementCategories && categoryToAchievements) {
    // Find top-level category matching this expansion
    const matchingCats: AchievementCategory[] = [];
    for (const [, cat] of achievementCategories) {
      if (cat.parentId === 0 && cat.name.toLowerCase() === matchedExpansion.name.toLowerCase()) {
        matchingCats.push(cat);
      }
    }

    if (matchingCats.length > 0) {
      for (const topCat of matchingCats) {
        // Find subcategories
        const subcats: { cat: AchievementCategory; count: number }[] = [];
        let totalAchievements = 0;

        for (const [, cat] of achievementCategories) {
          if (cat.parentId === topCat.id) {
            const achievementIds = categoryToAchievements.get(cat.id) || [];
            subcats.push({ cat, count: achievementIds.length });
            totalAchievements += achievementIds.length;
          }
        }

        // Also count achievements directly in top-level category
        const directIds = categoryToAchievements.get(topCat.id) || [];
        totalAchievements += directIds.length;

        lines.push(`### Achievements (${totalAchievements})`);
        if (subcats.length > 0) {
          subcats.sort((a, b) => a.cat.order - b.cat.order);
          for (const { cat, count } of subcats) {
            lines.push(`- **${cat.name}** — ${count} achievements`);
          }
        }
        if (directIds.length > 0) {
          lines.push(`- *(${directIds.length} uncategorized)*`);
        }
        lines.push('');
      }
    }
  }

  if (lines.length <= 2) {
    lines.push('*No faction or achievement data found for this expansion.*');
  }

  return lines.join('\n');
}

// ============ PUBLIC API: GAME EVENTS ============

async function loadGameEvents(): Promise<void> {
  if (gameEvents !== null) return;
  await loadDbStrings([DBSTR_TYPES.EVENT_BANNER, DBSTR_TYPES.EVENT_DESCRIPTION]);
  const banners = dbStrings?.get(DBSTR_TYPES.EVENT_BANNER) || new Map<number, string>();
  const descriptions = dbStrings?.get(DBSTR_TYPES.EVENT_DESCRIPTION) || new Map<number, string>();

  gameEvents = new Map();
  gameEventIndex = new Map();

  const allIds = new Set([...banners.keys(), ...descriptions.keys()]);
  for (const id of allIds) {
    const banner = banners.get(id) || '';
    const rawDesc = descriptions.get(id) || '';
    const description = stripHtmlTags(rawDesc.replace(/<c\s+"[^"]*">/gi, '').replace(/<\/c>/gi, ''));
    if (!banner && !description) continue;
    gameEvents.set(id, { banner, description });

    // Build word index
    const text = `${banner} ${description}`.toLowerCase();
    const words = text.split(/\W+/).filter(w => w.length > 2);
    for (const word of new Set(words)) {
      const existing = gameEventIndex!.get(word) || [];
      existing.push(id);
      gameEventIndex!.set(word, existing);
    }
  }
  console.error(`[LocalData] Loaded ${gameEvents.size} game events`);
}

export async function searchGameEvents(query: string): Promise<SearchResult[]> {
  await loadGameEvents();
  if (!gameEvents || !gameEventIndex) return [];

  const results: SearchResult[] = [];
  const normalizedQuery = normalizeQuery(query);
  const lowerQuery = normalizedQuery.toLowerCase();
  const queryWords = lowerQuery.split(/\W+/).filter(w => w.length > 2);

  // Word index search
  const idScores = new Map<number, number>();
  for (const word of queryWords) {
    for (const [indexWord, ids] of gameEventIndex) {
      if (indexWord.includes(word) || word.includes(indexWord)) {
        for (const id of ids) {
          idScores.set(id, (idScores.get(id) || 0) + 1);
        }
      }
    }
  }

  // Substring fallback
  if (idScores.size === 0) {
    for (const [id, event] of gameEvents) {
      const text = `${event.banner} ${event.description}`.toLowerCase();
      if (text.includes(lowerQuery)) {
        idScores.set(id, 1);
      }
    }
  }

  const sorted = [...idScores.entries()].sort((a, b) => b[1] - a[1]);
  for (const [id] of sorted.slice(0, 20)) {
    const event = gameEvents.get(id);
    if (!event) continue;
    results.push({
      name: event.banner || `Event ${id}`,
      type: 'event',
      id: String(id),
      source: 'Local Game Data',
      url: '',
    });
  }

  return results;
}

export async function getGameEvent(id: string): Promise<string> {
  await loadGameEvents();
  if (!gameEvents) return 'Game event data not available.';

  const eventId = parseInt(id);
  const event = gameEvents.get(eventId);
  if (!event) return `Game event with ID ${id} not found.`;

  const lines = [`## ${event.banner || `Event ${eventId}`}`, ''];
  if (event.description) {
    lines.push(event.description.trim());
  }
  lines.push('', `*Event ID: ${eventId}*`);
  return lines.join('\n');
}

// ============ CREATURE RACE TYPES ============

async function loadCreatureTypes(): Promise<void> {
  if (creatureTypes !== null) return;

  creatureTypes = new Map();
  creatureTypeIndex = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([DBSTR_TYPES.CREATURE_RACE]);
  const races: Map<number, string> = dbStrings?.get(DBSTR_TYPES.CREATURE_RACE) || new Map();

  for (const [id, name] of races) {
    if (!name || name === 'UNKNOWN RACE') continue;
    creatureTypes.set(id, name);

    // Build word index
    const words = name.toLowerCase().split(/\W+/).filter((w: string) => w.length > 2);
    for (const word of new Set(words)) {
      const existing = creatureTypeIndex!.get(word) || [];
      existing.push(id);
      creatureTypeIndex!.set(word, existing);
    }
  }
  console.error(`[LocalData] Loaded ${creatureTypes.size} creature race types`);
}

export async function searchCreatureTypes(query: string): Promise<string> {
  await loadCreatureTypes();
  if (!creatureTypes || creatureTypes.size === 0) return 'Creature type data not available.';

  const lowerQuery = query.toLowerCase().trim();
  const matches: { id: number; name: string; score: number }[] = [];

  // Word index search
  const queryWords = lowerQuery.split(/\W+/).filter(w => w.length > 2);
  const idScores = new Map<number, number>();

  if (queryWords.length > 0 && creatureTypeIndex) {
    for (const word of queryWords) {
      for (const [indexWord, ids] of creatureTypeIndex) {
        if (indexWord.includes(word) || word.includes(indexWord)) {
          for (const id of ids) {
            idScores.set(id, (idScores.get(id) || 0) + 1);
          }
        }
      }
    }
  }

  // Also do direct substring matching on full names
  for (const [id, name] of creatureTypes) {
    const lowerName = name.toLowerCase();
    let score = idScores.get(id) || 0;
    if (lowerName === lowerQuery) score += 10;
    else if (lowerName.startsWith(lowerQuery)) score += 5;
    else if (lowerName.includes(lowerQuery)) score += 3;
    if (score > 0) matches.push({ id, name, score });
  }

  if (matches.length === 0) {
    // Fuzzy fallback
    for (const [id, name] of creatureTypes) {
      if (fuzzyMatch(name, query)) {
        matches.push({ id, name, score: 1 });
      }
    }
  }

  matches.sort((a, b) => b.score - a.score);
  const limited = matches.slice(0, 50);

  if (limited.length === 0) return `No creature types found matching "${query}".`;

  const lines = [`## Creature/NPC Race Types matching "${query}"`, '', `Found ${limited.length} of ${matches.length} matches:`, ''];
  for (const m of limited) {
    lines.push(`- **${m.name}** (Race ID: ${m.id})`);
  }

  lines.push('', `*${creatureTypes.size} total creature types available*`);
  return lines.join('\n');
}

// ============ STARTING CITY LORE ============

async function loadStartingCityLore(): Promise<void> {
  if (startingCityLore !== null) return;

  startingCityLore = new Map();
  if (!isGameDataAvailable()) return;

  await loadDbStrings([DBSTR_TYPES.STARTING_CITY]);
  const cities = dbStrings?.get(DBSTR_TYPES.STARTING_CITY) || new Map();
  for (const [id, text] of cities) {
    if (text) startingCityLore.set(id, text);
  }
  console.error(`[LocalData] Loaded ${startingCityLore.size} starting city descriptions`);
}

// ============ DRAKKIN HERITAGES ============

async function loadDrakkinHeritages(): Promise<void> {
  if (drakkinHeritages !== null) return;

  drakkinHeritages = [];
  if (!isGameDataAvailable()) return;

  try {
    const data = await readGameFile(join('Resources', 'playercustomization.txt'));
    const seen = new Set<number>();

    for (const line of data.split('\n')) {
      if (!line.trim() || line.startsWith('#')) continue;
      const fields = line.split('^');
      if (fields.length < 5) continue;

      const raceId = parseInt(fields[0]);
      if (raceId !== 522) continue; // Drakkin only

      const heritageId = parseInt(fields[1]);
      if (isNaN(heritageId) || seen.has(heritageId)) continue;
      seen.add(heritageId);

      const name = fields[2] || '';
      if (!name) continue;

      // Parse class list
      const classStr = fields[4] || '';
      const classes = classStr.split(',').map(c => parseInt(c.trim())).filter(c => !isNaN(c));

      drakkinHeritages.push({ id: heritageId, name, classes });
    }
  } catch {
    // playercustomization.txt not available
  }
  console.error(`[LocalData] Loaded ${drakkinHeritages.length} Drakkin heritages`);
}



// ============ PUBLIC API: HELP TOPICS ============

let helpTopics: Map<string, { title: string; filename: string }> | null = null;

async function loadHelpTopics(): Promise<void> {
  if (helpTopics !== null) return;
  helpTopics = new Map();

  if (!isGameDataAvailable()) return;

  const helpDir = join(EQ_GAME_PATH, 'Help');
  if (!existsSync(helpDir)) return;

  try {
    const files = await readdir(helpDir);
    for (const file of files) {
      if (!file.endsWith('.html')) continue;
      const topic = file.replace('.html', '');
      try {
        const content = await readFile(join(helpDir, file), 'utf8');
        // Extract title from <c "#ffff00"> Title </c>
        const titleMatch = content.match(/<c\s+"#ffff00">\s*(.+?)\s*<\/c>/i);
        const title = titleMatch ? titleMatch[1].trim() : topic;
        helpTopics!.set(topic, { title, filename: file });
      } catch {
        helpTopics!.set(topic, { title: topic, filename: file });
      }
    }
    console.error(`[LocalData] Loaded ${helpTopics.size} help topics`);
  } catch (error) {
    console.error('[LocalData] Failed to load help topics:', error instanceof Error ? error.message : error);
  }
}

function stripHelpHtml(html: string): string {
  return html
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n')
    .replace(/<body[^>]*>/gi, '')
    .replace(/<\/body>/gi, '')
    .replace(/<c\s+"#ffff00">\s*(.+?)\s*<\/c>/gi, '## $1')
    .replace(/<c\s+"#66CCFF">\s*(.+?)\s*<\/c>/gi, '**$1**')
    .replace(/<c\s+"[^"]*">\s*(.+?)\s*<\/c>/gi, '$1')
    .replace(/<a\s+href="file:\/\/\/help\/([^"]+)">\s*(.+?)\s*<\/a>/gi, '$2 [→ $1]')
    .replace(/<a\s+href="[^"]*">\s*(.+?)\s*<\/a>/gi, '$1')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<[^>]+>/g, '')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

export async function searchHelpTopics(query?: string): Promise<string> {
  await loadHelpTopics();
  if (!helpTopics || helpTopics.size === 0) return 'Help topics not available.';

  if (!query || query.trim() === '') {
    // List all topics
    const sorted = [...helpTopics.entries()].sort((a, b) => a[1].title.localeCompare(b[1].title));
    const lines = [
      `## EverQuest Help Topics (${sorted.length})`,
      '',
      ...sorted.map(([topic, { title }]) => `- **${title}** → \`${topic}\``),
    ];
    return lines.join('\n');
  }

  const normalized = query.toLowerCase();
  const matches: { topic: string; title: string; relevance: number }[] = [];

  for (const [topic, { title }] of helpTopics) {
    const lTitle = title.toLowerCase();
    const lTopic = topic.toLowerCase();
    if (lTitle === normalized || lTopic === normalized) {
      matches.push({ topic, title, relevance: 3 });
    } else if (lTitle.startsWith(normalized) || lTopic.startsWith(normalized)) {
      matches.push({ topic, title, relevance: 2 });
    } else if (lTitle.includes(normalized) || lTopic.includes(normalized)) {
      matches.push({ topic, title, relevance: 1 });
    }
  }

  if (matches.length === 0) {
    // Search within help file content
    const helpDir = join(EQ_GAME_PATH, 'Help');
    const contentMatches: { topic: string; title: string }[] = [];
    for (const [topic, { title, filename }] of helpTopics) {
      try {
        const content = await readFile(join(helpDir, filename), 'utf8');
        if (content.toLowerCase().includes(normalized)) {
          contentMatches.push({ topic, title });
        }
      } catch { /* skip */ }
    }
    if (contentMatches.length > 0) {
      const lines = [
        `## Help Topics mentioning "${query}" (${contentMatches.length})`,
        '',
        ...contentMatches.map(m => `- **${m.title}** → \`${m.topic}\``),
      ];
      return lines.join('\n');
    }
    return `No help topics found matching "${query}". Use search_help_topics without a query to list all topics.`;
  }

  matches.sort((a, b) => b.relevance - a.relevance);
  const lines = [
    `## Help Topics matching "${query}" (${matches.length})`,
    '',
    ...matches.map(m => `- **${m.title}** → \`${m.topic}\``),
  ];
  return lines.join('\n');
}

export async function getHelpTopic(topic: string): Promise<string> {
  await loadHelpTopics();
  if (!helpTopics || helpTopics.size === 0) return 'Help topics not available.';

  // Try exact match first
  const normalized = topic.toLowerCase().replace('.html', '');
  let entry = helpTopics.get(normalized);

  // Try fuzzy match
  if (!entry) {
    for (const [key, val] of helpTopics) {
      if (key.toLowerCase() === normalized || val.title.toLowerCase() === normalized) {
        entry = val;
        break;
      }
    }
  }

  // Try partial match
  if (!entry) {
    for (const [key, val] of helpTopics) {
      if (key.toLowerCase().includes(normalized) || val.title.toLowerCase().includes(normalized)) {
        entry = val;
        break;
      }
    }
  }

  if (!entry) {
    return `Help topic "${topic}" not found. Use search_help_topics to list available topics.`;
  }

  const helpDir = join(EQ_GAME_PATH, 'Help');
  try {
    const content = await readFile(join(helpDir, entry.filename), 'utf8');
    return stripHelpHtml(content);
  } catch (error) {
    return `Failed to read help topic: ${error instanceof Error ? error.message : error}`;
  }
}

// ============ PUBLIC API: SHARED SPELLS ============

export async function getSharedSpells(class1: string, class2: string, level?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId1 = CLASS_NAME_TO_ID[class1.toLowerCase()];
  const classId2 = CLASS_NAME_TO_ID[class2.toLowerCase()];
  if (!classId1) return `Unknown class: "${class1}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (!classId2) return `Unknown class: "${class2}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (classId1 === classId2) return `Please specify two different classes to compare.`;

  const idx1 = classId1 - 1;
  const idx2 = classId2 - 1;
  const name1 = CLASS_IDS[classId1];
  const name2 = CLASS_IDS[classId2];

  const shared: { id: number; name: string; level1: number; level2: number; category?: string }[] = [];

  for (const [id, spell] of spells) {
    const lv1 = parseInt(spell.fields[SF.CLASS_LEVEL_START + idx1]);
    const lv2 = parseInt(spell.fields[SF.CLASS_LEVEL_START + idx2]);
    if (isNaN(lv1) || lv1 === 255 || lv1 <= 0) continue;
    if (isNaN(lv2) || lv2 === 255 || lv2 <= 0) continue;

    if (level !== undefined && (lv1 > level || lv2 > level)) continue;

    let cat: string | undefined;
    if (spellCategories) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) cat = spellCategories.get(catId);
    }

    shared.push({ id, name: spell.name, level1: lv1, level2: lv2, category: cat });
  }

  shared.sort((a, b) => Math.min(a.level1, a.level2) - Math.min(b.level1, b.level2) || a.name.localeCompare(b.name));

  if (shared.length === 0) {
    return `No shared spells found between ${name1} and ${name2}${level ? ` at or below level ${level}` : ''}.`;
  }

  const lines = [
    `## Shared Spells: ${name1} & ${name2}${level ? ` (≤ Level ${level})` : ''}`,
    `*${shared.length} spells shared*`,
    '',
    `| Spell | ${name1} Lvl | ${name2} Lvl | Category |`,
    `|-------|------------|------------|----------|`,
  ];

  const limit = 150;
  for (let i = 0; i < Math.min(shared.length, limit); i++) {
    const s = shared[i];
    const lvDiff = s.level1 !== s.level2 ? ' ⚡' : '';
    lines.push(`| ${s.name} (${s.id}) | ${s.level1} | ${s.level2}${lvDiff} | ${s.category || '-'} |`);
  }

  if (shared.length > limit) {
    lines.push(`\n*...and ${shared.length - limit} more shared spells*`);
  }

  const sameLevelCount = shared.filter(s => s.level1 === s.level2).length;
  const class1Earlier = shared.filter(s => s.level1 < s.level2).length;
  const class2Earlier = shared.filter(s => s.level2 < s.level1).length;
  lines.push('');
  lines.push(`### Summary`);
  lines.push(`- Same level: ${sameLevelCount}`);
  lines.push(`- ${name1} gets earlier: ${class1Earlier}`);
  lines.push(`- ${name2} gets earlier: ${class2Earlier}`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL LINE PROGRESSION ============

export async function getSpellLine(spellName: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Strip rank suffixes to find base name
  const baseName = spellName
    .replace(/\s+Rk\.\s*(II|III|IV|V|VI|VII|VIII|IX|X)\s*$/i, '')
    .replace(/\s+(II|III|IV|V|VI|VII|VIII|IX|X)\s*$/i, '')
    .trim();

  const lowerBase = baseName.toLowerCase();

  // Find all spells whose name starts with the base name + rank/version pattern
  const exactMatches: { id: number; name: string; classes: { className: string; level: number }[] }[] = [];

  for (const [id, spell] of spells) {
    const lowerName = spell.name.toLowerCase();
    if (lowerName === lowerBase ||
        lowerName.startsWith(lowerBase + ' rk.') ||
        (lowerName.startsWith(lowerBase + ' ') && /^(ii|iii|iv|v|vi|vii|viii|ix|x)$/i.test(spell.name.substring(baseName.length + 1).trim()))) {
      const classes: { className: string; level: number }[] = [];
      for (let i = 0; i < 16; i++) {
        const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + i]);
        if (!isNaN(lv) && lv !== 255 && lv > 0) {
          classes.push({ className: CLASS_IDS[i + 1], level: lv });
        }
      }
      if (classes.length > 0) {
        exactMatches.push({ id, name: spell.name, classes });
      }
    }
  }

  // If no exact matches, try broader substring search
  let results = exactMatches;
  if (results.length === 0) {
    for (const [id, spell] of spells) {
      if (spell.name.toLowerCase().includes(lowerBase)) {
        const classes: { className: string; level: number }[] = [];
        for (let i = 0; i < 16; i++) {
          const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + i]);
          if (!isNaN(lv) && lv !== 255 && lv > 0) {
            classes.push({ className: CLASS_IDS[i + 1], level: lv });
          }
        }
        if (classes.length > 0) {
          results.push({ id, name: spell.name, classes });
        }
      }
    }
  }

  if (results.length === 0) {
    return `No spell line found for "${spellName}".`;
  }

  // Sort by minimum class level
  results.sort((a, b) => {
    const minA = Math.min(...a.classes.map(c => c.level));
    const minB = Math.min(...b.classes.map(c => c.level));
    return minA - minB || a.name.localeCompare(b.name);
  });

  // Cap results
  if (results.length > 100) results = results.slice(0, 100);

  const lines = [
    `## Spell Line: ${baseName}`,
    `*${results.length} versions found*`,
    '',
  ];

  // Collect all classes that use this spell line
  const allClasses = new Set<string>();
  for (const r of results) {
    for (const c of r.classes) allClasses.add(c.className);
  }
  const classOrder = Object.values(CLASS_IDS).filter(c => allClasses.has(c));

  // Build table
  const classHeaders = classOrder.map(c => c.substring(0, 3)).join(' | ');
  const classDashes = classOrder.map(() => '---').join(' | ');
  lines.push(`| Spell | ${classHeaders} |`);
  lines.push(`|-------|${classDashes}|`);

  for (const r of results) {
    const classMap = new Map(r.classes.map(c => [c.className, c.level]));
    const classLevels = classOrder.map(c => {
      const lv = classMap.get(c);
      return lv !== undefined ? String(lv) : '-';
    }).join(' | ');
    lines.push(`| ${r.name} (${r.id}) | ${classLevels} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: BENEFICIAL/DETRIMENTAL SPELL SEARCH ============

export async function searchSpellsByBeneficial(className: string, beneficial: boolean, level?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const classIndex = classId - 1;
  const typeLabel = beneficial ? 'Beneficial (Buff)' : 'Detrimental (Debuff)';
  const matching: { id: number; name: string; level: number; category?: string; target: string }[] = [];

  for (const [id, spell] of spells) {
    const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
    if (isNaN(classLevel) || classLevel === 255 || classLevel <= 0) continue;
    if (level !== undefined && classLevel > level) continue;

    const isBeneficial = spell.fields[SF.BENEFICIAL] === '1';
    if (isBeneficial !== beneficial) continue;

    let cat: string | undefined;
    if (spellCategories) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) cat = spellCategories.get(catId);
    }

    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]);
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;

    matching.push({ id, name: spell.name, level: classLevel, category: cat, target });
  }

  matching.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  if (matching.length === 0) {
    return `No ${typeLabel.toLowerCase()} spells found for ${CLASS_IDS[classId]}${level ? ` at or below level ${level}` : ''}.`;
  }

  const lines = [
    `## ${CLASS_IDS[classId]} — ${typeLabel} Spells${level ? ` (≤ Level ${level})` : ''}`,
    `*${matching.length} spells found*`,
    '',
  ];

  // Group by category for summary
  const byCategory = new Map<string, number>();
  for (const s of matching) {
    const cat = s.category || 'Uncategorized';
    byCategory.set(cat, (byCategory.get(cat) || 0) + 1);
  }

  const sortedCats = [...byCategory.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('### By Category');
  for (const [cat, count] of sortedCats) {
    lines.push(`- **${cat}**: ${count}`);
  }
  lines.push('');

  // Show spells grouped by level
  let currentLevel = -1;
  let count = 0;
  for (const s of matching) {
    if (count >= 200) {
      lines.push(`\n*... and ${matching.length - count} more*`);
      break;
    }
    if (s.level !== currentLevel) {
      currentLevel = s.level;
      lines.push(`\n### Level ${currentLevel}`);
    }
    lines.push(`- **${s.name}** (${s.id}) — ${s.target}${s.category ? ` [${s.category}]` : ''}`);
    count++;
  }

  return lines.join('\n');
}

// ============ PUBLIC API: EXCLUSIVE SPELLS ============

export async function getExclusiveSpells(className: string, level?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const classIndex = classId - 1;
  const exclusive: { id: number; name: string; level: number; category?: string }[] = [];

  for (const [id, spell] of spells) {
    const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
    if (isNaN(classLevel) || classLevel === 255 || classLevel <= 0) continue;
    if (level !== undefined && classLevel > level) continue;

    // Check if no other class can use this spell
    let otherClassHas = false;
    for (let i = 0; i < 16; i++) {
      if (i === classIndex) continue;
      const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + i]);
      if (!isNaN(lv) && lv !== 255 && lv > 0) {
        otherClassHas = true;
        break;
      }
    }

    if (!otherClassHas) {
      let cat: string | undefined;
      if (spellCategories) {
        const catId = parseInt(spell.fields[SF.CATEGORY]);
        if (!isNaN(catId) && catId > 0) cat = spellCategories.get(catId);
      }
      exclusive.push({ id, name: spell.name, level: classLevel, category: cat });
    }
  }

  exclusive.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  if (exclusive.length === 0) {
    return `No exclusive spells found for ${CLASS_IDS[classId]}${level ? ` at or below level ${level}` : ''}.`;
  }

  const lines = [
    `## ${CLASS_IDS[classId]} — Exclusive Spells${level ? ` (≤ Level ${level})` : ''}`,
    `*${exclusive.length} spells only ${CLASS_IDS[classId]} can cast*`,
    '',
  ];

  // Category summary
  const byCategory = new Map<string, number>();
  for (const s of exclusive) {
    const cat = s.category || 'Uncategorized';
    byCategory.set(cat, (byCategory.get(cat) || 0) + 1);
  }
  const sortedCats = [...byCategory.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('### By Category');
  for (const [cat, count] of sortedCats) {
    lines.push(`- **${cat}**: ${count}`);
  }
  lines.push('');

  let currentLevel = -1;
  let count = 0;
  for (const s of exclusive) {
    if (count >= 200) {
      lines.push(`\n*... and ${exclusive.length - count} more*`);
      break;
    }
    if (s.level !== currentLevel) {
      currentLevel = s.level;
      lines.push(`\n### Level ${currentLevel}`);
    }
    lines.push(`- **${s.name}** (${s.id})${s.category ? ` [${s.category}]` : ''}`);
    count++;
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS COMPARISON ============

export async function compareClasses(class1: string, class2: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  await loadRaceClassInfo();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId1 = CLASS_NAME_TO_ID[class1.toLowerCase()];
  const classId2 = CLASS_NAME_TO_ID[class2.toLowerCase()];
  if (!classId1) return `Unknown class: "${class1}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (!classId2) return `Unknown class: "${class2}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (classId1 === classId2) return `Please specify two different classes to compare.`;

  const name1 = CLASS_IDS[classId1];
  const name2 = CLASS_IDS[classId2];
  const idx1 = classId1 - 1;
  const idx2 = classId2 - 1;

  // Races
  const races1 = new Set<string>();
  const races2 = new Set<string>();
  for (const [raceId, classIds] of Object.entries(RACE_CLASSES)) {
    const raceName = RACE_IDS[parseInt(raceId)];
    if (!raceName) continue;
    if (classIds.includes(classId1)) races1.add(raceName);
    if (classIds.includes(classId2)) races2.add(raceName);
  }

  const sharedRaces = [...races1].filter(r => races2.has(r));
  const uniqueRaces1 = [...races1].filter(r => !races2.has(r));
  const uniqueRaces2 = [...races2].filter(r => !races1.has(r));

  // Spell analysis
  let total1 = 0, total2 = 0, shared = 0;
  const cats1 = new Map<string, number>();
  const cats2 = new Map<string, number>();
  const catsShared = new Map<string, number>();

  for (const [, spell] of spells) {
    const lv1 = parseInt(spell.fields[SF.CLASS_LEVEL_START + idx1]);
    const lv2 = parseInt(spell.fields[SF.CLASS_LEVEL_START + idx2]);
    const has1 = !isNaN(lv1) && lv1 !== 255 && lv1 > 0;
    const has2 = !isNaN(lv2) && lv2 !== 255 && lv2 > 0;

    let cat = 'Uncategorized';
    if (spellCategories) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) {
        cat = spellCategories.get(catId) || 'Uncategorized';
      }
    }

    if (has1) { total1++; cats1.set(cat, (cats1.get(cat) || 0) + 1); }
    if (has2) { total2++; cats2.set(cat, (cats2.get(cat) || 0) + 1); }
    if (has1 && has2) { shared++; catsShared.set(cat, (catsShared.get(cat) || 0) + 1); }
  }

  const lines = [
    `## Class Comparison: ${name1} vs ${name2}`,
    '',
    '### Races',
    `| | ${name1} | ${name2} |`,
    `|---|---|---|`,
    `| Total | ${races1.size} | ${races2.size} |`,
    `| Shared | ${sharedRaces.length} | ${sharedRaces.length} |`,
    '',
    `**Shared:** ${sharedRaces.join(', ') || 'None'}`,
    `**${name1} only:** ${uniqueRaces1.join(', ') || 'None'}`,
    `**${name2} only:** ${uniqueRaces2.join(', ') || 'None'}`,
    '',
    '### Spells',
    `| | ${name1} | ${name2} |`,
    `|---|---|---|`,
    `| Total spells | ${total1} | ${total2} |`,
    `| Shared spells | ${shared} | ${shared} |`,
    `| Exclusive spells | ${total1 - shared} | ${total2 - shared} |`,
    '',
  ];

  // Category comparison
  const allCats = new Set([...cats1.keys(), ...cats2.keys()]);
  const catComparison: { cat: string; c1: number; c2: number; s: number }[] = [];
  for (const cat of allCats) {
    catComparison.push({
      cat,
      c1: cats1.get(cat) || 0,
      c2: cats2.get(cat) || 0,
      s: catsShared.get(cat) || 0,
    });
  }
  catComparison.sort((a, b) => (b.c1 + b.c2) - (a.c1 + a.c2));

  lines.push('### Spell Categories');
  lines.push(`| Category | ${name1} | ${name2} | Shared |`);
  lines.push(`|----------|---|---|---|`);
  for (const c of catComparison.slice(0, 30)) {
    lines.push(`| ${c.cat} | ${c.c1} | ${c.c2} | ${c.s} |`);
  }
  if (catComparison.length > 30) {
    lines.push(`*...and ${catComparison.length - 30} more categories*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: ADVANCED SPELL SEARCH ============

export async function searchSpellsAdvanced(criteria: {
  class?: string;
  minLevel?: number;
  maxLevel?: number;
  beneficial?: boolean;
  targetType?: string;
  resistType?: string;
  category?: string;
  nameContains?: string;
  hasEffect?: string;
}): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class
  let classId: number | undefined;
  let classIndex: number | undefined;
  if (criteria.class) {
    classId = CLASS_NAME_TO_ID[criteria.class.toLowerCase()];
    if (!classId) return `Unknown class: "${criteria.class}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    classIndex = classId - 1;
  }

  // Resolve target type
  let targetTypeId: number | undefined;
  if (criteria.targetType) {
    const lowerTarget = criteria.targetType.toLowerCase();
    for (const [id, name] of Object.entries(TARGET_TYPES)) {
      if (name.toLowerCase().includes(lowerTarget)) {
        targetTypeId = parseInt(id);
        break;
      }
    }
    if (targetTypeId === undefined) {
      return `Unknown target type: "${criteria.targetType}". Valid: ${Object.values(TARGET_TYPES).join(', ')}`;
    }
  }

  // Resolve resist type
  let resistTypeId: number | undefined;
  if (criteria.resistType) {
    const lowerResist = criteria.resistType.toLowerCase();
    for (const [id, name] of Object.entries(RESIST_TYPES)) {
      if (name.toLowerCase() === lowerResist || name.toLowerCase().startsWith(lowerResist)) {
        resistTypeId = parseInt(id);
        break;
      }
    }
    if (resistTypeId === undefined) {
      return `Unknown resist type: "${criteria.resistType}". Valid: ${Object.values(RESIST_TYPES).join(', ')}`;
    }
  }

  // Resolve effect SPA
  let effectSPA: number | undefined;
  if (criteria.hasEffect) {
    const lowerEffect = criteria.hasEffect.toLowerCase();
    for (const [id, name] of Object.entries(SPA_NAMES)) {
      if (name.toLowerCase().includes(lowerEffect)) {
        effectSPA = parseInt(id);
        break;
      }
    }
  }

  const lowerCategory = criteria.category?.toLowerCase();
  const lowerName = criteria.nameContains?.toLowerCase();

  const matching: { id: number; name: string; level: number; category?: string; target: string; resist: string }[] = [];

  for (const [id, spell] of spells) {
    // Class filter
    let classLevel: number | undefined;
    if (classIndex !== undefined) {
      classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
      if (isNaN(classLevel) || classLevel === 255 || classLevel <= 0) continue;
      if (criteria.minLevel !== undefined && classLevel < criteria.minLevel) continue;
      if (criteria.maxLevel !== undefined && classLevel > criteria.maxLevel) continue;
    }

    // Beneficial/detrimental
    if (criteria.beneficial !== undefined) {
      const isBeneficial = spell.fields[SF.BENEFICIAL] === '1';
      if (isBeneficial !== criteria.beneficial) continue;
    }

    // Target type
    if (targetTypeId !== undefined) {
      const spellTarget = parseInt(spell.fields[SF.TARGET_TYPE]);
      if (spellTarget !== targetTypeId) continue;
    }

    // Resist type
    if (resistTypeId !== undefined) {
      const spellResist = parseInt(spell.fields[SF.RESIST_TYPE]);
      if (spellResist !== resistTypeId) continue;
    }

    // Name filter
    if (lowerName && !spell.name.toLowerCase().includes(lowerName)) continue;

    // Category filter
    let cat: string | undefined;
    if (spellCategories) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) cat = spellCategories.get(catId);
    }
    if (lowerCategory && !(cat?.toLowerCase().includes(lowerCategory))) continue;

    // Effect filter
    if (effectSPA !== undefined) {
      let hasEffect = false;
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i] === String(effectSPA)) {
          hasEffect = true;
          break;
        }
      }
      if (!hasEffect) continue;
    }

    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]);
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;
    const resistId = parseInt(spell.fields[SF.RESIST_TYPE]);
    const resist = RESIST_TYPES[resistId] || `Type ${resistId}`;

    matching.push({
      id,
      name: spell.name,
      level: classLevel || 0,
      category: cat,
      target,
      resist,
    });
  }

  matching.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  // Build filter description
  const filters: string[] = [];
  if (classId) filters.push(`Class: ${CLASS_IDS[classId]}`);
  if (criteria.minLevel !== undefined) filters.push(`Min Level: ${criteria.minLevel}`);
  if (criteria.maxLevel !== undefined) filters.push(`Max Level: ${criteria.maxLevel}`);
  if (criteria.beneficial !== undefined) filters.push(criteria.beneficial ? 'Beneficial' : 'Detrimental');
  if (criteria.targetType) filters.push(`Target: ${TARGET_TYPES[targetTypeId!] || criteria.targetType}`);
  if (criteria.resistType) filters.push(`Resist: ${RESIST_TYPES[resistTypeId!] || criteria.resistType}`);
  if (criteria.category) filters.push(`Category: ${criteria.category}`);
  if (criteria.nameContains) filters.push(`Name: "${criteria.nameContains}"`);
  if (criteria.hasEffect) filters.push(`Effect: ${criteria.hasEffect}`);

  if (matching.length === 0) {
    return `No spells found matching: ${filters.join(', ')}.`;
  }

  const lines = [
    `## Advanced Spell Search`,
    `*Filters: ${filters.join(' | ')}*`,
    `*${matching.length} spells found*`,
    '',
  ];

  let count = 0;
  let currentLevel = -1;
  for (const s of matching) {
    if (count >= 150) {
      lines.push(`\n*... and ${matching.length - count} more*`);
      break;
    }
    if (classId && s.level !== currentLevel) {
      currentLevel = s.level;
      lines.push(`\n### Level ${currentLevel}`);
    }
    lines.push(`- **${s.name}** (${s.id}) — ${s.target} | ${s.resist}${s.category ? ` [${s.category}]` : ''}`);
    count++;
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS SPELL SUMMARY ============

export async function getClassSpellSummary(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const classIndex = classId - 1;

  // Collect stats
  const byCategory = new Map<string, number>();
  const byTarget = new Map<string, number>();
  const byTier = new Map<string, number>(); // "1-10", "11-20", etc.
  let totalSpells = 0;
  let beneficialCount = 0;
  let detrimentalCount = 0;
  let maxLevel = 0;

  for (const [, spell] of spells) {
    const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
    if (isNaN(classLevel) || classLevel === 255 || classLevel <= 0) continue;

    totalSpells++;
    if (classLevel > maxLevel) maxLevel = classLevel;

    // Beneficial/detrimental
    if (spell.fields[SF.BENEFICIAL] === '1') beneficialCount++;
    else detrimentalCount++;

    // Category
    let cat = 'Uncategorized';
    if (spellCategories) {
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      if (!isNaN(catId) && catId > 0) cat = spellCategories.get(catId) || 'Uncategorized';
    }
    byCategory.set(cat, (byCategory.get(cat) || 0) + 1);

    // Target
    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]);
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;
    byTarget.set(target, (byTarget.get(target) || 0) + 1);

    // Level tier
    const tier = `${Math.floor((classLevel - 1) / 10) * 10 + 1}-${Math.floor((classLevel - 1) / 10) * 10 + 10}`;
    byTier.set(tier, (byTier.get(tier) || 0) + 1);
  }

  const lines = [
    `## ${CLASS_IDS[classId]} — Spell Book Summary`,
    '',
    `**Total Spells:** ${totalSpells}`,
    `**Beneficial (Buffs):** ${beneficialCount}`,
    `**Detrimental (Debuffs):** ${detrimentalCount}`,
    `**Max Spell Level:** ${maxLevel}`,
    '',
  ];

  // Level tiers
  const sortedTiers = [...byTier.entries()].sort((a, b) => {
    const aNum = parseInt(a[0]);
    const bNum = parseInt(b[0]);
    return aNum - bNum;
  });
  lines.push('### Spells by Level Range');
  lines.push('| Level Range | Count |');
  lines.push('|-------------|-------|');
  for (const [tier, count] of sortedTiers) {
    lines.push(`| ${tier} | ${count} |`);
  }
  lines.push('');

  // Top categories
  const sortedCats = [...byCategory.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('### Top Spell Categories');
  lines.push('| Category | Count |');
  lines.push('|----------|-------|');
  for (const [cat, count] of sortedCats.slice(0, 25)) {
    lines.push(`| ${cat} | ${count} |`);
  }
  if (sortedCats.length > 25) {
    lines.push(`*...and ${sortedCats.length - 25} more categories*`);
  }
  lines.push('');

  // Target types
  const sortedTargets = [...byTarget.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('### By Target Type');
  lines.push('| Target | Count |');
  lines.push('|--------|-------|');
  for (const [target, count] of sortedTargets) {
    lines.push(`| ${target} | ${count} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: DEITY COMPARISON ============

export async function compareDeities(deity1: string, deity2: string): Promise<string> {
  await loadRaceClassInfo();
  await loadFactions(); // for faction data

  // Resolve deity names
  const allDeityNames = new Set<string>();
  for (const deities of Object.values(RACE_DEITIES)) {
    for (const d of deities) allDeityNames.add(d);
  }

  function findDeity(name: string): string | null {
    const lower = name.toLowerCase();
    for (const d of allDeityNames) {
      if (d.toLowerCase() === lower) return d;
    }
    for (const d of allDeityNames) {
      if (d.toLowerCase().includes(lower)) return d;
    }
    return null;
  }

  const name1 = findDeity(deity1);
  const name2 = findDeity(deity2);
  if (!name1) return `Unknown deity: "${deity1}". Valid: ${[...allDeityNames].sort().join(', ')}`;
  if (!name2) return `Unknown deity: "${deity2}". Valid: ${[...allDeityNames].sort().join(', ')}`;
  if (name1 === name2) return `Please specify two different deities to compare.`;

  // Find follower races
  const races1 = new Set<string>();
  const races2 = new Set<string>();
  for (const [raceId, deities] of Object.entries(RACE_DEITIES)) {
    const raceName = RACE_IDS[parseInt(raceId)];
    if (!raceName) continue;
    if (deities.includes(name1)) races1.add(raceName);
    if (deities.includes(name2)) races2.add(raceName);
  }

  const sharedRaces = [...races1].filter(r => races2.has(r));
  const uniqueRaces1 = [...races1].filter(r => !races2.has(r));
  const uniqueRaces2 = [...races2].filter(r => !races1.has(r));

  // Find available classes through races
  const classes1 = new Set<string>();
  const classes2 = new Set<string>();
  for (const [raceId, classIds] of Object.entries(RACE_CLASSES)) {
    const raceName = RACE_IDS[parseInt(raceId)];
    if (!raceName) continue;
    for (const cid of classIds) {
      if (races1.has(raceName)) classes1.add(CLASS_IDS[cid]);
      if (races2.has(raceName)) classes2.add(CLASS_IDS[cid]);
    }
  }

  const sharedClasses = [...classes1].filter(c => classes2.has(c));
  const uniqueClasses1 = [...classes1].filter(c => !classes2.has(c));
  const uniqueClasses2 = [...classes2].filter(c => !classes1.has(c));

  const lines = [
    `## Deity Comparison: ${name1} vs ${name2}`,
    '',
    '### Follower Races',
    `| | ${name1} | ${name2} |`,
    `|---|---|---|`,
    `| Total | ${races1.size} | ${races2.size} |`,
    `| Shared | ${sharedRaces.length} | ${sharedRaces.length} |`,
    '',
    `**Shared:** ${sharedRaces.join(', ') || 'None'}`,
    `**${name1} only:** ${uniqueRaces1.join(', ') || 'None'}`,
    `**${name2} only:** ${uniqueRaces2.join(', ') || 'None'}`,
    '',
    '### Available Classes (via follower races)',
    `| | ${name1} | ${name2} |`,
    `|---|---|---|`,
    `| Total | ${classes1.size} | ${classes2.size} |`,
    `| Shared | ${sharedClasses.length} | ${sharedClasses.length} |`,
    '',
    `**Shared:** ${sharedClasses.join(', ') || 'None'}`,
    `**${name1} only:** ${uniqueClasses1.join(', ') || 'None'}`,
    `**${name2} only:** ${uniqueClasses2.join(', ') || 'None'}`,
  ];

  // Lore descriptions
  if (deityDescriptions) {
    for (const [, desc] of deityDescriptions) {
      if (desc.toLowerCase().includes(name1.toLowerCase())) {
        lines.push('', `### ${name1} — Lore`, desc);
        break;
      }
    }
    for (const [, desc] of deityDescriptions) {
      if (desc.toLowerCase().includes(name2.toLowerCase())) {
        lines.push('', `### ${name2} — Lore`, desc);
        break;
      }
    }
  }

  return lines.join('\n');
}

// ============ DATA STATUS ============

export async function getLocalDataStatus(): Promise<string> {
  const available = isGameDataAvailable();
  const lines = [
    '## Local EverQuest Game Data',
    '',
    `**Game Path:** ${EQ_GAME_PATH}`,
    `**Data Available:** ${available ? 'Yes' : 'No'}`,
    '',
  ];

  if (!available) {
    lines.push('Set the `EQ_GAME_PATH` environment variable to your EQ installation directory.');
    return lines.join('\n');
  }

  // Report loaded data
  lines.push('### Loaded Data');
  lines.push(`- **Spells:** ${spells ? spells.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Spell Strings:** ${spellStrings ? spellStrings.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Spell Descriptions:** ${spellDescriptions ? spellDescriptions.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Zones:** ${zones ? zones.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Skill Caps:** ${skillCaps ? skillCaps.length.toLocaleString() + ' entries' : 'Not loaded'}`);
  lines.push(`- **Base Stats:** ${baseStats ? baseStats.length.toLocaleString() + ' entries' : 'Not loaded'}`);
  lines.push(`- **Achievements:** ${achievements ? achievements.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Factions:** ${factions ? factions.size.toLocaleString() : 'Not loaded'}${factionCategories ? ` (${factionCategories.size} expansion categories)` : ''}`);
  lines.push(`- **AA Abilities:** ${aaAbilities ? aaAbilities.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Spell Stacking:** ${spellStacking ? spellStacking.size.toLocaleString() + ' spells' : 'Not loaded'}`);
  lines.push(`- **Spell Group Names:** ${spellGroupNames ? spellGroupNames.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Bonus Descriptions:** ${bonusDescriptions ? bonusDescriptions.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Augment Groups:** ${augmentGroups ? augmentGroups.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **AC Mitigation:** ${acMitigation ? acMitigation.length.toLocaleString() + ' entries' : 'Not loaded'}`);
  lines.push(`- **Lore Stories:** ${loreEntries ? loreEntries.length.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Game Strings:** ${gameStrings ? gameStrings.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Overseer Minions:** ${overseerMinions ? overseerMinions.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Overseer Quests:** ${overseerQuests ? overseerQuests.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Overseer Incapacitations:** ${overseerIncapNames ? overseerIncapNames.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Achievement Categories:** ${achievementCategories ? achievementCategories.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Achievement Components:** ${achievementComponents ? achievementComponents.size.toLocaleString() + ' achievements' : 'Not loaded'}`);
  lines.push(`- **Combat Abilities:** ${combatAbilities ? combatAbilities.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Mercenaries:** ${mercenaries ? mercenaries.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Mercenary Stances:** ${mercenaryStances ? mercenaryStances.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Mercenary Abilities:** ${mercenaryAbilities ? mercenaryAbilities.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Race Descriptions:** ${raceDescriptions ? raceDescriptions.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Class Descriptions:** ${classDescriptions ? classDescriptions.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Deity Descriptions:** ${deityDescriptions ? deityDescriptions.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Alternate Currencies:** ${altCurrencies ? altCurrencies.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Tributes:** ${tributes ? tributes.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Item Effects:** ${itemEffectDescs ? itemEffectDescs.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Banner Categories:** ${bannerCategories ? bannerCategories.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Expansions:** ${expansionNames ? expansionNames.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Game Events:** ${gameEvents ? gameEvents.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Creature Types:** ${creatureTypes ? creatureTypes.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Starting City Lore:** ${startingCityLore ? startingCityLore.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Drakkin Heritages:** ${drakkinHeritages ? drakkinHeritages.length.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Overseer Archetypes:** ${overseerArchetypeNames ? overseerArchetypeNames.size.toLocaleString() : 'Not loaded'}`);
  lines.push(`- **Map Cache:** ${mapCache.size} zones loaded`);

  return lines.join('\n');
}

// ============ LISTING TOOLS ============

export async function listAllRaces(): Promise<string> {
  await loadRaceClassInfo();

  const lines = ['# All Playable Races (16)', ''];
  lines.push('| Race | Classes | Deities | Base Stats (STR/STA/AGI/DEX/WIS/INT/CHA) |');
  lines.push('|------|---------|---------|------------------------------------------|');

  for (const [raceId, raceName] of Object.entries(RACE_IDS)) {
    const id = parseInt(raceId);
    const classes = (RACE_CLASSES[id] || []).map(cid => CLASS_IDS[cid] || '?');
    const deities = RACE_DEITIES[id] || [];
    const stats = RACE_BASE_STATS[id] || [];
    const statStr = stats.join('/');

    lines.push(`| **${raceName}** | ${classes.join(', ')} | ${deities.length} | ${statStr} |`);
  }

  lines.push('');
  lines.push('## Race Details');
  lines.push('');

  for (const [raceId, raceName] of Object.entries(RACE_IDS)) {
    const id = parseInt(raceId);
    const desc = raceDescriptions?.get(id);
    const classes = (RACE_CLASSES[id] || []).map(cid => CLASS_IDS[cid] || '?');
    const deities = RACE_DEITIES[id] || [];
    const stats = RACE_BASE_STATS[id] || [];

    lines.push(`### ${raceName}`);
    if (desc?.short) lines.push(desc.short);
    lines.push(`- **Classes (${classes.length}):** ${classes.join(', ')}`);
    lines.push(`- **Deities (${deities.length}):** ${deities.join(', ')}`);
    lines.push(`- **Base Stats:** STR ${stats[0]}, STA ${stats[1]}, AGI ${stats[2]}, DEX ${stats[3]}, WIS ${stats[4]}, INT ${stats[5]}, CHA ${stats[6]}`);
    lines.push('');
  }

  return lines.join('\n');
}

export async function listAllClasses(): Promise<string> {
  await loadRaceClassInfo();
  await loadSpells();

  const lines = ['# All Classes (16)', ''];
  lines.push('| Class | Short | Races | Spells | Type |');
  lines.push('|-------|-------|-------|--------|------|');

  // Count spells per class
  const spellCounts: Record<number, number> = {};
  if (spells) {
    for (const spell of spells.values()) {
      for (let i = 0; i < 16; i++) {
        const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i]) || 255;
        if (level > 0 && level < 255) {
          const classId = i + 1;
          spellCounts[classId] = (spellCounts[classId] || 0) + 1;
        }
      }
    }
  }

  // Classify as melee/hybrid/caster
  const meleeClasses = new Set([1, 7, 9, 16]); // WAR, MNK, ROG, BER
  const hybridClasses = new Set([3, 4, 5, 8, 10, 15]); // PAL, RNG, SHD, BRD, SHM, BST
  const casterClasses = new Set([2, 6, 11, 12, 13, 14]); // CLR, DRU, NEC, WIZ, MAG, ENC

  for (const [classId, className] of Object.entries(CLASS_IDS)) {
    const id = parseInt(classId);
    const short = CLASS_SHORT[id] || '???';
    const races: string[] = [];
    for (const [raceId, raceClasses] of Object.entries(RACE_CLASSES)) {
      if (raceClasses.includes(id)) {
        races.push(RACE_IDS[parseInt(raceId)] || '?');
      }
    }
    const count = spellCounts[id] || 0;
    const type = meleeClasses.has(id) ? 'Melee' : hybridClasses.has(id) ? 'Hybrid' : casterClasses.has(id) ? 'Caster' : '?';

    lines.push(`| **${className}** | ${short} | ${races.length} | ${count.toLocaleString()} | ${type} |`);
  }

  lines.push('');
  lines.push('## Class Details');
  lines.push('');

  for (const [classId, className] of Object.entries(CLASS_IDS)) {
    const id = parseInt(classId);
    const desc = classDescriptions?.get(id);
    const races: string[] = [];
    for (const [raceId, raceClasses] of Object.entries(RACE_CLASSES)) {
      if (raceClasses.includes(id)) {
        races.push(RACE_IDS[parseInt(raceId)] || '?');
      }
    }
    const count = spellCounts[id] || 0;

    lines.push(`### ${className} (${CLASS_SHORT[id]})`);
    if (desc?.short) lines.push(desc.short);
    lines.push(`- **Races (${races.length}):** ${races.join(', ')}`);
    lines.push(`- **Spells:** ${count.toLocaleString()}`);
    lines.push('');
  }

  return lines.join('\n');
}

export async function listAllDeities(): Promise<string> {
  await loadRaceClassInfo();

  const lines = ['# All EverQuest Deities', ''];

  // Collect unique deity names from all races
  const allDeities = new Set<string>();
  for (const deityList of Object.values(RACE_DEITIES)) {
    for (const d of deityList) allDeities.add(d);
  }

  // Sort alphabetically but put Agnostic first
  const sorted = Array.from(allDeities).sort((a, b) => {
    if (a === 'Agnostic') return -1;
    if (b === 'Agnostic') return 1;
    return a.localeCompare(b);
  });

  lines.push(`| Deity | Follower Races | Classes Available |`);
  lines.push(`|-------|---------------|-------------------|`);

  for (const deity of sorted) {
    const followerRaces: string[] = [];
    for (const [raceId, deities] of Object.entries(RACE_DEITIES)) {
      if (deities.includes(deity)) {
        followerRaces.push(RACE_IDS[parseInt(raceId)] || '?');
      }
    }
    // Derive unique classes from follower races
    const classSet = new Set<number>();
    for (const [raceId, deities] of Object.entries(RACE_DEITIES)) {
      if (deities.includes(deity)) {
        const raceClasses = RACE_CLASSES[parseInt(raceId)] || [];
        for (const c of raceClasses) classSet.add(c);
      }
    }

    lines.push(`| **${deity}** | ${followerRaces.join(', ')} | ${classSet.size} |`);
  }

  lines.push('');
  lines.push('## Deity Details');
  lines.push('');

  for (const deity of sorted) {
    const followerRaces: string[] = [];
    for (const [raceId, deities] of Object.entries(RACE_DEITIES)) {
      if (deities.includes(deity)) {
        followerRaces.push(RACE_IDS[parseInt(raceId)] || '?');
      }
    }
    const classSet = new Set<number>();
    for (const [raceId, deities] of Object.entries(RACE_DEITIES)) {
      if (deities.includes(deity)) {
        const raceClasses = RACE_CLASSES[parseInt(raceId)] || [];
        for (const c of raceClasses) classSet.add(c);
      }
    }
    const classNames = Array.from(classSet).sort((a, b) => a - b).map(c => CLASS_IDS[c] || '?');

    // Get deity lore from deityDescriptions (match by text content like getDeityInfo)
    let lore = '';
    if (deityDescriptions) {
      for (const [, desc] of deityDescriptions) {
        if (desc.toLowerCase().includes(deity.toLowerCase())) {
          lore = desc;
          break;
        }
      }
    }

    lines.push(`### ${deity}`);
    if (lore) lines.push(lore);
    lines.push(`- **Follower Races (${followerRaces.length}):** ${followerRaces.join(', ')}`);
    lines.push(`- **Available Classes (${classNames.length}):** ${classNames.join(', ')}`);
    lines.push('');
  }

  return lines.join('\n');
}

// ============ AUGMENT SLOT TYPES ============

export async function listAugmentSlotTypes(): Promise<string> {
  await loadDbStrings([DBSTR_TYPES.AUGMENT_SLOT_TYPE]);
  const slotTypes = dbStrings?.get(DBSTR_TYPES.AUGMENT_SLOT_TYPE) || new Map();

  if (slotTypes.size === 0) return 'Augment slot type data not available.';

  const lines = [`# Augmentation Slot Types (${slotTypes.size})`, ''];
  lines.push('| ID | Slot Type |');
  lines.push('|----|-----------|');

  const sorted = Array.from(slotTypes.entries()).sort((a, b) => a[0] - b[0]);
  for (const [id, name] of sorted) {
    lines.push(`| ${id} | ${name} |`);
  }

  return lines.join('\n');
}

// ============ ITEM LORE GROUPS ============

export async function searchItemLoreGroups(query?: string): Promise<string> {
  await loadDbStrings([DBSTR_TYPES.ITEM_LORE_GROUP]);
  const loreGroups = dbStrings?.get(DBSTR_TYPES.ITEM_LORE_GROUP) || new Map();

  if (loreGroups.size === 0) return 'Item lore group data not available.';

  const lines: string[] = [];

  if (!query) {
    lines.push(`# Item Lore Groups (${loreGroups.size})`, '');
    lines.push('Item lore groups define which items are considered "LORE" duplicates — you can only carry one item from each lore group. Use a search query to filter.', '');
    lines.push('| ID | Lore Group |');
    lines.push('|----|------------|');
    const sorted = Array.from(loreGroups.entries()).sort((a, b) => a[0] - b[0]);
    for (const [id, name] of sorted.slice(0, 50)) {
      lines.push(`| ${id} | ${name} |`);
    }
    if (sorted.length > 50) {
      lines.push('', `*Showing first 50 of ${sorted.length}. Use a search query to filter.*`);
    }
  } else {
    const lowerQuery = query.toLowerCase();
    const matches: [number, string][] = [];
    for (const [id, name] of loreGroups) {
      if (name.toLowerCase().includes(lowerQuery)) {
        matches.push([id, name]);
      }
    }

    if (matches.length === 0) {
      return `No item lore groups matching "${query}".`;
    }

    lines.push(`# Item Lore Groups matching "${query}" (${matches.length})`, '');
    lines.push('| ID | Lore Group |');
    lines.push('|----|------------|');
    matches.sort((a, b) => a[1].localeCompare(b[1]));
    for (const [id, name] of matches) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  return lines.join('\n');
}

// ============ CLASS ABILITIES AT LEVEL ============

export async function getClassAbilitiesAtLevel(className: string, level: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  // Find spells at this exact level
  const spellsAtLevel: { name: string; category: string; beneficial: boolean; targetType: string }[] = [];

  for (const spell of spells.values()) {
    const spellLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (spellLevel !== level) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const targetTypeId = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const targetType = TARGET_TYPES[targetTypeId] || 'Unknown';

    spellsAtLevel.push({ name, category, beneficial, targetType });
  }

  const lines = [`# ${classFullName} — Level ${level} Spells`, ''];

  if (spellsAtLevel.length === 0) {
    lines.push(`No spells available at exactly level ${level} for ${classFullName}.`);
    return lines.join('\n');
  }

  lines.push(`**${spellsAtLevel.length} spells obtained at level ${level}:**`, '');

  // Group by category
  const byCategory: Record<string, typeof spellsAtLevel> = {};
  for (const s of spellsAtLevel) {
    if (!byCategory[s.category]) byCategory[s.category] = [];
    byCategory[s.category].push(s);
  }

  const sortedCategories = Object.keys(byCategory).sort();
  for (const cat of sortedCategories) {
    const catSpells = byCategory[cat];
    lines.push(`### ${cat} (${catSpells.length})`);
    for (const s of catSpells.sort((a, b) => a.name.localeCompare(b.name))) {
      const type = s.beneficial ? 'buff' : 'debuff';
      lines.push(`- ${s.name} (${type}, ${s.targetType})`);
    }
    lines.push('');
  }

  // Summary
  const buffCount = spellsAtLevel.filter(s => s.beneficial).length;
  const debuffCount = spellsAtLevel.length - buffCount;
  lines.push(`**Summary:** ${buffCount} buffs, ${debuffCount} debuffs across ${sortedCategories.length} categories`);

  return lines.join('\n');
}

// ============ SPELL EFFECT TYPES REFERENCE ============

export function listSpellEffectTypes(): string {
  const lines = [`# Spell Effect Types (SPA) — ${Object.keys(SPA_NAMES).length} types`, ''];
  lines.push('Use these effect names with `search_spells_by_effect` to find spells by their effect type.', '');
  lines.push('| SPA ID | Effect Name |');
  lines.push('|--------|-------------|');

  // Filter out "Limit:" types which are focus/AA modifiers, not direct spell effects
  const directEffects: [number, string][] = [];
  const limitEffects: [number, string][] = [];

  for (const [id, name] of Object.entries(SPA_NAMES)) {
    if (name.startsWith('Limit:')) {
      limitEffects.push([parseInt(id), name]);
    } else {
      directEffects.push([parseInt(id), name]);
    }
  }

  lines.push('### Direct Spell Effects');
  lines.push('');
  for (const [id, name] of directEffects.sort((a, b) => a[0] - b[0])) {
    lines.push(`| ${id} | ${name} |`);
  }

  lines.push('');
  lines.push(`### Focus/AA Limit Effects (${limitEffects.length})`);
  lines.push('These are used in focus effects and AA abilities to restrict which spells they apply to.');
  lines.push('');
  for (const [id, name] of limitEffects.sort((a, b) => a[0] - b[0])) {
    lines.push(`| ${id} | ${name} |`);
  }

  return lines.join('\n');
}

// ============ CAST TIME SEARCH ============

export async function searchSpellsByCastTime(className: string, maxCastMs?: number, minCastMs?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; castTime: number; category: string; beneficial: boolean }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0; // in milliseconds
    if (maxCastMs !== undefined && castTime > maxCastMs) continue;
    if (minCastMs !== undefined && castTime < minCastMs) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    matches.push({ name, level, castTime, category, beneficial });
  }

  if (matches.length === 0) {
    const range = maxCastMs !== undefined && minCastMs !== undefined
      ? `${minCastMs}-${maxCastMs}ms`
      : maxCastMs !== undefined ? `≤${maxCastMs}ms` : `≥${minCastMs}ms`;
    return `No ${classFullName} spells with cast time ${range}.`;
  }

  // Sort by cast time, then level
  matches.sort((a, b) => a.castTime - b.castTime || a.level - b.level);

  const rangeDesc = maxCastMs !== undefined && minCastMs !== undefined
    ? `${minCastMs}-${maxCastMs}ms`
    : maxCastMs !== undefined ? `≤${maxCastMs}ms` : minCastMs !== undefined ? `≥${minCastMs}ms` : 'all';

  const lines = [`# ${classFullName} Spells — Cast Time ${rangeDesc}`, ''];
  lines.push(`**${matches.length} spells found**`, '');

  // Cap output at 100
  const shown = matches.slice(0, 100);
  lines.push('| Cast Time | Level | Spell | Category | Type |');
  lines.push('|-----------|-------|-------|----------|------|');

  for (const s of shown) {
    const timeStr = s.castTime === 0 ? 'Instant' : `${(s.castTime / 1000).toFixed(1)}s`;
    const type = s.beneficial ? 'Buff' : 'Debuff';
    lines.push(`| ${timeStr} | ${s.level} | ${s.name} | ${s.category} | ${type} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow your search with level or cast time filters.*`);
  }

  return lines.join('\n');
}

// ============ RACE-CLASS MATRIX ============

export function getRaceClassMatrix(): string {
  const lines = ['# Race-Class Availability Matrix', ''];

  // Build header: Race | WAR | CLR | PAL | ...
  const classIds = Object.keys(CLASS_IDS).map(Number).sort((a, b) => a - b);
  const header = ['Race', ...classIds.map(id => CLASS_SHORT[id])];
  lines.push('| ' + header.join(' | ') + ' |');
  lines.push('|' + header.map(() => '---').join('|') + '|');

  for (const [raceId, raceName] of Object.entries(RACE_IDS)) {
    const id = parseInt(raceId);
    const raceClasses = RACE_CLASSES[id] || [];
    const cells = classIds.map(cid => raceClasses.includes(cid) ? 'X' : '-');
    lines.push(`| **${raceName}** | ${cells.join(' | ')} |`);
  }

  lines.push('');

  // Summary: count per class
  lines.push('### Races per Class');
  lines.push('');
  for (const cid of classIds) {
    let count = 0;
    for (const raceClasses of Object.values(RACE_CLASSES)) {
      if (raceClasses.includes(cid)) count++;
    }
    lines.push(`- **${CLASS_IDS[cid]}** (${CLASS_SHORT[cid]}): ${count} races`);
  }

  lines.push('');
  lines.push('### Classes per Race');
  lines.push('');
  for (const [raceId, raceName] of Object.entries(RACE_IDS)) {
    const count = (RACE_CLASSES[parseInt(raceId)] || []).length;
    lines.push(`- **${raceName}**: ${count} classes`);
  }

  return lines.join('\n');
}

// ============ LEVELING ZONES GUIDE ============

export async function getLevelingZonesGuide(): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const lines = ['# EverQuest Leveling Zones Guide', ''];

  // Define level tiers matching EQ's progression
  const tiers = [
    { label: '1-20', min: 1, max: 20 },
    { label: '21-40', min: 21, max: 40 },
    { label: '41-60', min: 41, max: 60 },
    { label: '61-80', min: 61, max: 80 },
    { label: '81-100', min: 81, max: 100 },
    { label: '101-120', min: 101, max: 120 },
    { label: '121+', min: 121, max: 999 },
  ];

  const tierZones: Record<string, { name: string; min: number; max: number }[]> = {};
  for (const tier of tiers) tierZones[tier.label] = [];
  const noLevel: { name: string }[] = [];

  for (const zone of zones.values()) {
    if (zone.levelMin <= 0 && zone.levelMax <= 0) {
      noLevel.push({ name: zone.name });
      continue;
    }

    const effectiveMax = zone.levelMax > 0 ? zone.levelMax : zone.levelMin;
    const effectiveMin = zone.levelMin > 0 ? zone.levelMin : 1;

    // Add zone to all tiers it overlaps with
    for (const tier of tiers) {
      if (effectiveMin <= tier.max && effectiveMax >= tier.min) {
        tierZones[tier.label].push({ name: zone.name, min: effectiveMin, max: effectiveMax });
      }
    }
  }

  const leveled = zones.size - noLevel.length;
  lines.push(`**${zones.size} total zones** (${leveled} with level data, ${noLevel.length} unleveled)`, '');

  for (const tier of tiers) {
    const zoneList = tierZones[tier.label];
    if (zoneList.length === 0) continue;
    zoneList.sort((a, b) => a.min - b.min || a.max - b.max);

    lines.push(`### Level ${tier.label} (${zoneList.length} zones)`);
    for (const z of zoneList) {
      const range = z.max > z.min ? `${z.min}-${z.max}` : `${z.min}+`;
      lines.push(`- **${z.name}** (${range})`);
    }
    lines.push('');
  }

  if (noLevel.length > 0) {
    lines.push(`### Unleveled Zones (${noLevel.length})`);
    lines.push('Classic zones, instances, and special areas without level ranges:');
    for (const z of noLevel.sort((a, b) => a.name.localeCompare(b.name)).slice(0, 50)) {
      lines.push(`- ${z.name}`);
    }
    if (noLevel.length > 50) {
      lines.push(`*...and ${noLevel.length - 50} more*`);
    }
  }

  return lines.join('\n');
}

// ============ OVERSEER QUEST SUMMARY ============

export async function getOverseerQuestSummary(): Promise<string> {
  await loadOverseerMinions();
  await loadOverseerQuests();
  await loadOverseerEnhancements();

  if (!overseerQuests || overseerQuests.size === 0) return 'Overseer quest data not available.';

  const lines = ['# Overseer System Summary', ''];

  // Quest stats by category
  const byCategory: Record<string, number> = {};
  const byDifficulty: Record<string, number> = {};
  const byDuration: Record<number, number> = {};
  let totalSlots = 0;

  for (const quest of overseerQuests.values()) {
    const cat = overseerCategories?.get(quest.categoryId) || `Category ${quest.categoryId}`;
    byCategory[cat] = (byCategory[cat] || 0) + 1;

    const diff = overseerDifficulties?.get(quest.difficulty) || `Difficulty ${quest.difficulty}`;
    byDifficulty[diff] = (byDifficulty[diff] || 0) + 1;

    byDuration[quest.duration] = (byDuration[quest.duration] || 0) + 1;
    totalSlots += quest.requiredSlots + quest.optionalSlots;
  }

  lines.push(`**${overseerQuests.size} total quests**, ${Math.round(totalSlots / overseerQuests.size * 10) / 10} avg slots per quest`, '');

  // Categories
  lines.push('### Quest Categories');
  lines.push('| Category | Quests |');
  lines.push('|----------|--------|');
  for (const [cat, count] of Object.entries(byCategory).sort((a, b) => b[1] - a[1])) {
    lines.push(`| ${cat} | ${count} |`);
  }
  lines.push('');

  // Difficulties
  lines.push('### Quest Difficulties');
  lines.push('| Difficulty | Quests |');
  lines.push('|-----------|--------|');
  for (const [diff, count] of Object.entries(byDifficulty).sort((a, b) => b[1] - a[1])) {
    lines.push(`| ${diff} | ${count} |`);
  }
  lines.push('');

  // Durations (duration field is in hours)
  lines.push('### Quest Durations');
  lines.push('| Duration | Quests |');
  lines.push('|----------|--------|');
  for (const [dur, count] of Object.entries(byDuration).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    const hours = parseInt(dur);
    lines.push(`| ${hours}h | ${count} |`);
  }
  lines.push('');

  // Agent stats
  if (overseerMinions && overseerMinions.size > 0) {
    lines.push('### Agent Statistics');
    const byRarity: Record<string, number> = {};
    const byJob: Record<string, number> = {};
    for (const minion of overseerMinions.values()) {
      const rarityName = OVERSEER_RARITIES[minion.rarity] || `Rarity ${minion.rarity}`;
      byRarity[rarityName] = (byRarity[rarityName] || 0) + 1;
      for (const job of minion.jobs) {
        const jobName = overseerJobNames?.get(job.jobTypeId) || `Job ${job.jobTypeId}`;
        byJob[jobName] = (byJob[jobName] || 0) + 1;
      }
    }
    lines.push(`**${overseerMinions.size} total agents**`, '');

    lines.push('| Rarity | Agents |');
    lines.push('|--------|--------|');
    for (const [rarity, count] of Object.entries(byRarity).sort()) {
      lines.push(`| ${rarity} | ${count} |`);
    }
    lines.push('');

    lines.push('| Job Type | Agents with Job |');
    lines.push('|----------|----------------|');
    for (const [job, count] of Object.entries(byJob).sort((a, b) => b[1] - a[1])) {
      lines.push(`| ${job} | ${count} |`);
    }
  }

  return lines.join('\n');
}

// ============ MERCENARY OVERVIEW ============

export async function getMercenaryOverview(): Promise<string> {
  await loadMercenaries();
  await loadMercenaryStances();

  if (!mercenaries || mercenaries.size === 0) return 'Mercenary data not available.';

  const lines = ['# Mercenary Overview', ''];

  // Group by type
  const byType: Record<string, MercenaryEntry[]> = {};
  const byTier: Record<string, number> = {};
  const byRace: Record<string, number> = {};

  for (const merc of mercenaries.values()) {
    const type = merc.type || 'Unknown';
    if (!byType[type]) byType[type] = [];
    byType[type].push(merc);

    byTier[merc.tier] = (byTier[merc.tier] || 0) + 1;
    if (merc.race) {
      byRace[merc.race] = (byRace[merc.race] || 0) + 1;
    }
  }

  lines.push(`**${mercenaries.size} mercenary templates** across ${Object.keys(byType).length} types`, '');

  // Types
  lines.push('### Mercenary Types');
  lines.push('| Type | Count |');
  lines.push('|------|-------|');
  for (const [type, mercs] of Object.entries(byType).sort((a, b) => b[1].length - a[1].length)) {
    lines.push(`| ${type} | ${mercs.length} |`);
  }
  lines.push('');

  // Tiers
  lines.push('### Mercenary Tiers');
  lines.push('| Tier | Count |');
  lines.push('|------|-------|');
  for (const [tier, count] of Object.entries(byTier).sort()) {
    lines.push(`| ${tier} | ${count} |`);
  }
  lines.push('');

  // Races
  if (Object.keys(byRace).length > 0) {
    lines.push('### Mercenary Races');
    lines.push('| Race | Count |');
    lines.push('|------|-------|');
    for (const [race, count] of Object.entries(byRace).sort((a, b) => b[1] - a[1]).slice(0, 20)) {
      lines.push(`| ${race} | ${count} |`);
    }
    lines.push('');
  }

  // Stances
  if (mercenaryStances && mercenaryStances.size > 0) {
    lines.push('### Available Stances');
    for (const [, stance] of mercenaryStances) {
      lines.push(`- **${stance.name}** (${stance.shortDesc}): ${stance.description || 'No description'}`);
    }
  }

  return lines.join('\n');
}

// ============ SPELL RECAST TIME SEARCH ============

export async function searchSpellsByRecastTime(className: string, maxRecastSec?: number, minRecastSec?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; recastTime: number; category: string; timerId: number }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const recastTime = parseInt(spell.fields[SF.RECAST_TIME]) || 0; // in milliseconds
    const recastSec = recastTime / 1000;
    if (maxRecastSec !== undefined && recastSec > maxRecastSec) continue;
    if (minRecastSec !== undefined && recastSec < minRecastSec) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const timerId = parseInt(spell.fields[SF.TIMER_ID]) || 0;

    matches.push({ name, level, recastTime: recastSec, category, timerId });
  }

  if (matches.length === 0) {
    const range = maxRecastSec !== undefined && minRecastSec !== undefined
      ? `${minRecastSec}-${maxRecastSec}s`
      : maxRecastSec !== undefined ? `≤${maxRecastSec}s` : `≥${minRecastSec}s`;
    return `No ${classFullName} spells with recast time ${range}.`;
  }

  matches.sort((a, b) => b.recastTime - a.recastTime || a.level - b.level);

  const rangeDesc = maxRecastSec !== undefined && minRecastSec !== undefined
    ? `${minRecastSec}-${maxRecastSec}s`
    : maxRecastSec !== undefined ? `≤${maxRecastSec}s` : minRecastSec !== undefined ? `≥${minRecastSec}s` : 'all';

  const lines = [`# ${classFullName} Spells — Recast Time ${rangeDesc}`, ''];
  lines.push(`**${matches.length} spells found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Recast | Level | Spell | Category | Timer Group |');
  lines.push('|--------|-------|-------|----------|------------|');

  for (const s of shown) {
    let timeStr: string;
    if (s.recastTime === 0) timeStr = 'None';
    else if (s.recastTime < 60) timeStr = `${s.recastTime}s`;
    else if (s.recastTime < 3600) timeStr = `${Math.floor(s.recastTime / 60)}m ${s.recastTime % 60 > 0 ? Math.round(s.recastTime % 60) + 's' : ''}`.trim();
    else timeStr = `${Math.floor(s.recastTime / 3600)}h ${Math.floor((s.recastTime % 3600) / 60)}m`;

    const timerStr = s.timerId > 0 ? `Group ${s.timerId}` : '-';
    lines.push(`| ${timeStr} | ${s.level} | ${s.name} | ${s.category} | ${timerStr} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow with recast time filters.*`);
  }

  return lines.join('\n');
}

// ============ CHARACTER CREATION GUIDE ============

export async function getCharacterCreationGuide(role?: string): Promise<string> {
  await loadRaceClassInfo();
  await loadSpells();

  const lines = ['# EverQuest Character Creation Guide', ''];

  // Define roles
  const roles: Record<string, { classes: number[]; description: string }> = {
    'tank': {
      classes: [1, 3, 5],
      description: 'Tanks absorb damage and hold aggro, protecting the group. Warrior is the premier tank, Paladin adds healing, Shadow Knight adds damage/utility.'
    },
    'healer': {
      classes: [2, 6, 10],
      description: 'Healers keep the group alive. Cleric is the strongest single-target healer, Druid adds versatility, Shaman adds buffs/debuffs.'
    },
    'melee dps': {
      classes: [7, 9, 16, 4, 8, 15],
      description: 'Melee DPS deal physical damage up close. Monk and Rogue are pure DPS, Berserker is AoE-focused, Ranger/Bard/Beastlord are hybrid DPS.'
    },
    'caster dps': {
      classes: [12, 13, 11],
      description: 'Caster DPS deal magic damage from range. Wizard has highest burst, Magician has pets and sustained damage, Necromancer has DoTs and pets.'
    },
    'crowd control': {
      classes: [14, 8],
      description: 'CC classes control enemies through mesmerize, charm, and debuffs. Enchanter is the CC specialist, Bard provides AoE mezz and group utility.'
    },
    'utility': {
      classes: [8, 14, 10, 6],
      description: 'Utility classes provide group-wide benefits: buffs, debuffs, mana regen, travel, and versatility. Bard, Enchanter, Shaman, and Druid are top utility.'
    },
  };

  if (role) {
    const lowerRole = role.toLowerCase();
    const matched = Object.entries(roles).find(([key]) => key.includes(lowerRole) || lowerRole.includes(key));

    if (!matched) {
      lines.push(`Unknown role: "${role}". Available roles: ${Object.keys(roles).join(', ')}`);
      return lines.join('\n');
    }

    const [roleName, roleData] = matched;
    lines.push(`## ${roleName.charAt(0).toUpperCase() + roleName.slice(1)} Classes`, '');
    lines.push(roleData.description, '');

    for (const classId of roleData.classes) {
      const className = CLASS_IDS[classId];
      const desc = classDescriptions?.get(classId);
      const races: string[] = [];
      for (const [raceId, raceClasses] of Object.entries(RACE_CLASSES)) {
        if (raceClasses.includes(classId)) {
          races.push(RACE_IDS[parseInt(raceId)] || '?');
        }
      }

      lines.push(`### ${className} (${CLASS_SHORT[classId]})`);
      if (desc?.short) lines.push(desc.short);
      lines.push(`- **Available Races:** ${races.join(', ')}`);
      lines.push('');
    }
  } else {
    // Show all roles overview
    lines.push('## Roles Overview', '');

    for (const [roleName, roleData] of Object.entries(roles)) {
      const classNames = roleData.classes.map(id => `${CLASS_IDS[id]} (${CLASS_SHORT[id]})`);
      lines.push(`### ${roleName.charAt(0).toUpperCase() + roleName.slice(1)}`);
      lines.push(roleData.description);
      lines.push(`**Classes:** ${classNames.join(', ')}`, '');
    }

    lines.push('## Quick Reference', '');
    lines.push('| Class | Role | Type | Races |');
    lines.push('|-------|------|------|-------|');

    const classRoles: Record<number, string> = {
      1: 'Tank', 2: 'Healer', 3: 'Tank/Healer', 4: 'Melee DPS',
      5: 'Tank/DPS', 6: 'Healer/Utility', 7: 'Melee DPS', 8: 'Utility/CC',
      9: 'Melee DPS', 10: 'Healer/Utility', 11: 'Caster DPS', 12: 'Caster DPS',
      13: 'Caster DPS', 14: 'CC/Utility', 15: 'Melee DPS', 16: 'Melee DPS',
    };

    const meleeClasses = new Set([1, 7, 9, 16]);
    const hybridClasses = new Set([3, 4, 5, 8, 10, 15]);

    for (const [classId, className] of Object.entries(CLASS_IDS)) {
      const id = parseInt(classId);
      const role = classRoles[id] || '?';
      const type = meleeClasses.has(id) ? 'Melee' : hybridClasses.has(id) ? 'Hybrid' : 'Caster';
      let raceCount = 0;
      for (const raceClasses of Object.values(RACE_CLASSES)) {
        if (raceClasses.includes(id)) raceCount++;
      }
      lines.push(`| ${className} | ${role} | ${type} | ${raceCount} races |`);
    }
  }

  return lines.join('\n');
}

// ============ SPELL RANGE SEARCH ============

export async function searchSpellsByRange(className: string, maxRange?: number, minRange?: number, aeOnly?: boolean): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; range: number; aeRange: number; category: string; target: string; beneficial: boolean }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const range = parseInt(spell.fields[SF.RANGE]) || 0;
    const aeRange = parseInt(spell.fields[SF.AE_RANGE]) || 0;
    const searchRange = aeOnly ? aeRange : range;

    if (maxRange !== undefined && searchRange > maxRange) continue;
    if (minRange !== undefined && searchRange < minRange) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    matches.push({ name, level, range, aeRange, category, target, beneficial });
  }

  if (matches.length === 0) {
    const rangeType = aeOnly ? 'AE range' : 'range';
    const rangeDesc = maxRange !== undefined && minRange !== undefined
      ? `${minRange}-${maxRange}`
      : maxRange !== undefined ? `≤${maxRange}` : `≥${minRange}`;
    return `No ${classFullName} spells with ${rangeType} ${rangeDesc}.`;
  }

  const sortField = aeOnly ? 'aeRange' : 'range';
  matches.sort((a, b) => {
    const valA = aeOnly ? a.aeRange : a.range;
    const valB = aeOnly ? b.aeRange : b.range;
    return valB - valA || a.level - b.level;
  });

  const rangeType = aeOnly ? 'AE Range' : 'Range';
  const rangeDesc = maxRange !== undefined && minRange !== undefined
    ? `${minRange}-${maxRange}`
    : maxRange !== undefined ? `≤${maxRange}` : minRange !== undefined ? `≥${minRange}` : 'all';

  const lines = [`# ${classFullName} Spells — ${rangeType} ${rangeDesc}`, ''];
  lines.push(`**${matches.length} spells found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Range | AE Range | Level | Spell | Target | Category |');
  lines.push('|-------|----------|-------|-------|--------|----------|');

  for (const s of shown) {
    lines.push(`| ${s.range} | ${s.aeRange} | ${s.level} | ${s.name} | ${s.target} | ${s.category} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow your search.*`);
  }

  return lines.join('\n');
}

// ============ SPELL MANA COST SEARCH ============

export async function searchSpellsByManaCost(className: string, maxMana?: number, minMana?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; mana: number; endurance: number; category: string; beneficial: boolean; castTime: number }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const mana = parseInt(spell.fields[SF.MANA]) || 0;
    const endurance = parseInt(spell.fields[SF.ENDURANCE]) || 0;
    const cost = mana > 0 ? mana : endurance;

    if (maxMana !== undefined && cost > maxMana) continue;
    if (minMana !== undefined && cost < minMana) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0;

    matches.push({ name, level, mana, endurance, category, beneficial, castTime });
  }

  if (matches.length === 0) {
    const rangeDesc = maxMana !== undefined && minMana !== undefined
      ? `${minMana}-${maxMana}`
      : maxMana !== undefined ? `≤${maxMana}` : `≥${minMana}`;
    return `No ${classFullName} spells with mana/endurance cost ${rangeDesc}.`;
  }

  matches.sort((a, b) => {
    const costA = a.mana > 0 ? a.mana : a.endurance;
    const costB = b.mana > 0 ? b.mana : b.endurance;
    return costB - costA || a.level - b.level;
  });

  const rangeDesc = maxMana !== undefined && minMana !== undefined
    ? `${minMana}-${maxMana}`
    : maxMana !== undefined ? `≤${maxMana}` : minMana !== undefined ? `≥${minMana}` : 'all';

  const lines = [`# ${classFullName} Spells — Mana/Endurance Cost ${rangeDesc}`, ''];
  lines.push(`**${matches.length} spells found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Cost | Type | Level | Spell | Category | Cast Time |');
  lines.push('|------|------|-------|-------|----------|-----------|');

  for (const s of shown) {
    const costType = s.mana > 0 ? 'Mana' : s.endurance > 0 ? 'End' : 'Free';
    const costVal = s.mana > 0 ? s.mana : s.endurance > 0 ? s.endurance : 0;
    const castStr = s.castTime === 0 ? 'Instant' : `${(s.castTime / 1000).toFixed(1)}s`;
    lines.push(`| ${costVal} | ${costType} | ${s.level} | ${s.name} | ${s.category} | ${castStr} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow your search.*`);
  }

  return lines.join('\n');
}

// ============ SPELL DURATION SEARCH ============

export async function searchSpellsByDuration(className: string, maxDurationSec?: number, minDurationSec?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; durationSec: number; durationStr: string; category: string; beneficial: boolean; target: string }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const durationFormula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const durationValue = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    const ticks = calculateDurationTicks(durationFormula, durationValue);
    if (ticks <= 0) continue;
    const durationSec = ticks * 6;

    if (maxDurationSec !== undefined && durationSec > maxDurationSec) continue;
    if (minDurationSec !== undefined && durationSec < minDurationSec) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;
    const durationStr = formatDuration(durationFormula, durationValue);

    matches.push({ name, level, durationSec, durationStr, category, beneficial, target });
  }

  if (matches.length === 0) {
    const rangeDesc = maxDurationSec !== undefined && minDurationSec !== undefined
      ? `${minDurationSec}-${maxDurationSec}s`
      : maxDurationSec !== undefined ? `≤${maxDurationSec}s` : `≥${minDurationSec}s`;
    return `No ${classFullName} spells with duration ${rangeDesc}.`;
  }

  matches.sort((a, b) => b.durationSec - a.durationSec || a.level - b.level);

  const rangeDesc = maxDurationSec !== undefined && minDurationSec !== undefined
    ? `${minDurationSec}-${maxDurationSec}s`
    : maxDurationSec !== undefined ? `≤${maxDurationSec}s` : minDurationSec !== undefined ? `≥${minDurationSec}s` : 'all';

  const lines = [`# ${classFullName} Spells — Duration ${rangeDesc}`, ''];
  lines.push(`**${matches.length} spells found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Duration | Level | Spell | Target | Category | Type |');
  lines.push('|----------|-------|-------|--------|----------|------|');

  for (const s of shown) {
    const type = s.beneficial ? 'Buff' : 'Debuff';
    lines.push(`| ${s.durationStr} | ${s.level} | ${s.name} | ${s.target} | ${s.category} | ${type} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow your search.*`);
  }

  return lines.join('\n');
}

// ============ FACTION OVERVIEW ============

export async function getFactionOverview(): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# EverQuest Faction System Overview', ''];

  // Count by category/expansion
  const byCat = new Map<string, number>();
  let uncategorized = 0;
  for (const faction of factions.values()) {
    if (faction.category) {
      byCat.set(faction.category, (byCat.get(faction.category) || 0) + 1);
    } else {
      uncategorized++;
    }
  }

  lines.push(`**${factions.size.toLocaleString()} total factions** across ${byCat.size} expansion categories`, '');

  // Sorted by count descending
  const sortedCats = [...byCat.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('## Factions by Expansion/Category', '');
  lines.push('| Category | Factions |');
  lines.push('|----------|----------|');
  for (const [cat, count] of sortedCats) {
    lines.push(`| ${cat} | ${count} |`);
  }
  if (uncategorized > 0) {
    lines.push(`| *(Uncategorized)* | ${uncategorized} |`);
  }

  // Faction value ranges
  lines.push('', '## Faction Value Ranges', '');
  const ranges = { standard: 0, wide: 0, narrow: 0 };
  for (const faction of factions.values()) {
    const range = faction.maxValue - faction.minValue;
    if (range >= 3000) ranges.wide++;
    else if (range >= 1000) ranges.standard++;
    else ranges.narrow++;
  }
  lines.push(`- **Wide range (3000+):** ${ranges.wide} factions`);
  lines.push(`- **Standard range (1000-2999):** ${ranges.standard} factions`);
  lines.push(`- **Narrow range (<1000):** ${ranges.narrow} factions`);

  // Factions with starting values
  let withStarting = 0;
  let totalModifiers = 0;
  for (const faction of factions.values()) {
    if (faction.startingValues && faction.startingValues.length > 0) {
      withStarting++;
      totalModifiers += faction.startingValues.length;
    }
  }
  lines.push('', '## Starting Faction Values', '');
  lines.push(`- **${withStarting}** factions have race/class/deity starting modifiers`);
  lines.push(`- **${totalModifiers.toLocaleString()}** total modifiers across all factions`);

  return lines.join('\n');
}

// ============ SPELL PUSHBACK SEARCH ============

export async function searchSpellsByPushback(className: string, minPushback?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; pushBack: number; pushUp: number; category: string; target: string; range: number }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const pushBack = parseFloat(spell.fields[SF.PUSH_BACK]) || 0;
    const pushUp = parseFloat(spell.fields[SF.PUSH_UP]) || 0;
    if (pushBack === 0 && pushUp === 0) continue;

    if (minPushback !== undefined && pushBack < minPushback && pushUp < minPushback) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;
    const range = parseInt(spell.fields[SF.RANGE]) || 0;

    matches.push({ name, level, pushBack, pushUp, category, target, range });
  }

  if (matches.length === 0) {
    return `No ${classFullName} spells with pushback/knockback effects${minPushback ? ` ≥${minPushback}` : ''}.`;
  }

  matches.sort((a, b) => (b.pushBack + b.pushUp) - (a.pushBack + a.pushUp) || a.level - b.level);

  const lines = [`# ${classFullName} Spells with Knockback/Pushback`, ''];
  lines.push(`**${matches.length} spells found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Push Back | Push Up | Level | Spell | Target | Range | Category |');
  lines.push('|-----------|---------|-------|-------|--------|-------|----------|');

  for (const s of shown) {
    lines.push(`| ${s.pushBack} | ${s.pushUp} | ${s.level} | ${s.name} | ${s.target} | ${s.range} | ${s.category} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}.*`);
  }

  return lines.join('\n');
}

// ============ DEITY-CLASS MATRIX ============

export function getDeityClassMatrix(): string {
  const lines = ['# Deity-Class Availability Matrix', ''];
  lines.push('Shows which classes can worship each deity (derived from race-deity and race-class combinations).', '');

  // Collect all unique deities
  const allDeities = new Set<string>();
  for (const deities of Object.values(RACE_DEITIES)) {
    for (const d of deities) allDeities.add(d);
  }
  const sortedDeities = [...allDeities].sort((a, b) => {
    if (a === 'Agnostic') return -1;
    if (b === 'Agnostic') return 1;
    return a.localeCompare(b);
  });

  // For each deity, find which classes can follow it
  const deityClasses = new Map<string, Set<number>>();
  for (const deity of sortedDeities) {
    const classSet = new Set<number>();
    for (const [raceIdStr, deities] of Object.entries(RACE_DEITIES)) {
      const raceId = parseInt(raceIdStr);
      if (!deities.includes(deity)) continue;
      const raceClasses = RACE_CLASSES[raceId] || [];
      for (const classId of raceClasses) {
        classSet.add(classId);
      }
    }
    deityClasses.set(deity, classSet);
  }

  // Build matrix header
  const classIds = Object.keys(CLASS_IDS).map(Number).sort((a, b) => a - b);
  const header = '| Deity | ' + classIds.map(id => CLASS_SHORT[id]).join(' | ') + ' | Total |';
  const sep = '|' + '-'.repeat(20) + '|' + classIds.map(() => '---').join('|') + '|-------|';
  lines.push(header);
  lines.push(sep);

  for (const deity of sortedDeities) {
    const classes = deityClasses.get(deity)!;
    const cells = classIds.map(id => classes.has(id) ? 'X' : '-');
    lines.push(`| ${deity.padEnd(18)} | ${cells.join(' | ')} | ${classes.size} |`);
  }

  // Class totals
  const classTotals = classIds.map(id => {
    let count = 0;
    for (const classes of deityClasses.values()) {
      if (classes.has(id)) count++;
    }
    return count;
  });
  lines.push(`| **Deities per class** | ${classTotals.join(' | ')} | |`);

  lines.push('', `**${sortedDeities.length} deities** × **${classIds.length} classes**`);

  return lines.join('\n');
}

// ============ SPELL RECOVERY TIME SEARCH ============

export async function searchSpellsByRecoveryTime(className: string, maxRecoveryMs?: number, minRecoveryMs?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; recoveryTime: number; castTime: number; category: string; beneficial: boolean }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const recoveryTime = parseInt(spell.fields[SF.RECOVERY_TIME]) || 0;
    if (maxRecoveryMs !== undefined && recoveryTime > maxRecoveryMs) continue;
    if (minRecoveryMs !== undefined && recoveryTime < minRecoveryMs) continue;

    const name = spell.fields[SF.NAME];
    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    matches.push({ name, level, recoveryTime, castTime, category, beneficial });
  }

  if (matches.length === 0) {
    const range = maxRecoveryMs !== undefined && minRecoveryMs !== undefined
      ? `${minRecoveryMs}-${maxRecoveryMs}ms`
      : maxRecoveryMs !== undefined ? `≤${maxRecoveryMs}ms` : `≥${minRecoveryMs}ms`;
    return `No ${classFullName} spells with recovery time ${range}.`;
  }

  matches.sort((a, b) => a.recoveryTime - b.recoveryTime || a.level - b.level);

  const rangeDesc = maxRecoveryMs !== undefined && minRecoveryMs !== undefined
    ? `${minRecoveryMs}-${maxRecoveryMs}ms`
    : maxRecoveryMs !== undefined ? `≤${maxRecoveryMs}ms` : minRecoveryMs !== undefined ? `≥${minRecoveryMs}ms` : 'all';

  const lines = [`# ${classFullName} Spells — Recovery Time ${rangeDesc}`, ''];
  lines.push(`Recovery time is the delay after casting before you can take another action.`, '');
  lines.push(`**${matches.length} spells found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Recovery | Cast Time | Total | Level | Spell | Category |');
  lines.push('|----------|-----------|-------|-------|-------|----------|');

  for (const s of shown) {
    const recStr = s.recoveryTime === 0 ? 'None' : `${(s.recoveryTime / 1000).toFixed(1)}s`;
    const castStr = s.castTime === 0 ? 'Instant' : `${(s.castTime / 1000).toFixed(1)}s`;
    const totalMs = s.recoveryTime + s.castTime;
    const totalStr = totalMs === 0 ? 'Instant' : `${(totalMs / 1000).toFixed(1)}s`;
    lines.push(`| ${recStr} | ${castStr} | ${totalStr} | ${s.level} | ${s.name} | ${s.category} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow your search.*`);
  }

  return lines.join('\n');
}

// ============ COMPARE FACTIONS ============

export async function compareFactions(faction1: string, faction2: string): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  // Find factions by name or ID
  const findFaction = (query: string): FactionEntry | undefined => {
    const id = parseInt(query);
    if (!isNaN(id) && factions!.has(id)) return factions!.get(id);
    const lower = query.toLowerCase();
    for (const faction of factions!.values()) {
      if (faction.name.toLowerCase() === lower) return faction;
    }
    for (const faction of factions!.values()) {
      if (faction.name.toLowerCase().includes(lower)) return faction;
    }
    return undefined;
  };

  const f1 = findFaction(faction1);
  const f2 = findFaction(faction2);
  if (!f1) return `Faction not found: "${faction1}"`;
  if (!f2) return `Faction not found: "${faction2}"`;

  const lines = [`# Faction Comparison: ${f1.name} vs ${f2.name}`, ''];

  lines.push('| Property | ' + f1.name + ' | ' + f2.name + ' |');
  lines.push('|----------|' + '-'.repeat(f1.name.length + 2) + '|' + '-'.repeat(f2.name.length + 2) + '|');
  lines.push(`| ID | ${f1.id} | ${f2.id} |`);
  lines.push(`| Expansion | ${f1.category || 'Unknown'} | ${f2.category || 'Unknown'} |`);
  lines.push(`| Min Value | ${f1.minValue} | ${f2.minValue} |`);
  lines.push(`| Max Value | ${f1.maxValue} | ${f2.maxValue} |`);
  lines.push(`| Value Range | ${f1.maxValue - f1.minValue} | ${f2.maxValue - f2.minValue} |`);
  lines.push(`| Starting Modifiers | ${f1.startingValues?.length || 0} | ${f2.startingValues?.length || 0} |`);

  // Compare starting values by race
  if ((f1.startingValues && f1.startingValues.length > 0) || (f2.startingValues && f2.startingValues.length > 0)) {
    const f1Map = new Map(f1.startingValues?.map(sv => [sv.modifierId, sv.value]) || []);
    const f2Map = new Map(f2.startingValues?.map(sv => [sv.modifierId, sv.value]) || []);

    const allModifiers = new Set([...f1Map.keys(), ...f2Map.keys()]);
    const raceModifiers: { name: string; v1: number; v2: number }[] = [];

    for (const modId of allModifiers) {
      const name = factionModifierNames?.get(modId) || `Modifier ${modId}`;
      if (!name.startsWith('Race:') && !PLAYABLE_RACE_MODIFIER_IDS.has(modId)) continue;
      const raceName = name.replace(/^Race:\s*/, '');
      raceModifiers.push({
        name: raceName,
        v1: f1Map.get(modId) || 0,
        v2: f2Map.get(modId) || 0,
      });
    }

    if (raceModifiers.length > 0) {
      raceModifiers.sort((a, b) => a.name.localeCompare(b.name));
      lines.push('', '## Starting Faction by Race', '');
      lines.push(`| Race | ${f1.name} | ${f2.name} |`);
      lines.push(`|------|${'-'.repeat(f1.name.length + 2)}|${'-'.repeat(f2.name.length + 2)}|`);
      for (const rm of raceModifiers) {
        if (rm.v1 !== 0 || rm.v2 !== 0) {
          lines.push(`| ${rm.name} | ${rm.v1} | ${rm.v2} |`);
        }
      }
    }
  }

  return lines.join('\n');
}

// ============ ZONE LEVEL STATISTICS ============

export async function getZoneLevelStatistics(): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const lines = ['# EverQuest Zone Level Statistics', ''];

  // Count zones by level bands
  const bands: { label: string; min: number; max: number; zones: string[] }[] = [
    { label: '1-10', min: 1, max: 10, zones: [] },
    { label: '11-20', min: 11, max: 20, zones: [] },
    { label: '21-30', min: 21, max: 30, zones: [] },
    { label: '31-40', min: 31, max: 40, zones: [] },
    { label: '41-50', min: 41, max: 50, zones: [] },
    { label: '51-60', min: 51, max: 60, zones: [] },
    { label: '61-70', min: 61, max: 70, zones: [] },
    { label: '71-80', min: 71, max: 80, zones: [] },
    { label: '81-90', min: 81, max: 90, zones: [] },
    { label: '91-100', min: 91, max: 100, zones: [] },
    { label: '101-110', min: 101, max: 110, zones: [] },
    { label: '111-120', min: 111, max: 120, zones: [] },
    { label: '121+', min: 121, max: 999, zones: [] },
  ];

  let hasLevel = 0;
  let noLevel = 0;
  let widestRange = { name: '', range: 0 };

  for (const zone of zones.values()) {
    if (zone.levelMin <= 0 && zone.levelMax <= 0) {
      noLevel++;
      continue;
    }
    hasLevel++;

    const effectiveMax = zone.levelMax > 0 ? zone.levelMax : zone.levelMin;
    const range = effectiveMax - zone.levelMin;
    if (range > widestRange.range) {
      widestRange = { name: zone.name, range };
    }

    for (const band of bands) {
      if (zone.levelMin <= band.max && effectiveMax >= band.min) {
        band.zones.push(zone.name);
      }
    }
  }

  lines.push(`**${zones.size} total zones** — ${hasLevel} with level data, ${noLevel} without`, '');

  lines.push('## Zone Count by Level Band', '');
  lines.push('| Level Range | Zones | % of Leveled |');
  lines.push('|-------------|-------|--------------|');
  for (const band of bands) {
    const pct = hasLevel > 0 ? ((band.zones.length / hasLevel) * 100).toFixed(1) : '0';
    const bar = '█'.repeat(Math.round(band.zones.length / 3));
    lines.push(`| ${band.label.padEnd(8)} | ${band.zones.length.toString().padStart(4)} | ${pct}% ${bar} |`);
  }

  if (widestRange.range > 0) {
    lines.push('', `**Widest level range:** ${widestRange.name} (${widestRange.range} levels)`);
  }

  // Peak level distribution (which levels have the most zones)
  const levelCounts = new Map<number, number>();
  for (const zone of zones.values()) {
    if (zone.levelMin <= 0) continue;
    const effectiveMax = zone.levelMax > 0 ? zone.levelMax : zone.levelMin;
    for (let l = zone.levelMin; l <= Math.min(effectiveMax, 130); l++) {
      levelCounts.set(l, (levelCounts.get(l) || 0) + 1);
    }
  }

  const peakLevels = [...levelCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
  if (peakLevels.length > 0) {
    lines.push('', '## Peak Levels (Most Zone Options)', '');
    lines.push('| Level | Zones Available |');
    lines.push('|-------|----------------|');
    for (const [level, count] of peakLevels) {
      lines.push(`| ${level} | ${count} |`);
    }
  }

  return lines.join('\n');
}

// ============ ACHIEVEMENT OVERVIEW ============

export async function getAchievementOverview(): Promise<string> {
  await loadAchievements();
  await loadAchievementCategories();
  if (!achievements || achievements.size === 0) return 'Achievement data not available.';

  const lines = ['# EverQuest Achievement System Overview', ''];
  lines.push(`**${achievements.size.toLocaleString()} total achievements**`, '');

  // Points distribution
  let totalPoints = 0;
  let hiddenCount = 0;
  let lockedCount = 0;
  let withPoints = 0;
  const pointBuckets = new Map<string, number>();

  for (const ach of achievements.values()) {
    totalPoints += ach.points;
    if (ach.hidden) hiddenCount++;
    if (ach.locked) lockedCount++;
    if (ach.points > 0) withPoints++;

    const bucket = ach.points === 0 ? '0' :
      ach.points <= 5 ? '1-5' :
      ach.points <= 10 ? '6-10' :
      ach.points <= 20 ? '11-20' :
      ach.points <= 50 ? '21-50' : '51+';
    pointBuckets.set(bucket, (pointBuckets.get(bucket) || 0) + 1);
  }

  lines.push('## Summary', '');
  lines.push(`- **Total points available:** ${totalPoints.toLocaleString()}`);
  lines.push(`- **Achievements with points:** ${withPoints.toLocaleString()}`);
  lines.push(`- **Hidden achievements:** ${hiddenCount.toLocaleString()}`);
  lines.push(`- **Locked achievements:** ${lockedCount.toLocaleString()}`);

  lines.push('', '## Points Distribution', '');
  lines.push('| Points | Achievements |');
  lines.push('|--------|-------------|');
  for (const bucket of ['0', '1-5', '6-10', '11-20', '21-50', '51+']) {
    const count = pointBuckets.get(bucket) || 0;
    if (count > 0) {
      lines.push(`| ${bucket} | ${count} |`);
    }
  }

  // Top-level categories
  if (achievementCategories && categoryToAchievements) {
    const topCats: { name: string; totalAchs: number }[] = [];

    for (const [, cat] of achievementCategories) {
      if (cat.parentId !== 0) continue;

      // Count all achievements in this top-level category and subcategories
      let total = 0;
      const directAchs = categoryToAchievements.get(cat.id) || [];
      total += directAchs.length;

      for (const [, subcat] of achievementCategories) {
        if (subcat.parentId === cat.id) {
          const subAchs = categoryToAchievements.get(subcat.id) || [];
          total += subAchs.length;
        }
      }

      if (total > 0) {
        topCats.push({ name: cat.name, totalAchs: total });
      }
    }

    topCats.sort((a, b) => b.totalAchs - a.totalAchs);

    lines.push('', '## Achievements by Top-Level Category', '');
    lines.push('| Category | Achievements |');
    lines.push('|----------|-------------|');
    for (const tc of topCats) {
      lines.push(`| ${tc.name} | ${tc.totalAchs} |`);
    }
  }

  return lines.join('\n');
}

// ============ COMPARE EXPANSIONS ============

export async function compareExpansions(exp1Query: string, exp2Query: string): Promise<string> {
  await loadExpansions();
  await loadFactions();
  await loadAchievementCategories();
  await loadAchievements();
  await loadZones();

  if (!expansionNames || expansionNames.size === 0) return 'Expansion data not available.';

  const findExpansion = (query: string): { id: number; name: string } | undefined => {
    const lower = query.toLowerCase();
    for (const [id, name] of expansionNames!) {
      if (name.toLowerCase() === lower) return { id, name };
    }
    for (const [id, name] of expansionNames!) {
      if (name.toLowerCase().includes(lower)) return { id, name };
    }
    const num = parseInt(query);
    if (!isNaN(num) && expansionNames!.has(num)) return { id: num, name: expansionNames!.get(num)! };
    return undefined;
  };

  const e1 = findExpansion(exp1Query);
  const e2 = findExpansion(exp2Query);
  if (!e1) return `Expansion not found: "${exp1Query}". Use list_expansions to see all.`;
  if (!e2) return `Expansion not found: "${exp2Query}". Use list_expansions to see all.`;

  const lines = [`# Expansion Comparison: ${e1.name} vs ${e2.name}`, ''];

  // Count factions
  const countFactions = (expName: string): number => {
    if (!factions) return 0;
    let count = 0;
    for (const faction of factions.values()) {
      if (faction.category && faction.category.toLowerCase() === expName.toLowerCase()) count++;
    }
    return count;
  };

  // Count achievements
  const countAchievements = (expName: string): { total: number; subcats: number } => {
    if (!achievementCategories || !categoryToAchievements) return { total: 0, subcats: 0 };
    let total = 0;
    let subcats = 0;
    for (const [, cat] of achievementCategories) {
      if (cat.parentId !== 0) continue;
      if (cat.name.toLowerCase() !== expName.toLowerCase()) continue;
      const directAchs = categoryToAchievements.get(cat.id) || [];
      total += directAchs.length;
      for (const [, subcat] of achievementCategories) {
        if (subcat.parentId === cat.id) {
          subcats++;
          const subAchs = categoryToAchievements.get(subcat.id) || [];
          total += subAchs.length;
        }
      }
    }
    return { total, subcats };
  };

  const f1 = countFactions(e1.name);
  const f2 = countFactions(e2.name);
  const a1 = countAchievements(e1.name);
  const a2 = countAchievements(e2.name);

  lines.push('| Property | ' + e1.name + ' | ' + e2.name + ' |');
  lines.push('|----------|' + '-'.repeat(e1.name.length + 2) + '|' + '-'.repeat(e2.name.length + 2) + '|');
  lines.push(`| Expansion # | ${e1.id} | ${e2.id} |`);
  lines.push(`| Factions | ${f1} | ${f2} |`);
  lines.push(`| Achievements | ${a1.total} | ${a2.total} |`);
  lines.push(`| Achievement Subcategories | ${a1.subcats} | ${a2.subcats} |`);

  // List faction names for both
  if (factions && (f1 > 0 || f2 > 0)) {
    const getFactionNames = (expName: string): string[] => {
      const names: string[] = [];
      for (const faction of factions!.values()) {
        if (faction.category && faction.category.toLowerCase() === expName.toLowerCase()) {
          names.push(faction.name);
        }
      }
      return names.sort();
    };

    const fnames1 = getFactionNames(e1.name);
    const fnames2 = getFactionNames(e2.name);

    if (fnames1.length > 0) {
      lines.push('', `## ${e1.name} Factions (${fnames1.length})`);
      for (const n of fnames1.slice(0, 20)) lines.push(`- ${n}`);
      if (fnames1.length > 20) lines.push(`- *(${fnames1.length - 20} more...)*`);
    }
    if (fnames2.length > 0) {
      lines.push('', `## ${e2.name} Factions (${fnames2.length})`);
      for (const n of fnames2.slice(0, 20)) lines.push(`- ${n}`);
      if (fnames2.length > 20) lines.push(`- *(${fnames2.length - 20} more...)*`);
    }
  }

  return lines.join('\n');
}

// ============ SPELL SUBCATEGORY SEARCH ============

export async function searchSpellsBySubcategory(className: string, subcategory: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  // Find matching subcategory ID
  const normalizedSubcat = subcategory.toLowerCase();
  let matchedSubcatId: number | null = null;
  let matchedSubcatName = '';

  if (spellCategories) {
    // Exact match first
    for (const [id, name] of spellCategories) {
      if (name.toLowerCase() === normalizedSubcat) {
        matchedSubcatId = id;
        matchedSubcatName = name;
        break;
      }
    }
    // Partial match
    if (matchedSubcatId === null) {
      for (const [id, name] of spellCategories) {
        if (name.toLowerCase().includes(normalizedSubcat)) {
          matchedSubcatId = id;
          matchedSubcatName = name;
          break;
        }
      }
    }
  }

  if (matchedSubcatId === null) {
    // List available subcategories used by this class
    const classCats = new Map<number, { name: string; count: number }>();
    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
      if (level <= 0 || level >= 255) continue;
      const subCatId = parseInt(spell.fields[SF.SUBCATEGORY]) || 0;
      if (subCatId === 0) continue;
      const catName = spellCategories?.get(subCatId) || 'Unknown';
      const existing = classCats.get(subCatId) || { name: catName, count: 0 };
      existing.count++;
      classCats.set(subCatId, existing);
    }
    const sorted = [...classCats.values()].sort((a, b) => b.count - a.count);
    const lines = [`Subcategory "${subcategory}" not found for ${classFullName}.`, ''];
    lines.push(`**Available subcategories for ${classFullName}:**`);
    for (const sc of sorted.slice(0, 40)) {
      lines.push(`- ${sc.name} (${sc.count} spells)`);
    }
    return lines.join('\n');
  }

  const matches: { name: string; level: number; category: string; beneficial: boolean; target: string; mana: number }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const subCatId = parseInt(spell.fields[SF.SUBCATEGORY]) || 0;
    if (subCatId !== matchedSubcatId) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const targetId = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const target = TARGET_TYPES[targetId] || `Type ${targetId}`;
    const mana = parseInt(spell.fields[SF.MANA]) || 0;

    matches.push({ name, level, category, beneficial, target, mana });
  }

  if (matches.length === 0) {
    return `No ${classFullName} spells in subcategory "${matchedSubcatName}".`;
  }

  matches.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  const lines = [`# ${classFullName} Spells — Subcategory: ${matchedSubcatName}`, ''];
  lines.push(`**${matches.length} spells found** (parent category shown for context)`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Level | Spell | Parent Category | Target | Mana | Type |');
  lines.push('|-------|-------|----------------|--------|------|------|');

  for (const s of shown) {
    const type = s.beneficial ? 'Buff' : 'Debuff';
    lines.push(`| ${s.level} | ${s.name} | ${s.category} | ${s.target} | ${s.mana || '-'} | ${type} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}.*`);
  }

  return lines.join('\n');
}

// ============ AA OVERVIEW ============

export async function getAAOverview(): Promise<string> {
  await loadAAAbilities();
  if (!aaAbilities || aaAbilities.size === 0) return 'AA ability data not available.';

  const lines = ['# EverQuest AA System Overview', ''];
  lines.push(`**${aaAbilities.size.toLocaleString()} total AA abilities**`, '');

  // Analyze descriptions for common keywords
  const keywords = new Map<string, number>();
  const keywordPatterns = [
    'damage', 'heal', 'hit points', 'mana', 'endurance', 'resist',
    'critical', 'accuracy', 'avoidance', 'haste', 'attack',
    'defense', 'shield', 'proc', 'stun', 'root', 'slow',
    'fear', 'charm', 'mezz', 'snare', 'dot', 'nuke',
    'pet', 'summon', 'gate', 'bind', 'invis', 'levitate',
    'regenerat', 'buff', 'debuff', 'focus', 'passive',
  ];

  for (const aa of aaAbilities.values()) {
    const lowerDesc = aa.description.toLowerCase();
    for (const kw of keywordPatterns) {
      if (lowerDesc.includes(kw)) {
        keywords.set(kw, (keywords.get(kw) || 0) + 1);
      }
    }
  }

  // Description length stats
  let totalLen = 0;
  let hasDesc = 0;
  let noDesc = 0;
  for (const aa of aaAbilities.values()) {
    if (aa.description && aa.description.length > 0) {
      hasDesc++;
      totalLen += aa.description.length;
    } else {
      noDesc++;
    }
  }

  lines.push('## Description Statistics', '');
  lines.push(`- **With descriptions:** ${hasDesc.toLocaleString()}`);
  lines.push(`- **Without descriptions:** ${noDesc.toLocaleString()}`);
  if (hasDesc > 0) {
    lines.push(`- **Average description length:** ${Math.round(totalLen / hasDesc)} characters`);
  }

  // Keyword analysis
  const sortedKw = [...keywords.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('', '## Common AA Keywords (by description frequency)', '');
  lines.push('| Keyword | AAs Mentioning |');
  lines.push('|---------|---------------|');
  for (const [kw, count] of sortedKw.slice(0, 25)) {
    const pct = ((count / aaAbilities.size) * 100).toFixed(1);
    lines.push(`| ${kw} | ${count} (${pct}%) |`);
  }

  // Name patterns (ranks)
  let withRank = 0;
  const rankCounts = new Map<string, number>();
  for (const aa of aaAbilities.values()) {
    const rankMatch = aa.name.match(/\((\d+)\)$/);
    if (rankMatch) {
      withRank++;
      const rank = rankMatch[1];
      rankCounts.set(rank, (rankCounts.get(rank) || 0) + 1);
    }
  }
  if (withRank > 0) {
    lines.push('', '## AA Ranks', '');
    lines.push(`- **AAs with rank numbers:** ${withRank.toLocaleString()}`);
    lines.push(`- **Unique base abilities (estimated):** ~${(aaAbilities.size - withRank + rankCounts.size).toLocaleString()}`);
  }

  return lines.join('\n');
}

// ============ OVERSEER AGENT TRAIT SEARCH ============

export async function searchOverseerAgentsByTrait(trait: string): Promise<string> {
  await loadOverseerMinions();
  if (!overseerMinions || overseerMinions.size === 0) return 'Overseer agent data not available.';

  const normalizedTrait = trait.toLowerCase();

  const matches: { id: number; name: string; rarity: number; traits: string[]; jobs: string[] }[] = [];

  for (const agent of overseerMinions.values()) {
    const hasTrait = agent.traits.some(t => t.toLowerCase().includes(normalizedTrait));
    if (!hasTrait) continue;

    const jobNames = agent.jobs.map(j => {
      const name = overseerJobNames?.get(j.jobTypeId) || `Job ${j.jobTypeId}`;
      return `${name} (${j.level})`;
    });

    matches.push({
      id: agent.id,
      name: agent.shortName || agent.fullName,
      rarity: agent.rarity,
      traits: agent.traits,
      jobs: jobNames,
    });
  }

  if (matches.length === 0) {
    // List available traits
    const allTraits = new Map<string, number>();
    for (const agent of overseerMinions.values()) {
      for (const t of agent.traits) {
        allTraits.set(t, (allTraits.get(t) || 0) + 1);
      }
    }
    const sorted = [...allTraits.entries()].sort((a, b) => b[1] - a[1]);
    const lines = [`No overseer agents with trait matching "${trait}".`, ''];
    lines.push('**Available traits:**');
    for (const [t, count] of sorted.slice(0, 40)) {
      lines.push(`- ${t} (${count} agents)`);
    }
    return lines.join('\n');
  }

  const rarityNames: Record<number, string> = { 1: 'Common', 2: 'Uncommon', 3: 'Rare', 4: 'Elite', 5: 'Iconic' };

  matches.sort((a, b) => b.rarity - a.rarity || a.name.localeCompare(b.name));

  const lines = [`# Overseer Agents with Trait: "${trait}"`, ''];
  lines.push(`**${matches.length} agents found**`, '');

  const shown = matches.slice(0, 50);
  lines.push('| Agent | Rarity | All Traits | Jobs |');
  lines.push('|-------|--------|-----------|------|');

  for (const m of shown) {
    const rarity = rarityNames[m.rarity] || `Rarity ${m.rarity}`;
    lines.push(`| ${m.name} | ${rarity} | ${m.traits.join(', ')} | ${m.jobs.join(', ')} |`);
  }

  if (matches.length > 50) {
    lines.push('', `*Showing first 50 of ${matches.length}.*`);
  }

  return lines.join('\n');
}

// ============ GAME EVENT OVERVIEW ============

export async function getGameEventOverview(): Promise<string> {
  await loadGameEvents();
  if (!gameEvents || gameEvents.size === 0) return 'Game event data not available.';

  const lines = ['# EverQuest Game Event Overview', ''];
  lines.push(`**${gameEvents.size} game events/announcements**`, '');

  // Categorize events by keywords in banners
  const categories = new Map<string, { count: number; examples: string[] }>();
  const categoryPatterns: [string, RegExp][] = [
    ['Expansion', /expansion|launch|release/i],
    ['Seasonal', /frostfell|erollisi|bristlebane|anniversary|halloween|harvest|night of shadows/i],
    ['Double XP', /double|bonus|experience|xp/i],
    ['Server', /server|merge|maintenance|downtime/i],
    ['Marketplace', /marketplace|sale|discount|free/i],
    ['Membership', /member|subscription|all access/i],
    ['Patch/Update', /patch|update|fix|hotfix/i],
    ['Event', /event|raid|contest|competition/i],
    ['Recruit', /recruit|returning|welcome back/i],
  ];

  for (const event of gameEvents.values()) {
    const text = `${event.banner} ${event.description}`;
    let categorized = false;
    for (const [catName, pattern] of categoryPatterns) {
      if (pattern.test(text)) {
        const cat = categories.get(catName) || { count: 0, examples: [] };
        cat.count++;
        if (cat.examples.length < 3) cat.examples.push(event.banner);
        categories.set(catName, cat);
        categorized = true;
        break;
      }
    }
    if (!categorized) {
      const cat = categories.get('Other') || { count: 0, examples: [] };
      cat.count++;
      if (cat.examples.length < 3) cat.examples.push(event.banner);
      categories.set('Other', cat);
    }
  }

  lines.push('## Events by Category', '');
  lines.push('| Category | Count | Examples |');
  lines.push('|----------|-------|----------|');

  const sortedCats = [...categories.entries()].sort((a, b) => b[1].count - a[1].count);
  for (const [name, data] of sortedCats) {
    const examples = data.examples.slice(0, 2).join('; ');
    lines.push(`| ${name} | ${data.count} | ${examples} |`);
  }

  // Banner length stats
  let shortBanners = 0;
  let longBanners = 0;
  for (const event of gameEvents.values()) {
    if (event.banner.length <= 30) shortBanners++;
    else longBanners++;
  }

  lines.push('', '## Banner Statistics', '');
  lines.push(`- **Short banners (≤30 chars):** ${shortBanners}`);
  lines.push(`- **Long banners (>30 chars):** ${longBanners}`);

  return lines.join('\n');
}

// ============ LORE OVERVIEW ============

export async function getLoreOverview(): Promise<string> {
  await loadLore();
  if (!loreEntries || loreEntries.length === 0) return 'Lore data not available.';

  const lines = ['# EverQuest In-Game Lore Overview', ''];
  lines.push(`**${loreEntries.length} lore stories** from game files`, '');

  // Analyze content
  let totalWords = 0;
  let totalChars = 0;
  let shortest = { title: '', words: Infinity };
  let longest = { title: '', words: 0 };

  const titleList: { title: string; words: number; filename: string }[] = [];

  for (const entry of loreEntries) {
    const words = entry.content.split(/\s+/).filter(w => w.length > 0).length;
    totalWords += words;
    totalChars += entry.content.length;

    if (words < shortest.words) shortest = { title: entry.title || entry.filename, words };
    if (words > longest.words) longest = { title: entry.title || entry.filename, words };

    titleList.push({ title: entry.title || entry.filename, words, filename: entry.filename });
  }

  lines.push('## Statistics', '');
  lines.push(`- **Total words:** ${totalWords.toLocaleString()}`);
  lines.push(`- **Average story length:** ${Math.round(totalWords / loreEntries.length)} words`);
  lines.push(`- **Longest story:** ${longest.title} (${longest.words.toLocaleString()} words)`);
  lines.push(`- **Shortest story:** ${shortest.title} (${shortest.words} words)`);

  // List all stories sorted by title
  titleList.sort((a, b) => a.title.localeCompare(b.title));

  lines.push('', '## All Lore Stories', '');
  lines.push('| Title | Words |');
  lines.push('|-------|-------|');
  for (const entry of titleList) {
    lines.push(`| ${entry.title} | ${entry.words.toLocaleString()} |`);
  }

  return lines.join('\n');
}

// ============ CURRENCY OVERVIEW ============

export async function getCurrencyOverview(): Promise<string> {
  await loadAltCurrencies();
  if (!altCurrencies || altCurrencies.size === 0) return 'Currency data not available.';

  const lines = ['# EverQuest Alternate Currency Overview', ''];
  lines.push(`**${altCurrencies.size} alternate currencies**`, '');

  // List all currencies
  const sorted = [...altCurrencies.entries()].sort((a, b) => a[1].name.localeCompare(b[1].name));

  lines.push('| ID | Currency | Description |');
  lines.push('|----|----------|-------------|');

  for (const [id, currency] of sorted) {
    const desc = currency.description.length > 80
      ? currency.description.substring(0, 77) + '...'
      : currency.description;
    lines.push(`| ${id} | ${currency.name} | ${desc} |`);
  }

  // Name analysis
  const keywords = new Map<string, number>();
  for (const currency of altCurrencies.values()) {
    const lower = currency.name.toLowerCase();
    for (const kw of ['coin', 'token', 'mark', 'medal', 'gem', 'crystal', 'seal', 'badge', 'shard', 'point']) {
      if (lower.includes(kw)) {
        keywords.set(kw, (keywords.get(kw) || 0) + 1);
      }
    }
  }

  if (keywords.size > 0) {
    lines.push('', '## Currency Type Distribution', '');
    const sortedKw = [...keywords.entries()].sort((a, b) => b[1] - a[1]);
    for (const [kw, count] of sortedKw) {
      lines.push(`- **${kw}:** ${count} currencies`);
    }
  }

  return lines.join('\n');
}

// ============ MAP POI STATISTICS ============

export async function getMapStatistics(): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const lines = ['# EverQuest Map POI Statistics', ''];

  // Check map directory
  const mapDir = gamePath('maps');
  if (!existsSync(mapDir)) return 'Maps directory not found at ' + mapDir;

  // Count map files and POIs
  const allFiles = await readdir(mapDir);
  const files = allFiles.filter((f: string) => f.endsWith('.txt') && !f.endsWith('_1.txt') && !f.endsWith('_2.txt') && !f.endsWith('_3.txt'));

  let totalPOIs = 0;
  let zonesWithPOIs = 0;
  let maxPOIs = { zone: '', count: 0 };
  const poiCounts: number[] = [];

  for (const file of files) {
    const content = await readFile(join(mapDir, file), 'utf-8');
    const poiLines = content.split('\n').filter((l: string) => l.startsWith('P '));
    if (poiLines.length > 0) {
      zonesWithPOIs++;
      totalPOIs += poiLines.length;
      poiCounts.push(poiLines.length);
      if (poiLines.length > maxPOIs.count) {
        maxPOIs = { zone: file.replace('.txt', ''), count: poiLines.length };
      }
    }
  }

  lines.push(`**${totalPOIs.toLocaleString()} total POIs** across **${zonesWithPOIs} zone maps** (${files.length} map files total)`, '');

  lines.push('## Summary', '');
  lines.push(`- **Map files:** ${files.length}`);
  lines.push(`- **Zones with POIs:** ${zonesWithPOIs}`);
  lines.push(`- **Total POIs:** ${totalPOIs.toLocaleString()}`);
  if (poiCounts.length > 0) {
    const avg = Math.round(totalPOIs / zonesWithPOIs);
    poiCounts.sort((a, b) => a - b);
    const median = poiCounts[Math.floor(poiCounts.length / 2)];
    lines.push(`- **Average POIs per zone:** ${avg}`);
    lines.push(`- **Median POIs per zone:** ${median}`);
    lines.push(`- **Most POIs:** ${maxPOIs.zone} (${maxPOIs.count})`);
  }

  // POI density distribution
  const buckets = [
    { label: '1-10', min: 1, max: 10, count: 0 },
    { label: '11-50', min: 11, max: 50, count: 0 },
    { label: '51-100', min: 51, max: 100, count: 0 },
    { label: '101-200', min: 101, max: 200, count: 0 },
    { label: '201-500', min: 201, max: 500, count: 0 },
    { label: '501+', min: 501, max: 99999, count: 0 },
  ];

  for (const count of poiCounts) {
    for (const bucket of buckets) {
      if (count >= bucket.min && count <= bucket.max) {
        bucket.count++;
        break;
      }
    }
  }

  lines.push('', '## POI Density Distribution', '');
  lines.push('| POIs per Zone | Zones |');
  lines.push('|--------------|-------|');
  for (const bucket of buckets) {
    if (bucket.count > 0) {
      lines.push(`| ${bucket.label} | ${bucket.count} |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: DRAKKIN HERITAGES ============

export async function listDrakkinHeritages(): Promise<string> {
  await loadDrakkinHeritages();
  if (!drakkinHeritages || drakkinHeritages.length === 0) return 'Drakkin heritage data not available.';

  const lines = ['# Drakkin Dragon Heritages', ''];
  lines.push(`**${drakkinHeritages.length} heritages** available for the Drakkin race`, '');
  lines.push('Each heritage represents a dragon bloodline that determines appearance and lore background.', '');

  lines.push('| Heritage ID | Name | Available Classes |');
  lines.push('|-------------|------|-------------------|');

  for (const h of drakkinHeritages.sort((a, b) => a.id - b.id)) {
    const classNames = h.classes.map(c => CLASS_IDS[c]).filter(Boolean).join(', ');
    lines.push(`| ${h.id} | ${h.name} | ${classNames} |`);
  }

  // Summary: which classes can be Drakkin
  const allClassIds = new Set<number>();
  for (const h of drakkinHeritages) {
    for (const c of h.classes) allClassIds.add(c);
  }
  const sortedClasses = [...allClassIds].sort((a, b) => a - b).map(c => CLASS_IDS[c]).filter(Boolean);
  lines.push('', `**Drakkin can be:** ${sortedClasses.join(', ')} (${sortedClasses.length} classes)`);

  return lines.join('\n');
}

// ============ PUBLIC API: RECOURSE SPELL SEARCH ============

export async function searchSpellsWithRecourse(className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';
  await loadSpellDescriptions();

  const lines = ['# Spells with Recourse Effects', ''];

  let classId: number | undefined;
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    lines[0] = `# ${CLASS_IDS[classId]} Spells with Recourse Effects`;
  }

  const results: { name: string; level: number; recourseId: number; recourseName: string; category: string }[] = [];

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const recourseId = parseInt(spell.fields[SF.RECOURSE]);
    if (!recourseId || recourseId <= 0) continue;

    if (classId) {
      const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]);
      if (isNaN(classLevel) || classLevel > 254) continue;

      const recourseSpell = spells.get(recourseId);
      const recourseName = recourseSpell ? recourseSpell.name : `Spell #${recourseId}`;
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      const category = (spellCategories && spellCategories.get(catId)) || '';

      results.push({ name: spell.name, level: classLevel, recourseId, recourseName, category });
    } else {
      let minLevel = 255;
      for (let c = 0; c < 16; c++) {
        const lvl = parseInt(spell.fields[SF.CLASS_LEVEL_START + c]);
        if (!isNaN(lvl) && lvl < minLevel) minLevel = lvl;
      }
      if (minLevel > 254) continue;

      const recourseSpell = spells.get(recourseId);
      const recourseName = recourseSpell ? recourseSpell.name : `Spell #${recourseId}`;
      const catId = parseInt(spell.fields[SF.CATEGORY]);
      const category = (spellCategories && spellCategories.get(catId)) || '';

      results.push({ name: spell.name, level: minLevel, recourseId, recourseName, category });
    }
  }

  results.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  lines.push(`**${results.length} spells** with recourse (follow-up) effects`, '');
  lines.push('A recourse spell is automatically cast on the caster when the main spell successfully lands on a target.', '');

  lines.push('| Level | Spell | Recourse Spell | Category |');
  lines.push('|-------|-------|----------------|----------|');

  for (const r of results.slice(0, 100)) {
    lines.push(`| ${r.level} | ${r.name} | ${r.recourseName} | ${r.category} |`);
  }

  if (results.length > 100) {
    lines.push('', `*Showing first 100 of ${results.length} results.*`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: BASE STAT COMPARISON ============

export async function compareBaseStats(class1: string, class2: string, level?: number): Promise<string> {
  await loadBaseStats();
  if (!baseStats || baseStats.length === 0) return 'Base stat data not available.';

  const classId1 = CLASS_NAME_TO_ID[class1.toLowerCase()];
  const classId2 = CLASS_NAME_TO_ID[class2.toLowerCase()];
  if (!classId1) return `Unknown class: "${class1}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (!classId2) return `Unknown class: "${class2}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (classId1 === classId2) return `Both classes are the same (${CLASS_IDS[classId1]}). Choose two different classes.`;

  const name1 = CLASS_IDS[classId1];
  const name2 = CLASS_IDS[classId2];

  const entries1 = baseStats.filter(e => e.classId === classId1);
  const entries2 = baseStats.filter(e => e.classId === classId2);

  if (entries1.length === 0) return `No base stat data found for ${name1}.`;
  if (entries2.length === 0) return `No base stat data found for ${name2}.`;

  const lines = [`# Base Stat Comparison: ${name1} vs ${name2}`, ''];

  if (level) {
    const e1 = entries1.find(e => e.level === level);
    const e2 = entries2.find(e => e.level === level);
    if (!e1) return `No data for ${name1} at level ${level}.`;
    if (!e2) return `No data for ${name2} at level ${level}.`;

    lines.push(`## Level ${level}`, '');
    lines.push(`| Stat | ${name1} | ${name2} | Difference |`);
    lines.push('|------|' + '-'.repeat(name1.length + 2) + '|' + '-'.repeat(name2.length + 2) + '|------------|');

    const stats = [
      { label: 'HP', v1: e1.hp, v2: e2.hp },
      { label: 'Mana', v1: e1.mana, v2: e2.mana },
      { label: 'Endurance', v1: e1.endurance, v2: e2.endurance },
      { label: 'HP Regen', v1: e1.hpRegen, v2: e2.hpRegen },
      { label: 'Mana Regen', v1: e1.manaRegen, v2: e2.manaRegen },
      { label: 'End Regen', v1: e1.enduranceRegen, v2: e2.enduranceRegen },
    ];

    for (const s of stats) {
      const diff = s.v1 - s.v2;
      const diffStr = diff > 0 ? `+${diff.toFixed(1)} ${name1}` : diff < 0 ? `+${(-diff).toFixed(1)} ${name2}` : 'Equal';
      const fmt = (v: number) => v % 1 !== 0 ? v.toFixed(3) : v.toString();
      lines.push(`| ${s.label} | ${fmt(s.v1)} | ${fmt(s.v2)} | ${diffStr} |`);
    }
  } else {
    const milestones = [1, 10, 20, 30, 40, 50, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125];

    lines.push('## HP Comparison', '');
    lines.push(`| Level | ${name1} | ${name2} | Advantage |`);
    lines.push('|-------|' + '-'.repeat(name1.length + 2) + '|' + '-'.repeat(name2.length + 2) + '|-----------|');

    for (const lvl of milestones) {
      const e1 = entries1.find(e => e.level === lvl);
      const e2 = entries2.find(e => e.level === lvl);
      if (!e1 || !e2) continue;
      const diff = e1.hp - e2.hp;
      const adv = diff > 0 ? `${name1} +${diff}` : diff < 0 ? `${name2} +${-diff}` : 'Equal';
      lines.push(`| ${lvl} | ${e1.hp.toLocaleString()} | ${e2.hp.toLocaleString()} | ${adv} |`);
    }

    lines.push('', '## Mana Comparison', '');
    lines.push(`| Level | ${name1} | ${name2} | Advantage |`);
    lines.push('|-------|' + '-'.repeat(name1.length + 2) + '|' + '-'.repeat(name2.length + 2) + '|-----------|');

    for (const lvl of milestones) {
      const e1 = entries1.find(e => e.level === lvl);
      const e2 = entries2.find(e => e.level === lvl);
      if (!e1 || !e2) continue;
      const diff = e1.mana - e2.mana;
      const adv = diff > 0 ? `${name1} +${diff}` : diff < 0 ? `${name2} +${-diff}` : 'Equal';
      lines.push(`| ${lvl} | ${e1.mana.toLocaleString()} | ${e2.mana.toLocaleString()} | ${adv} |`);
    }

    lines.push('', '## Endurance Comparison', '');
    lines.push(`| Level | ${name1} | ${name2} | Advantage |`);
    lines.push('|-------|' + '-'.repeat(name1.length + 2) + '|' + '-'.repeat(name2.length + 2) + '|-----------|');

    for (const lvl of milestones) {
      const e1 = entries1.find(e => e.level === lvl);
      const e2 = entries2.find(e => e.level === lvl);
      if (!e1 || !e2) continue;
      const diff = e1.endurance - e2.endurance;
      const adv = diff > 0 ? `${name1} +${diff}` : diff < 0 ? `${name2} +${-diff}` : 'Equal';
      lines.push(`| ${lvl} | ${e1.endurance.toLocaleString()} | ${e2.endurance.toLocaleString()} | ${adv} |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SKILL CAP COMPARISON ============

export async function compareSkillCaps(class1: string, class2: string, level?: number): Promise<string> {
  await loadSkillCaps();
  if (!skillCaps || skillCaps.length === 0) return 'Skill cap data not available.';

  const classId1 = CLASS_NAME_TO_ID[class1.toLowerCase()];
  const classId2 = CLASS_NAME_TO_ID[class2.toLowerCase()];
  if (!classId1) return `Unknown class: "${class1}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (!classId2) return `Unknown class: "${class2}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  if (classId1 === classId2) return `Both classes are the same (${CLASS_IDS[classId1]}). Choose two different classes.`;

  const name1 = CLASS_IDS[classId1];
  const name2 = CLASS_IDS[classId2];
  const targetLevel = level || 125; // Default to max level

  const entries1 = skillCaps.filter(e => e.classId === classId1 && e.level === targetLevel);
  const entries2 = skillCaps.filter(e => e.classId === classId2 && e.level === targetLevel);

  // Build skill cap maps
  const caps1 = new Map<number, number>();
  const caps2 = new Map<number, number>();
  for (const e of entries1) caps1.set(e.skillId, e.cap);
  for (const e of entries2) caps2.set(e.skillId, e.cap);

  const allSkillIds = new Set([...caps1.keys(), ...caps2.keys()]);
  if (allSkillIds.size === 0) return `No skill data found at level ${targetLevel}.`;

  const lines = [`# Skill Cap Comparison: ${name1} vs ${name2} (Level ${targetLevel})`, ''];

  // Categorize: shared skills, unique to class1, unique to class2
  const shared: { skillId: number; name: string; cap1: number; cap2: number }[] = [];
  const only1: { skillId: number; name: string; cap: number }[] = [];
  const only2: { skillId: number; name: string; cap: number }[] = [];

  for (const skillId of [...allSkillIds].sort((a, b) => a - b)) {
    const c1 = caps1.get(skillId) || 0;
    const c2 = caps2.get(skillId) || 0;
    const skillName = SKILL_NAMES[skillId] || `Skill ${skillId}`;

    if (c1 > 0 && c2 > 0) {
      shared.push({ skillId, name: skillName, cap1: c1, cap2: c2 });
    } else if (c1 > 0) {
      only1.push({ skillId, name: skillName, cap: c1 });
    } else if (c2 > 0) {
      only2.push({ skillId, name: skillName, cap: c2 });
    }
  }

  // Shared skills comparison
  if (shared.length > 0) {
    lines.push('## Shared Skills', '');
    lines.push(`| Skill | ${name1} | ${name2} | Advantage |`);
    lines.push('|-------|' + '-'.repeat(name1.length + 2) + '|' + '-'.repeat(name2.length + 2) + '|-----------|');

    for (const s of shared) {
      const diff = s.cap1 - s.cap2;
      const adv = diff > 0 ? `${name1} +${diff}` : diff < 0 ? `${name2} +${-diff}` : 'Equal';
      lines.push(`| ${s.name} | ${s.cap1} | ${s.cap2} | ${adv} |`);
    }
  }

  // Skills unique to each class
  if (only1.length > 0) {
    lines.push('', `## ${name1} Only`, '');
    lines.push('| Skill | Cap |');
    lines.push('|-------|-----|');
    for (const s of only1) {
      lines.push(`| ${s.name} | ${s.cap} |`);
    }
  }

  if (only2.length > 0) {
    lines.push('', `## ${name2} Only`, '');
    lines.push('| Skill | Cap |');
    lines.push('|-------|-----|');
    for (const s of only2) {
      lines.push(`| ${s.name} | ${s.cap} |`);
    }
  }

  lines.push('', `**Summary:** ${shared.length} shared skills, ${only1.length} unique to ${name1}, ${only2.length} unique to ${name2}`);

  return lines.join('\n');
}

// ============ PUBLIC API: BASE STAT OVERVIEW ============

export async function getBaseStatOverview(level: number): Promise<string> {
  await loadBaseStats();
  if (!baseStats || baseStats.length === 0) return 'Base stat data not available.';

  const entries = baseStats.filter(e => e.level === level);
  if (entries.length === 0) return `No base stat data found at level ${level}. Try levels 1-125.`;

  const lines = [`# All Classes Base Stats at Level ${level}`, ''];

  // Sort by HP descending
  const byHP = [...entries].sort((a, b) => b.hp - a.hp);

  lines.push('## Sorted by HP', '');
  lines.push('| Rank | Class | HP | Mana | Endurance | HP Regen | Mana Regen | End Regen |');
  lines.push('|------|-------|-----|------|-----------|----------|------------|-----------|');

  let rank = 1;
  for (const e of byHP) {
    const className = CLASS_IDS[e.classId] || `Class ${e.classId}`;
    lines.push(`| ${rank++} | ${className} | ${e.hp.toLocaleString()} | ${e.mana.toLocaleString()} | ${e.endurance.toLocaleString()} | ${e.hpRegen.toFixed(1)} | ${e.manaRegen.toFixed(1)} | ${e.enduranceRegen.toFixed(1)} |`);
  }

  // Quick rankings
  const byMana = [...entries].filter(e => e.mana > 0).sort((a, b) => b.mana - a.mana);
  if (byMana.length > 0) {
    lines.push('', '## Mana Rankings', '');
    lines.push('| Rank | Class | Mana |');
    lines.push('|------|-------|------|');
    let mRank = 1;
    for (const e of byMana) {
      lines.push(`| ${mRank++} | ${CLASS_IDS[e.classId] || 'Unknown'} | ${e.mana.toLocaleString()} |`);
    }
  }

  // Classes without mana
  const noMana = entries.filter(e => e.mana === 0);
  if (noMana.length > 0) {
    lines.push('', `**Non-caster classes (no mana):** ${noMana.map(e => CLASS_IDS[e.classId]).join(', ')}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL EFFECT OVERVIEW ============

export async function getSpellEffectOverview(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# EverQuest Spell Effect (SPA) Overview', ''];

  // Count spells per effect type using the pipe-separated effect field
  const effectCounts = new Map<number, number>();
  let totalEffects = 0;

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const seen = new Set<number>();

    // Find the effect field (pipe-separated, at end of fields array)
    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) {
        effectField = spell.fields[i];
        break;
      }
    }
    if (!effectField) continue;

    const slots = effectField.split('$');
    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length < 3) continue;
      const spa = parseInt(parts[1]);
      if (!isNaN(spa) && spa > 0 && !seen.has(spa)) {
        seen.add(spa);
        effectCounts.set(spa, (effectCounts.get(spa) || 0) + 1);
        totalEffects++;
      }
    }
  }

  lines.push(`**${effectCounts.size} distinct spell effects** across ${totalEffects.toLocaleString()} total effect slots`, '');

  // Sort by count descending
  const sorted = [...effectCounts.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('## Top 50 Most Common Effects', '');
  lines.push('| Rank | SPA | Effect Name | Spells |');
  lines.push('|------|-----|-------------|--------|');

  for (let i = 0; i < Math.min(50, sorted.length); i++) {
    const [spa, count] = sorted[i];
    const name = SPA_NAMES[spa] || `Unknown SPA ${spa}`;
    lines.push(`| ${i + 1} | ${spa} | ${name} | ${count.toLocaleString()} |`);
  }

  // Effect categories
  const categories: Record<string, number> = {
    'Stat Buffs (STR/DEX/AGI/STA/INT/WIS/CHA)': 0,
    'Resist Buffs (Fire/Cold/Poison/Disease/Magic)': 0,
    'HP/Mana/Endurance': 0,
    'Crowd Control (Stun/Mez/Charm/Fear)': 0,
    'Movement (Snare/Root/Levitate)': 0,
  };

  const statSPAs = [4, 5, 6, 7, 8, 9, 10];
  const resistSPAs = [46, 47, 48, 49, 50];
  const poolSPAs = [0, 15, 24, 34, 35, 69];
  const ccSPAs = [21, 74, 22, 23];
  const moveSPAs = [3, 31, 57];

  for (const spa of statSPAs) categories['Stat Buffs (STR/DEX/AGI/STA/INT/WIS/CHA)'] += effectCounts.get(spa) || 0;
  for (const spa of resistSPAs) categories['Resist Buffs (Fire/Cold/Poison/Disease/Magic)'] += effectCounts.get(spa) || 0;
  for (const spa of poolSPAs) categories['HP/Mana/Endurance'] += effectCounts.get(spa) || 0;
  for (const spa of ccSPAs) categories['Crowd Control (Stun/Mez/Charm/Fear)'] += effectCounts.get(spa) || 0;
  for (const spa of moveSPAs) categories['Movement (Snare/Root/Levitate)'] += effectCounts.get(spa) || 0;

  lines.push('', '## Effect Categories', '');
  lines.push('| Category | Total Spells |');
  lines.push('|----------|-------------|');
  for (const [cat, count] of Object.entries(categories)) {
    lines.push(`| ${cat} | ${count.toLocaleString()} |`);
  }

  // Rarest effects
  const rarest = sorted.filter(([, count]) => count <= 5).slice(0, 20);
  if (rarest.length > 0) {
    lines.push('', '## Rarest Effects (≤5 spells)', '');
    lines.push('| SPA | Effect Name | Spells |');
    lines.push('|-----|-------------|--------|');
    for (const [spa, count] of rarest) {
      const name = SPA_NAMES[spa] || `Unknown SPA ${spa}`;
      lines.push(`| ${spa} | ${name} | ${count} |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SKILL OVERVIEW ============

export async function getSkillOverview(): Promise<string> {
  await loadSkillCaps();
  if (!skillCaps || skillCaps.length === 0) return 'Skill cap data not available.';

  const lines = ['# EverQuest Skill Overview', ''];

  // Build skill -> classes map at max level (125)
  const skillClasses = new Map<number, Map<number, number>>(); // skillId -> classId -> cap

  for (const entry of skillCaps) {
    if (entry.level !== 125 || entry.cap <= 0) continue;
    if (!skillClasses.has(entry.skillId)) skillClasses.set(entry.skillId, new Map());
    skillClasses.get(entry.skillId)!.set(entry.classId, entry.cap);
  }

  const sortedSkills = [...skillClasses.entries()].sort((a, b) => a[0] - b[0]);

  lines.push(`**${sortedSkills.length} skills** at level 125`, '');

  // Combat skills
  const combatSkillIds = [0, 1, 2, 3, 36, 77, 7, 8, 10, 11, 15, 16, 19, 20, 22, 23, 26, 28, 30, 33, 34, 37, 38, 52, 73, 74, 76, 21];
  const magicSkillIds = [4, 5, 13, 14, 18, 24, 31, 43, 44, 45, 46, 47];
  const bardSkillIds = [12, 41, 49, 54, 70];
  const rogueSkillIds = [6, 9, 17, 25, 29, 35, 42, 48, 56, 62, 64, 65, 71, 75];

  const classHeaders = Object.entries(CLASS_IDS).slice(0, 16).map(([, name]) => name.substring(0, 3).toUpperCase());

  lines.push('## Combat Skills', '');
  lines.push('| Skill | ' + classHeaders.join(' | ') + ' |');
  lines.push('|-------|' + classHeaders.map(() => '---').join('|') + '|');

  for (const [skillId, classMap] of sortedSkills) {
    if (!combatSkillIds.includes(skillId)) continue;
    const skillName = SKILL_NAMES[skillId] || `Skill ${skillId}`;
    const caps = [];
    for (let c = 1; c <= 16; c++) {
      const cap = classMap.get(c);
      caps.push(cap ? String(cap) : '-');
    }
    lines.push(`| ${skillName} | ${caps.join(' | ')} |`);
  }

  lines.push('', '## Magic Skills', '');
  lines.push('| Skill | ' + classHeaders.join(' | ') + ' |');
  lines.push('|-------|' + classHeaders.map(() => '---').join('|') + '|');

  for (const [skillId, classMap] of sortedSkills) {
    if (!magicSkillIds.includes(skillId)) continue;
    const skillName = SKILL_NAMES[skillId] || `Skill ${skillId}`;
    const caps = [];
    for (let c = 1; c <= 16; c++) {
      const cap = classMap.get(c);
      caps.push(cap ? String(cap) : '-');
    }
    lines.push(`| ${skillName} | ${caps.join(' | ')} |`);
  }

  // Summary: how many skills per class
  lines.push('', '## Skills Per Class', '');
  lines.push('| Class | Total Skills | Avg Cap |');
  lines.push('|-------|-------------|---------|');

  for (let c = 1; c <= 16; c++) {
    let totalSkills = 0;
    let totalCap = 0;
    for (const [, classMap] of sortedSkills) {
      const cap = classMap.get(c);
      if (cap && cap > 0) {
        totalSkills++;
        totalCap += cap;
      }
    }
    const avg = totalSkills > 0 ? Math.round(totalCap / totalSkills) : 0;
    lines.push(`| ${CLASS_IDS[c]} | ${totalSkills} | ${avg} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL GROWTH CURVE ============

export async function getSpellGrowthCurve(className: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const classIndex = classId - 1;

  // Count spells at each level
  const spellsByLevel = new Map<number, number>();
  let totalSpells = 0;

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
    if (isNaN(classLevel) || classLevel > 254 || classLevel <= 0) continue;

    spellsByLevel.set(classLevel, (spellsByLevel.get(classLevel) || 0) + 1);
    totalSpells++;
  }

  if (totalSpells === 0) return `No spells found for ${CLASS_IDS[classId]}.`;

  const lines = [`# ${CLASS_IDS[classId]} Spell Growth Curve`, ''];
  lines.push(`**${totalSpells} total spells** across ${spellsByLevel.size} different levels`, '');

  // Major spell gain levels (top 10)
  const sortedByCount = [...spellsByLevel.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('## Top 10 Spell Gain Levels', '');
  lines.push('| Rank | Level | New Spells |');
  lines.push('|------|-------|-----------|');
  for (let i = 0; i < Math.min(10, sortedByCount.length); i++) {
    lines.push(`| ${i + 1} | ${sortedByCount[i][0]} | ${sortedByCount[i][1]} |`);
  }

  // Growth by 5-level brackets
  const maxLevel = Math.max(...spellsByLevel.keys());
  lines.push('', '## Spells by Level Bracket', '');
  lines.push('| Bracket | New Spells | Cumulative | Bar |');
  lines.push('|---------|-----------|------------|-----|');

  let cumulative = 0;
  const brackets: { label: string; count: number; cum: number }[] = [];

  for (let start = 1; start <= maxLevel; start += 5) {
    let bracketCount = 0;
    for (let lvl = start; lvl < start + 5; lvl++) {
      bracketCount += spellsByLevel.get(lvl) || 0;
    }
    cumulative += bracketCount;
    brackets.push({ label: `${start}-${start + 4}`, count: bracketCount, cum: cumulative });
  }

  const maxCount = Math.max(...brackets.map(b => b.count));
  for (const b of brackets) {
    if (b.count === 0) continue;
    const barLen = Math.max(1, Math.round((b.count / maxCount) * 20));
    const bar = '█'.repeat(barLen);
    lines.push(`| ${b.label} | ${b.count} | ${b.cum} | ${bar} |`);
  }

  // Dry spell analysis (longest gap between new spells)
  const allLevels = [...spellsByLevel.keys()].sort((a, b) => a - b);
  let maxGap = 0;
  let gapStart = 0;
  let gapEnd = 0;
  for (let i = 1; i < allLevels.length; i++) {
    const gap = allLevels[i] - allLevels[i - 1];
    if (gap > maxGap) {
      maxGap = gap;
      gapStart = allLevels[i - 1];
      gapEnd = allLevels[i];
    }
  }

  if (maxGap > 1) {
    lines.push('', `**Longest dry spell:** Levels ${gapStart + 1}-${gapEnd - 1} (${maxGap - 1} levels with no new spells)`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: RACE STAT COMPARISON ============

export async function getRaceStatComparison(): Promise<string> {
  const lines = ['# All Races Starting Stat Comparison', ''];

  const raceIds = Object.keys(RACE_BASE_STATS).map(Number);

  lines.push('| Race | STR | STA | AGI | DEX | WIS | INT | CHA | Total |');
  lines.push('|------|-----|-----|-----|-----|-----|-----|-----|-------|');

  const raceData: { id: number; name: string; stats: number[]; total: number }[] = [];

  for (const raceId of raceIds) {
    const stats = RACE_BASE_STATS[raceId];
    if (!stats) continue;
    const total = stats.reduce((a, b) => a + b, 0);
    raceData.push({ id: raceId, name: RACE_IDS[raceId] || `Race ${raceId}`, stats, total });
  }

  // Sort by total stats
  raceData.sort((a, b) => b.total - a.total);

  for (const r of raceData) {
    lines.push(`| ${r.name} | ${r.stats.join(' | ')} | ${r.total} |`);
  }

  // Per-stat rankings
  lines.push('', '## Best Race by Stat', '');
  lines.push('| Stat | #1 | #2 | #3 |');
  lines.push('|------|----|----|-----|');

  for (let s = 0; s < STAT_NAMES.length; s++) {
    const ranked = [...raceData].sort((a, b) => b.stats[s] - a.stats[s]);
    lines.push(`| ${STAT_NAMES[s]} | ${ranked[0].name} (${ranked[0].stats[s]}) | ${ranked[1].name} (${ranked[1].stats[s]}) | ${ranked[2].name} (${ranked[2].stats[s]}) |`);
  }

  // Stat spread analysis
  lines.push('', '## Stat Spread', '');
  for (let s = 0; s < STAT_NAMES.length; s++) {
    const values = raceData.map(r => r.stats[s]);
    const min = Math.min(...values);
    const max = Math.max(...values);
    lines.push(`- **${STAT_NAMES[s]}:** ${min}–${max} (spread: ${max - min})`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: DEITY OVERVIEW ============

export async function getDeityOverview(): Promise<string> {
  await loadRaceClassInfo();

  const lines = ['# EverQuest Deity Overview', ''];

  // Collect all unique deities
  const deityRaces = new Map<string, Set<number>>();  // deity -> set of raceIds
  const deityClasses = new Map<string, Set<number>>(); // deity -> set of classIds

  for (const [raceIdStr, deities] of Object.entries(RACE_DEITIES)) {
    const raceId = parseInt(raceIdStr);
    const raceClasses = RACE_CLASSES[raceId] || [];
    for (const deity of deities) {
      if (!deityRaces.has(deity)) deityRaces.set(deity, new Set());
      if (!deityClasses.has(deity)) deityClasses.set(deity, new Set());
      deityRaces.get(deity)!.add(raceId);
      for (const cls of raceClasses) {
        deityClasses.get(deity)!.add(cls);
      }
    }
  }

  const sortedDeities = [...deityRaces.keys()].sort();
  lines.push(`**${sortedDeities.length} deities** in EverQuest`, '');

  lines.push('| Deity | Races | Classes | Race Names |');
  lines.push('|-------|-------|---------|------------|');

  for (const deity of sortedDeities) {
    const races = deityRaces.get(deity)!;
    const classes = deityClasses.get(deity)!;
    const raceNames = [...races].map(id => RACE_IDS[id]).filter(Boolean).join(', ');
    lines.push(`| ${deity} | ${races.size} | ${classes.size} | ${raceNames} |`);
  }

  // Most accessible deities
  const byAccess = sortedDeities.sort((a, b) => deityRaces.get(b)!.size - deityRaces.get(a)!.size);
  lines.push('', '## Most Accessible Deities', '');
  lines.push(`- **Most races:** ${byAccess[0]} (${deityRaces.get(byAccess[0])!.size} races)`);
  lines.push(`- **Fewest races:** ${byAccess[byAccess.length - 1]} (${deityRaces.get(byAccess[byAccess.length - 1])!.size} races)`);

  // Agnostic info
  if (deityRaces.has('Agnostic')) {
    const agnosticRaces = [...deityRaces.get('Agnostic')!].map(id => RACE_IDS[id]).filter(Boolean);
    lines.push('', `**Agnostic option available for:** ${agnosticRaces.join(', ')} (${agnosticRaces.length} races)`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS COMPARISON MATRIX ============

export async function getClassComparisonMatrix(): Promise<string> {
  await loadSpells();
  await loadSkillCaps();
  await loadBaseStats();

  const lines = ['# Class Comparison Matrix', ''];

  const classData: {
    id: number;
    name: string;
    spellCount: number;
    beneficialPct: number;
    skillCount: number;
    maxHP: number;
    maxMana: number;
    hasPet: boolean;
  }[] = [];

  for (let classId = 1; classId <= 16; classId++) {
    const classIndex = classId - 1;
    let spellCount = 0;
    let beneficial = 0;
    // Known permanent pet classes
    const PET_CLASS_IDS = new Set([5, 10, 11, 13, 14, 15]); // SK, SHA, NEC, MAG, ENC, BST
    const hasPet = PET_CLASS_IDS.has(classId);

    if (spells) {
      for (const [, spell] of spells) {
        const classLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]);
        if (isNaN(classLevel) || classLevel > 254 || classLevel <= 0) continue;
        spellCount++;
        if (spell.fields[SF.BENEFICIAL] === '1') beneficial++;
      }
    }

    let skillCount = 0;
    if (skillCaps) {
      const caps = new Set<number>();
      for (const entry of skillCaps) {
        if (entry.classId === classId && entry.level === 125 && entry.cap > 0) caps.add(entry.skillId);
      }
      skillCount = caps.size;
    }

    let maxHP = 0;
    let maxMana = 0;
    if (baseStats) {
      const entry = baseStats.find(e => e.classId === classId && e.level === 125);
      if (entry) {
        maxHP = entry.hp;
        maxMana = entry.mana;
      }
    }

    classData.push({
      id: classId,
      name: CLASS_IDS[classId],
      spellCount,
      beneficialPct: spellCount > 0 ? Math.round((beneficial / spellCount) * 100) : 0,
      skillCount,
      maxHP,
      maxMana,
      hasPet,
    });
  }

  lines.push('| Class | Spells | Beneficial% | Skills | Base HP | Base Mana | Has Pet |');
  lines.push('|-------|--------|------------|--------|---------|-----------|---------|');

  for (const c of classData) {
    lines.push(`| ${c.name} | ${c.spellCount.toLocaleString()} | ${c.beneficialPct}% | ${c.skillCount} | ${c.maxHP.toLocaleString()} | ${c.maxMana.toLocaleString()} | ${c.hasPet ? 'Yes' : 'No'} |`);
  }

  // Rankings
  lines.push('', '## Rankings', '');

  const bySpells = [...classData].sort((a, b) => b.spellCount - a.spellCount);
  lines.push(`**Most spells:** ${bySpells[0].name} (${bySpells[0].spellCount.toLocaleString()})`);

  const bySkills = [...classData].sort((a, b) => b.skillCount - a.skillCount);
  lines.push(`**Most skills:** ${bySkills[0].name} (${bySkills[0].skillCount})`);

  const byBeneficial = [...classData].filter(c => c.spellCount > 0).sort((a, b) => b.beneficialPct - a.beneficialPct);
  lines.push(`**Most beneficial:** ${byBeneficial[0].name} (${byBeneficial[0].beneficialPct}%)`);
  lines.push(`**Most detrimental:** ${byBeneficial[byBeneficial.length - 1].name} (${100 - byBeneficial[byBeneficial.length - 1].beneficialPct}% detrimental)`);

  const byHP = [...classData].sort((a, b) => b.maxHP - a.maxHP);
  lines.push(`**Highest base HP (125):** ${byHP[0].name} (${byHP[0].maxHP.toLocaleString()})`);

  const petClasses = classData.filter(c => c.hasPet).map(c => c.name);
  if (petClasses.length > 0) {
    lines.push(`**Pet classes:** ${petClasses.join(', ')}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: EXPANSION TIMELINE ============

export async function getExpansionTimeline(): Promise<string> {
  await loadExpansions();
  await loadFactions();
  await loadAchievementCategories();

  if (!expansionNames || expansionNames.size === 0) return 'Expansion data not available.';

  const lines = ['# EverQuest Expansion Timeline', ''];

  const sorted = [...expansionNames.entries()].sort((a, b) => a[0] - b[0]);

  lines.push('| # | Expansion | Factions | Achievements |');
  lines.push('|---|-----------|----------|-------------|');

  for (const [id, name] of sorted) {
    // Count factions for this expansion
    let factionCount = 0;
    if (factions) {
      const lowerName = name.toLowerCase();
      for (const [, faction] of factions) {
        if (faction.category && faction.category.toLowerCase().includes(lowerName)) {
          factionCount++;
        }
      }
    }

    // Count achievements for this expansion
    let achievementCount = 0;
    if (achievementCategories) {
      for (const [, cat] of achievementCategories) {
        if (cat.name.toLowerCase().includes(name.toLowerCase())) {
          // Count achievements in this category and subcategories
          if (categoryToAchievements) {
            const achIds = categoryToAchievements.get(cat.id);
            if (achIds) achievementCount += achIds.length;
            // Also count subcategory achievements
            for (const [, subCat] of achievementCategories) {
              if (subCat.parentId === cat.id) {
                const subAchIds = categoryToAchievements.get(subCat.id);
                if (subAchIds) achievementCount += subAchIds.length;
              }
            }
          }
        }
      }
    }

    lines.push(`| ${id} | ${name} | ${factionCount || '-'} | ${achievementCount || '-'} |`);
  }

  // Summary stats
  let totalFactions = factions ? factions.size : 0;
  let totalAchievements = 0;
  if (achievements) totalAchievements = achievements.size;

  lines.push('', '## Totals', '');
  lines.push(`- **Expansions:** ${sorted.length}`);
  if (totalFactions > 0) lines.push(`- **Total factions:** ${totalFactions.toLocaleString()}`);
  if (totalAchievements > 0) lines.push(`- **Total achievements:** ${totalAchievements.toLocaleString()}`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL ENDURANCE SEARCH ============

export async function searchSpellsByEndurance(className: string, maxEndurance?: number, minEndurance?: number): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const matches: { name: string; level: number; endurance: number; category: string; beneficial: boolean; castTime: number; recastTime: number }[] = [];

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const endurance = parseInt(spell.fields[SF.ENDURANCE]) || 0;
    if (endurance <= 0) continue; // Only endurance-cost abilities

    if (maxEndurance !== undefined && endurance > maxEndurance) continue;
    if (minEndurance !== undefined && endurance < minEndurance) continue;

    const name = spell.fields[SF.NAME];
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    const recastTime = parseInt(spell.fields[SF.RECAST_TIME]) || 0;

    matches.push({ name, level, endurance, category, beneficial, castTime, recastTime });
  }

  if (matches.length === 0) {
    const rangeDesc = maxEndurance !== undefined && minEndurance !== undefined
      ? `${minEndurance}-${maxEndurance}`
      : maxEndurance !== undefined ? `≤${maxEndurance}` : minEndurance !== undefined ? `≥${minEndurance}` : 'any';
    return `No ${classFullName} endurance abilities with cost ${rangeDesc}.`;
  }

  matches.sort((a, b) => b.endurance - a.endurance || a.level - b.level);

  const rangeDesc = maxEndurance !== undefined && minEndurance !== undefined
    ? `${minEndurance}-${maxEndurance}`
    : maxEndurance !== undefined ? `≤${maxEndurance}` : minEndurance !== undefined ? `≥${minEndurance}` : 'all';

  const lines = [`# ${classFullName} Endurance Abilities — Cost ${rangeDesc}`, ''];
  lines.push(`**${matches.length} abilities found**`, '');

  const shown = matches.slice(0, 100);
  lines.push('| Endurance | Level | Ability | Category | Cast Time | Recast |');
  lines.push('|-----------|-------|---------|----------|-----------|--------|');

  for (const s of shown) {
    const castStr = s.castTime === 0 ? 'Instant' : `${(s.castTime / 1000).toFixed(1)}s`;
    const recastStr = s.recastTime === 0 ? '-' : `${(s.recastTime / 1000).toFixed(1)}s`;
    lines.push(`| ${s.endurance} | ${s.level} | ${s.name} | ${s.category} | ${castStr} | ${recastStr} |`);
  }

  if (matches.length > 100) {
    lines.push('', `*Showing first 100 of ${matches.length}. Narrow your search.*`);
  }

  // Summary
  const totalEnd = matches.reduce((sum, m) => sum + m.endurance, 0);
  const avgEnd = Math.round(totalEnd / matches.length);
  const maxEnd = matches[0].endurance;
  const minEnd = matches[matches.length - 1].endurance;

  lines.push('', '## Summary', '');
  lines.push(`- **Total abilities:** ${matches.length}`);
  lines.push(`- **Endurance range:** ${minEnd} - ${maxEnd}`);
  lines.push(`- **Average cost:** ${avgEnd}`);

  // Category breakdown
  const catCounts = new Map<string, number>();
  for (const m of matches) {
    catCounts.set(m.category, (catCounts.get(m.category) || 0) + 1);
  }
  const sortedCats = [...catCounts.entries()].sort((a, b) => b[1] - a[1]);
  if (sortedCats.length > 1) {
    lines.push('', '**By category:**');
    for (const [cat, count] of sortedCats.slice(0, 10)) {
      lines.push(`- ${cat}: ${count}`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: AC MITIGATION COMPARISON ============

export async function getACMitigationComparison(level?: number): Promise<string> {
  await loadACMitigation();
  if (!acMitigation || acMitigation.length === 0) return 'AC mitigation data not available.';

  const targetLevel = level ?? 125;

  const classEntries: { classId: number; name: string; acCap: number; multiplier: number }[] = [];

  for (let classId = 1; classId <= 16; classId++) {
    const entry = acMitigation.find(e => e.classId === classId && e.level === targetLevel);
    if (entry) {
      classEntries.push({
        classId,
        name: CLASS_IDS[classId],
        acCap: entry.acCap,
        multiplier: entry.softCapMultiplier,
      });
    }
  }

  if (classEntries.length === 0) {
    return `No AC mitigation data found for level ${targetLevel}. Try a different level (1-125).`;
  }

  // Sort by AC cap descending
  classEntries.sort((a, b) => b.acCap - a.acCap);

  const lines = [`# AC Mitigation Comparison — Level ${targetLevel}`, ''];
  lines.push('AC Soft Cap is where additional AC returns diminish. Above the cap, each point of AC is worth (Soft Cap Multiplier) of its normal value.', '');

  lines.push('| Rank | Class | AC Soft Cap | Soft Cap Mult | Effective Tier |');
  lines.push('|------|-------|-------------|---------------|----------------|');

  for (let i = 0; i < classEntries.length; i++) {
    const c = classEntries[i];
    const multPct = (c.multiplier * 100).toFixed(0) + '%';
    // Tier assignment based on AC cap ranges
    let tier = 'Light';
    if (c.acCap >= classEntries[0].acCap * 0.9) tier = 'Plate';
    else if (c.acCap >= classEntries[0].acCap * 0.7) tier = 'Chain';
    else if (c.acCap >= classEntries[0].acCap * 0.5) tier = 'Leather';
    lines.push(`| ${i + 1} | ${c.name} | ${c.acCap.toLocaleString()} | ${multPct} | ${tier} |`);
  }

  // Rankings
  lines.push('', '## Analysis', '');

  const highest = classEntries[0];
  const lowest = classEntries[classEntries.length - 1];
  lines.push(`**Highest AC cap:** ${highest.name} (${highest.acCap.toLocaleString()})`);
  lines.push(`**Lowest AC cap:** ${lowest.name} (${lowest.acCap.toLocaleString()})`);
  lines.push(`**Spread:** ${(highest.acCap - lowest.acCap).toLocaleString()} AC (${((highest.acCap / lowest.acCap - 1) * 100).toFixed(0)}% difference)`);

  // Group by tier
  const tiers: Record<string, string[]> = { 'Plate': [], 'Chain': [], 'Leather': [], 'Light': [] };
  for (const c of classEntries) {
    let tier = 'Light';
    if (c.acCap >= classEntries[0].acCap * 0.9) tier = 'Plate';
    else if (c.acCap >= classEntries[0].acCap * 0.7) tier = 'Chain';
    else if (c.acCap >= classEntries[0].acCap * 0.5) tier = 'Leather';
    tiers[tier].push(c.name);
  }
  lines.push('', '**Armor tiers:**');
  for (const [tier, classes] of Object.entries(tiers)) {
    if (classes.length > 0) {
      lines.push(`- **${tier}:** ${classes.join(', ')}`);
    }
  }

  // Multiplier analysis
  const byMult = [...classEntries].sort((a, b) => b.multiplier - a.multiplier);
  lines.push('', `**Best soft cap multiplier:** ${byMult[0].name} (${(byMult[0].multiplier * 100).toFixed(0)}%)`);
  lines.push(`**Worst soft cap multiplier:** ${byMult[byMult.length - 1].name} (${(byMult[byMult.length - 1].multiplier * 100).toFixed(0)}%)`);

  return lines.join('\n');
}

// ============ PUBLIC API: TRIBUTE OVERVIEW ============

export async function getTributeOverview(): Promise<string> {
  await loadTributes();
  if (!tributes || tributes.size === 0) return 'Tribute data not available.';

  const personal: TributeEntry[] = [];
  const guild: TributeEntry[] = [];

  for (const tribute of tributes.values()) {
    if (tribute.isGuild) {
      guild.push(tribute);
    } else {
      personal.push(tribute);
    }
  }

  const lines = ['# Tribute System Overview', ''];

  lines.push(`- **Personal tributes:** ${personal.length}`);
  lines.push(`- **Guild tributes:** ${guild.length}`);
  lines.push(`- **Total:** ${tributes.size}`);

  // Personal tributes sorted alphabetically
  lines.push('', '## Personal Tributes', '');
  personal.sort((a, b) => a.name.localeCompare(b.name));

  lines.push('| # | Tribute | Description |');
  lines.push('|---|---------|-------------|');

  for (let i = 0; i < personal.length; i++) {
    const desc = personal[i].description.length > 80
      ? personal[i].description.substring(0, 80) + '...'
      : personal[i].description;
    lines.push(`| ${i + 1} | ${personal[i].name} | ${desc} |`);
  }

  // Guild tributes
  if (guild.length > 0) {
    lines.push('', '## Guild Tributes', '');
    guild.sort((a, b) => a.name.localeCompare(b.name));

    lines.push('| # | Tribute | Description |');
    lines.push('|---|---------|-------------|');

    for (let i = 0; i < guild.length; i++) {
      const desc = guild[i].description.length > 80
        ? guild[i].description.substring(0, 80) + '...'
        : guild[i].description;
      lines.push(`| ${i + 1} | ${guild[i].name} | ${desc} |`);
    }
  }

  // Word frequency in tribute descriptions for common themes
  const wordCounts = new Map<string, number>();
  const stopWords = new Set(['the', 'a', 'an', 'of', 'to', 'in', 'for', 'and', 'or', 'is', 'by', 'on', 'at', 'with', 'your', 'you', 'this', 'that', 'it', 'from', 'are', 'be', 'has', 'was', 'will', 'can', 'all', 'as', 'not', 'but', 'its', 'per', 'been', 'each']);
  for (const tribute of tributes.values()) {
    const words = tribute.description.toLowerCase().split(/\W+/);
    for (const word of words) {
      if (word.length > 3 && !stopWords.has(word)) {
        wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
      }
    }
  }
  const topWords = [...wordCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 15);
  if (topWords.length > 0) {
    lines.push('', '## Common Tribute Themes', '');
    for (const [word, count] of topWords) {
      lines.push(`- **${word}:** mentioned in ${count} tributes`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: STARTING CITY LORE ============

export async function getStartingCityLore(): Promise<string> {
  await loadStartingCityLore();
  await loadRaceClassInfo();
  if (!startingCityLore || startingCityLore.size === 0) return 'Starting city lore data not available.';

  const lines = ['# Starting City Lore', ''];
  lines.push(`**${startingCityLore.size} starting city descriptions available**`, '');

  // Build city ID to name mapping from race data
  // City IDs from dbstr type 15 correspond to starting cities
  const sorted = [...startingCityLore.entries()].sort((a, b) => a[0] - b[0]);

  for (const [id, text] of sorted) {
    const cleanText = text.replace(/\r/g, '').trim();
    lines.push(`## City ID ${id}`, '');
    lines.push(cleanText);
    lines.push('');
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CREATURE TYPE OVERVIEW ============

export async function getCreatureTypeOverview(): Promise<string> {
  await loadCreatureTypes();
  if (!creatureTypes || creatureTypes.size === 0) return 'Creature type data not available.';

  const lines = ['# Creature/NPC Race Type Overview', ''];
  lines.push(`**${creatureTypes.size} creature race types defined**`, '');

  // Alphabetical grouping
  const byLetter = new Map<string, string[]>();
  for (const [, name] of creatureTypes) {
    const letter = name.charAt(0).toUpperCase();
    if (!byLetter.has(letter)) byLetter.set(letter, []);
    byLetter.get(letter)!.push(name);
  }

  const sortedLetters = [...byLetter.keys()].sort();
  lines.push('## By First Letter', '');
  lines.push('| Letter | Count | Examples |');
  lines.push('|--------|-------|----------|');

  for (const letter of sortedLetters) {
    const names = byLetter.get(letter)!.sort();
    const examples = names.slice(0, 5).join(', ');
    const more = names.length > 5 ? `, ... (+${names.length - 5})` : '';
    lines.push(`| ${letter} | ${names.length} | ${examples}${more} |`);
  }

  // Common word analysis
  const wordCounts = new Map<string, number>();
  for (const [, name] of creatureTypes) {
    const words = name.toLowerCase().split(/[\s_]+/);
    for (const word of words) {
      if (word.length > 2) {
        wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
      }
    }
  }
  const topWords = [...wordCounts.entries()]
    .filter(([, c]) => c >= 3)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 25);

  if (topWords.length > 0) {
    lines.push('', '## Most Common Name Words', '');
    for (const [word, count] of topWords) {
      lines.push(`- **${word}:** ${count} types`);
    }
  }

  // Name length statistics
  const lengths = [...creatureTypes.values()].map(n => n.length);
  lengths.sort((a, b) => a - b);
  const avgLen = Math.round(lengths.reduce((s, l) => s + l, 0) / lengths.length);
  const shortest = [...creatureTypes.entries()].sort((a, b) => a[1].length - b[1].length).slice(0, 5);
  const longest = [...creatureTypes.entries()].sort((a, b) => b[1].length - a[1].length).slice(0, 5);

  lines.push('', '## Name Statistics', '');
  lines.push(`- **Average name length:** ${avgLen} characters`);
  lines.push(`- **Shortest:** ${shortest.map(([, n]) => `"${n}"`).join(', ')}`);
  lines.push(`- **Longest:** ${longest.map(([, n]) => `"${n}"`).join(', ')}`);

  // ID range analysis
  const ids = [...creatureTypes.keys()].sort((a, b) => a - b);
  lines.push('', '## ID Range', '');
  lines.push(`- **Lowest ID:** ${ids[0]}`);
  lines.push(`- **Highest ID:** ${ids[ids.length - 1]}`);
  lines.push(`- **ID span:** ${ids[ids.length - 1] - ids[0] + 1} (${((creatureTypes.size / (ids[ids.length - 1] - ids[0] + 1)) * 100).toFixed(1)}% density)`);

  return lines.join('\n');
}

// ============ PUBLIC API: OVERSEER JOB OVERVIEW ============

export async function getOverseerJobOverview(): Promise<string> {
  await loadOverseerEnhancements();
  await loadOverseerMinions();

  const lines = ['# Overseer System Overview', ''];

  // Jobs
  if (overseerJobNames && overseerJobNames.size > 0) {
    const jobs = [...overseerJobNames.entries()].sort((a, b) => a[0] - b[0]);
    lines.push(`## Jobs (${jobs.length})`, '');
    lines.push('| ID | Job Name |');
    lines.push('|----|----------|');
    for (const [id, name] of jobs) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  // Archetypes
  if (overseerArchetypeNames && overseerArchetypeNames.size > 0) {
    const archetypes = [...overseerArchetypeNames.entries()].sort((a, b) => a[0] - b[0]);
    lines.push('', `## Archetypes (${archetypes.length})`, '');
    lines.push('| ID | Archetype |');
    lines.push('|----|-----------|');
    for (const [id, name] of archetypes) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  // Categories
  if (overseerCategories && overseerCategories.size > 0) {
    const cats = [...overseerCategories.entries()].sort((a, b) => a[0] - b[0]);
    lines.push('', `## Quest Categories (${cats.length})`, '');
    for (const [id, name] of cats) {
      lines.push(`- **${name}** (ID: ${id})`);
    }
  }

  // Difficulties
  if (overseerDifficulties && overseerDifficulties.size > 0) {
    const diffs = [...overseerDifficulties.entries()].sort((a, b) => a[0] - b[0]);
    lines.push('', `## Difficulty Levels (${diffs.length})`, '');
    for (const [id, name] of diffs) {
      lines.push(`- **${name}** (ID: ${id})`);
    }
  }

  // Job class descriptions
  if (overseerJobClassDescs && overseerJobClassDescs.size > 0) {
    const descs = [...overseerJobClassDescs.entries()].sort((a, b) => a[0] - b[0]);
    lines.push('', `## Job Class Descriptions (${descs.length})`, '');
    for (const [id, desc] of descs.slice(0, 30)) {
      const shortDesc = desc.length > 100 ? desc.substring(0, 100) + '...' : desc;
      lines.push(`- **ID ${id}:** ${shortDesc}`);
    }
    if (descs.length > 30) {
      lines.push(`- ... and ${descs.length - 30} more`);
    }
  }

  // Trait descriptions
  if (overseerTraitDescs && overseerTraitDescs.size > 0) {
    lines.push('', `## Traits (${overseerTraitDescs.size})`, '');
    const traits = [...overseerTraitDescs.entries()].sort((a, b) => a[0] - b[0]);
    for (const [id, desc] of traits.slice(0, 30)) {
      const shortDesc = desc.length > 80 ? desc.substring(0, 80) + '...' : desc;
      lines.push(`- **ID ${id}:** ${shortDesc}`);
    }
    if (traits.length > 30) {
      lines.push(`- ... and ${traits.length - 30} more`);
    }
  }

  // Minion count summary
  if (overseerMinions && overseerMinions.size > 0) {
    lines.push('', '## Minion Summary', '');
    lines.push(`- **Total minions:** ${overseerMinions.size}`);

    // Count by rarity
    const rarityCounts = new Map<number, number>();
    for (const minion of overseerMinions.values()) {
      rarityCounts.set(minion.rarity, (rarityCounts.get(minion.rarity) || 0) + 1);
    }
    const rarityNames: Record<number, string> = { 1: 'Common', 2: 'Uncommon', 3: 'Rare', 4: 'Elite', 5: 'Legendary' };
    const sortedRarities = [...rarityCounts.entries()].sort((a, b) => a[0] - b[0]);
    for (const [rarity, count] of sortedRarities) {
      lines.push(`- **${rarityNames[rarity] || `Rarity ${rarity}`}:** ${count} minions`);
    }
  }

  // Incapacitation summary
  if (overseerIncapNames && overseerIncapNames.size > 0) {
    lines.push('', `## Incapacitations (${overseerIncapNames.size})`, '');
    const incaps = [...overseerIncapNames.entries()].sort((a, b) => a[0] - b[0]);
    for (const [id, name] of incaps) {
      const desc = overseerIncapDescs?.get(id);
      const dur = overseerIncapDurations?.get(id);
      let extra = '';
      if (dur) extra += ` (${Math.round(dur.duration / 3600)}h)`;
      if (desc) extra += ` — ${desc.substring(0, 60)}`;
      lines.push(`- **${name}**${extra}`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL RESIST TYPE OVERVIEW ============

export async function getSpellResistOverview(className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classId: number | undefined;
  let classFullName = 'All Classes';
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classFullName = CLASS_IDS[classId];
  }

  // Count spells by resist type, optionally filtered by class
  const resistCounts: Record<number, { total: number; beneficial: number; detrimental: number }> = {};

  for (const spell of spells.values()) {
    if (classId) {
      const classIndex = classId - 1;
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
      if (level <= 0 || level >= 255) continue;
    }

    const resistType = parseInt(spell.fields[SF.RESIST_TYPE]) || 0;
    if (!resistCounts[resistType]) resistCounts[resistType] = { total: 0, beneficial: 0, detrimental: 0 };
    resistCounts[resistType].total++;
    if (spell.fields[SF.BENEFICIAL] === '1') {
      resistCounts[resistType].beneficial++;
    } else {
      resistCounts[resistType].detrimental++;
    }
  }

  const lines = [`# Spell Resist Type Overview — ${classFullName}`, ''];

  const sorted = Object.entries(resistCounts)
    .map(([rt, counts]) => ({
      id: parseInt(rt),
      name: RESIST_TYPES[parseInt(rt)] || `Unknown (${rt})`,
      ...counts
    }))
    .sort((a, b) => b.total - a.total);

  const grandTotal = sorted.reduce((s, r) => s + r.total, 0);
  lines.push(`**${grandTotal.toLocaleString()} total spells analyzed**`, '');

  lines.push('| Resist Type | Total | % | Beneficial | Detrimental |');
  lines.push('|-------------|-------|---|------------|-------------|');

  for (const r of sorted) {
    const pct = ((r.total / grandTotal) * 100).toFixed(1);
    lines.push(`| ${r.name} | ${r.total.toLocaleString()} | ${pct}% | ${r.beneficial.toLocaleString()} | ${r.detrimental.toLocaleString()} |`);
  }

  // Which resist types are most commonly detrimental vs beneficial
  lines.push('', '## Analysis', '');

  const detrimentalResists = sorted
    .filter(r => r.detrimental > 0 && r.id > 0)
    .sort((a, b) => b.detrimental - a.detrimental);

  if (detrimentalResists.length > 0) {
    lines.push('**Most resisted spell types (detrimental only):**');
    for (const r of detrimentalResists.slice(0, 5)) {
      const detrPct = ((r.detrimental / r.total) * 100).toFixed(0);
      lines.push(`- ${r.name}: ${r.detrimental.toLocaleString()} detrimental spells (${detrPct}% of ${r.name} spells)`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL TARGET TYPE OVERVIEW ============

export async function getSpellTargetOverview(className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classId: number | undefined;
  let classFullName = 'All Classes';
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classFullName = CLASS_IDS[classId];
  }

  const targetCounts: Record<number, { total: number; beneficial: number; detrimental: number }> = {};

  for (const spell of spells.values()) {
    if (classId) {
      const classIndex = classId - 1;
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
      if (level <= 0 || level >= 255) continue;
    }

    const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    if (!targetCounts[targetType]) targetCounts[targetType] = { total: 0, beneficial: 0, detrimental: 0 };
    targetCounts[targetType].total++;
    if (spell.fields[SF.BENEFICIAL] === '1') {
      targetCounts[targetType].beneficial++;
    } else {
      targetCounts[targetType].detrimental++;
    }
  }

  const lines = [`# Spell Target Type Overview — ${classFullName}`, ''];

  const sorted = Object.entries(targetCounts)
    .map(([tt, counts]) => ({
      id: parseInt(tt),
      name: TARGET_TYPES[parseInt(tt)] || `Type ${tt}`,
      ...counts
    }))
    .sort((a, b) => b.total - a.total);

  const grandTotal = sorted.reduce((s, r) => s + r.total, 0);
  lines.push(`**${grandTotal.toLocaleString()} total spells analyzed**`, '');

  lines.push('| Target Type | Total | % | Beneficial | Detrimental |');
  lines.push('|-------------|-------|---|------------|-------------|');

  for (const t of sorted) {
    const pct = ((t.total / grandTotal) * 100).toFixed(1);
    lines.push(`| ${t.name} | ${t.total.toLocaleString()} | ${pct}% | ${t.beneficial.toLocaleString()} | ${t.detrimental.toLocaleString()} |`);
  }

  // Categorize target types
  lines.push('', '## Target Type Categories', '');

  const aoeTargets = sorted.filter(t => [2, 4, 8, 40, 42, 44, 46].includes(t.id));
  const singleTargets = sorted.filter(t => [1, 5, 9, 10, 13].includes(t.id));
  const selfTargets = sorted.filter(t => [6].includes(t.id));
  const groupTargets = sorted.filter(t => [3, 41].includes(t.id));

  if (aoeTargets.length > 0) {
    const aoeTotal = aoeTargets.reduce((s, t) => s + t.total, 0);
    lines.push(`**AoE spells:** ${aoeTotal.toLocaleString()} (${((aoeTotal / grandTotal) * 100).toFixed(1)}%)`);
  }
  if (singleTargets.length > 0) {
    const singleTotal = singleTargets.reduce((s, t) => s + t.total, 0);
    lines.push(`**Single-target spells:** ${singleTotal.toLocaleString()} (${((singleTotal / grandTotal) * 100).toFixed(1)}%)`);
  }
  if (selfTargets.length > 0) {
    const selfTotal = selfTargets.reduce((s, t) => s + t.total, 0);
    lines.push(`**Self-only spells:** ${selfTotal.toLocaleString()} (${((selfTotal / grandTotal) * 100).toFixed(1)}%)`);
  }
  if (groupTargets.length > 0) {
    const groupTotal = groupTargets.reduce((s, t) => s + t.total, 0);
    lines.push(`**Group spells:** ${groupTotal.toLocaleString()} (${((groupTotal / grandTotal) * 100).toFixed(1)}%)`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: ACHIEVEMENT COMPONENT OVERVIEW ============

export async function getAchievementComponentOverview(): Promise<string> {
  await loadAchievementComponents();
  await loadAchievements();
  if (!achievementComponents || achievementComponents.size === 0) return 'Achievement component data not available.';

  const lines = ['# Achievement Component Overview', ''];

  let totalComponents = 0;
  let totalAchievements = achievementComponents.size;

  // Component count distribution
  const stepCounts: number[] = [];
  const componentTypes = new Map<number, number>();

  for (const [, components] of achievementComponents) {
    totalComponents += components.length;
    stepCounts.push(components.length);
    for (const comp of components) {
      componentTypes.set(comp.type, (componentTypes.get(comp.type) || 0) + 1);
    }
  }

  lines.push(`- **Achievements with components:** ${totalAchievements.toLocaleString()}`);
  lines.push(`- **Total components/steps:** ${totalComponents.toLocaleString()}`);

  const avgSteps = (totalComponents / totalAchievements).toFixed(1);
  stepCounts.sort((a, b) => a - b);
  const medianSteps = stepCounts[Math.floor(stepCounts.length / 2)];
  const maxSteps = stepCounts[stepCounts.length - 1];

  lines.push(`- **Average steps per achievement:** ${avgSteps}`);
  lines.push(`- **Median steps:** ${medianSteps}`);
  lines.push(`- **Maximum steps:** ${maxSteps}`);

  // Step count distribution
  const stepDistribution = new Map<number, number>();
  for (const count of stepCounts) {
    const bucket = count <= 10 ? count : count <= 20 ? 20 : count <= 50 ? 50 : 100;
    stepDistribution.set(bucket, (stepDistribution.get(bucket) || 0) + 1);
  }

  lines.push('', '## Step Count Distribution', '');
  lines.push('| Steps | Achievements |');
  lines.push('|-------|-------------|');

  const sortedBuckets = [...stepDistribution.entries()].sort((a, b) => a[0] - b[0]);
  for (const [bucket, count] of sortedBuckets) {
    const label = bucket <= 10 ? `${bucket}` : bucket <= 20 ? '11-20' : bucket <= 50 ? '21-50' : '51+';
    lines.push(`| ${label} | ${count} |`);
  }

  // Component type breakdown
  if (componentTypes.size > 0) {
    lines.push('', '## Component Types', '');
    lines.push('| Type ID | Count | % |');
    lines.push('|---------|-------|---|');

    const sortedTypes = [...componentTypes.entries()].sort((a, b) => b[1] - a[1]);
    for (const [typeId, count] of sortedTypes) {
      const pct = ((count / totalComponents) * 100).toFixed(1);
      lines.push(`| ${typeId} | ${count.toLocaleString()} | ${pct}% |`);
    }
  }

  // Achievements with most steps
  const bySteps = [...achievementComponents.entries()]
    .map(([achId, comps]) => ({ achId, count: comps.length }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  if (bySteps.length > 0 && achievements) {
    lines.push('', '## Most Complex Achievements', '');
    for (const entry of bySteps) {
      const ach = achievements.get(entry.achId);
      const name = ach ? ach.name : `Achievement ${entry.achId}`;
      lines.push(`- **${name}**: ${entry.count} steps`);
    }
  }

  // Achievements with single step
  const singleStep = stepCounts.filter(c => c === 1).length;
  lines.push('', '## Complexity Breakdown', '');
  lines.push(`- **Single-step:** ${singleStep} achievements (${((singleStep / totalAchievements) * 100).toFixed(1)}%)`);
  lines.push(`- **2-5 steps:** ${stepCounts.filter(c => c >= 2 && c <= 5).length} achievements`);
  lines.push(`- **6-10 steps:** ${stepCounts.filter(c => c >= 6 && c <= 10).length} achievements`);
  lines.push(`- **11+ steps:** ${stepCounts.filter(c => c > 10).length} achievements`);

  return lines.join('\n');
}

// ============ PUBLIC API: MERCENARY ABILITY OVERVIEW ============

export async function getMercenaryAbilityOverview(): Promise<string> {
  await loadMercenaryStances();
  if (!mercenaryAbilities || mercenaryAbilities.size === 0) return 'Mercenary ability data not available.';

  const lines = ['# Mercenary Ability Overview', ''];
  lines.push(`**${mercenaryAbilities.size} abilities defined**`, '');

  // List all abilities sorted by ID
  const sorted = [...mercenaryAbilities.entries()].sort((a, b) => a[0] - b[0]);

  lines.push('| ID | Ability | Description |');
  lines.push('|----|---------|-------------|');

  for (const [id, ability] of sorted) {
    const desc = ability.description.length > 80
      ? ability.description.substring(0, 80) + '...'
      : ability.description;
    lines.push(`| ${id} | ${ability.name} | ${desc} |`);
  }

  // Word frequency analysis
  const wordCounts = new Map<string, number>();
  const stopWords = new Set(['the', 'a', 'an', 'of', 'to', 'in', 'for', 'and', 'or', 'is', 'by', 'on', 'at', 'with', 'your', 'you', 'this', 'that', 'it', 'from', 'are', 'be', 'has', 'was', 'will', 'can', 'all', 'as', 'not', 'but']);
  for (const [, ability] of mercenaryAbilities) {
    const words = ability.description.toLowerCase().split(/\W+/);
    for (const word of words) {
      if (word.length > 3 && !stopWords.has(word)) {
        wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
      }
    }
  }
  const topWords = [...wordCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
  if (topWords.length > 0) {
    lines.push('', '## Common Themes', '');
    for (const [word, count] of topWords) {
      lines.push(`- **${word}:** ${count} mentions`);
    }
  }

  // Types summary
  if (mercenaryTypes && mercenaryTypes.size > 0) {
    lines.push('', '## Mercenary Types', '');
    for (const [id, name] of [...mercenaryTypes.entries()].sort((a, b) => a[0] - b[0])) {
      lines.push(`- **${name}** (Type ${id})`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL TIMER GROUP OVERVIEW ============

export async function getSpellTimerOverview(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  // Group spells by timer ID
  const timerGroups = new Map<number, { name: string; level: number; recast: number; category: string }[]>();

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const timerId = parseInt(spell.fields[SF.TIMER_ID]) || 0;
    const name = spell.fields[SF.NAME];
    const recast = parseInt(spell.fields[SF.RECAST_TIME]) || 0;
    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';

    if (!timerGroups.has(timerId)) timerGroups.set(timerId, []);
    timerGroups.get(timerId)!.push({ name, level, recast, category });
  }

  const lines = [`# ${classFullName} Spell Timer Groups`, ''];

  // Shared timer groups (timer > 0 with multiple spells)
  const sharedTimers = [...timerGroups.entries()]
    .filter(([id, spells]) => id > 0 && spells.length > 1)
    .sort((a, b) => b[1].length - a[1].length);

  lines.push(`**${timerGroups.size} timer groups (${sharedTimers.length} shared lockouts)**`, '');

  // Default timer group (0)
  const defaultGroup = timerGroups.get(0);
  if (defaultGroup) {
    lines.push(`## Default Spell Gem Timer (${defaultGroup.length} spells)`, '');
    lines.push('Spells on the default timer use individual spell gem cooldowns.', '');
  }

  // Shared timers
  if (sharedTimers.length > 0) {
    lines.push('## Shared Timer Lockouts', '');
    lines.push('These timers are shared — activating one locks out all others in the same group.', '');

    for (const [timerId, groupSpells] of sharedTimers.slice(0, 25)) {
      const sorted = groupSpells.sort((a, b) => b.level - a.level);
      const maxRecast = Math.max(...groupSpells.map(s => s.recast));
      const recastStr = maxRecast === 0 ? '' : ` (${(maxRecast / 1000).toFixed(0)}s recast)`;

      lines.push(`### Timer ${timerId}${recastStr} — ${groupSpells.length} spells`);
      for (const s of sorted.slice(0, 10)) {
        lines.push(`- Lv ${s.level}: ${s.name} [${s.category}]`);
      }
      if (sorted.length > 10) {
        lines.push(`- ... and ${sorted.length - 10} more`);
      }
      lines.push('');
    }
  }

  // Single-spell timers
  const singleTimers = [...timerGroups.entries()]
    .filter(([id, spells]) => id > 0 && spells.length === 1);

  if (singleTimers.length > 0) {
    lines.push(`## Unique Timers (${singleTimers.length} timers with 1 spell each)`, '');
    const singleSorted = singleTimers
      .map(([id, s]) => ({ id, ...s[0] }))
      .sort((a, b) => b.level - a.level);
    for (const s of singleSorted.slice(0, 20)) {
      const recastStr = s.recast > 0 ? ` (${(s.recast / 1000).toFixed(0)}s)` : '';
      lines.push(`- Timer ${s.id}: Lv ${s.level} ${s.name}${recastStr}`);
    }
    if (singleSorted.length > 20) {
      lines.push(`- ... and ${singleSorted.length - 20} more`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL CATEGORY BREAKDOWN ============

export async function getSpellCategoryBreakdown(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = CLASS_NAME_TO_ID[className.toLowerCase()];
  if (!classId) {
    return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
  }

  const classIndex = classId - 1;
  const classFullName = CLASS_IDS[classId];

  const categories = new Map<string, { count: number; beneficial: number; detrimental: number; minLevel: number; maxLevel: number }>();

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
    if (level <= 0 || level >= 255) continue;

    const categoryId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(categoryId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    if (!categories.has(category)) {
      categories.set(category, { count: 0, beneficial: 0, detrimental: 0, minLevel: 255, maxLevel: 0 });
    }
    const cat = categories.get(category)!;
    cat.count++;
    if (beneficial) cat.beneficial++;
    else cat.detrimental++;
    if (level < cat.minLevel) cat.minLevel = level;
    if (level > cat.maxLevel) cat.maxLevel = level;
  }

  const sorted = [...categories.entries()].sort((a, b) => b[1].count - a[1].count);
  const totalSpells = sorted.reduce((s, [, c]) => s + c.count, 0);

  const lines = [`# ${classFullName} Spell Category Breakdown`, ''];
  lines.push(`**${totalSpells.toLocaleString()} spells across ${sorted.length} categories**`, '');

  lines.push('| Category | Count | % | Beneficial | Detrimental | Level Range |');
  lines.push('|----------|-------|---|------------|-------------|-------------|');

  for (const [name, data] of sorted) {
    const pct = ((data.count / totalSpells) * 100).toFixed(1);
    lines.push(`| ${name} | ${data.count} | ${pct}% | ${data.beneficial} | ${data.detrimental} | ${data.minLevel}-${data.maxLevel} |`);
  }

  // Top 5 categories by category type
  lines.push('', '## Top Categories', '');
  const topBeneficial = sorted.filter(([, d]) => d.beneficial > 0).sort((a, b) => b[1].beneficial - a[1].beneficial);
  if (topBeneficial.length > 0) {
    lines.push(`**Most beneficial:** ${topBeneficial[0][0]} (${topBeneficial[0][1].beneficial} spells)`);
  }
  const topDetrimental = sorted.filter(([, d]) => d.detrimental > 0).sort((a, b) => b[1].detrimental - a[1].detrimental);
  if (topDetrimental.length > 0) {
    lines.push(`**Most detrimental:** ${topDetrimental[0][0]} (${topDetrimental[0][1].detrimental} spells)`);
  }

  // Categories unique to high levels (min level >= 70)
  const highLevelOnly = sorted.filter(([, d]) => d.minLevel >= 70);
  if (highLevelOnly.length > 0) {
    lines.push('', '**High-level only categories (70+):**');
    for (const [name, data] of highLevelOnly.slice(0, 10)) {
      lines.push(`- ${name}: ${data.count} spells (Lv ${data.minLevel}-${data.maxLevel})`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SHARED SPELLS OVERVIEW ============

export async function getSharedSpellsOverview(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // For each spell, count how many classes can use it (level < 255)
  const spellClassCounts: { name: string; classCount: number; classes: string[] }[] = [];

  for (const spell of spells.values()) {
    const classes: string[] = [];
    for (let classId = 1; classId <= 16; classId++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
      if (level > 0 && level < 255) {
        classes.push(CLASS_SHORT[classId]);
      }
    }
    if (classes.length >= 2) {
      spellClassCounts.push({ name: spell.fields[SF.NAME], classCount: classes.length, classes });
    }
  }

  const lines = ['# Cross-Class Spell Availability', ''];

  // Distribution: how many spells are shared by N classes
  const distribution = new Map<number, number>();
  for (const s of spellClassCounts) {
    distribution.set(s.classCount, (distribution.get(s.classCount) || 0) + 1);
  }

  lines.push('## Spell Sharing Distribution', '');
  lines.push('| Classes | Spell Count |');
  lines.push('|---------|-------------|');

  for (let n = 16; n >= 2; n--) {
    const count = distribution.get(n) || 0;
    if (count > 0) {
      lines.push(`| ${n} classes | ${count.toLocaleString()} |`);
    }
  }

  // Count single-class spells
  let singleClass = 0;
  for (const spell of spells.values()) {
    let count = 0;
    for (let classId = 1; classId <= 16; classId++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
      if (level > 0 && level < 255) count++;
    }
    if (count === 1) singleClass++;
  }
  lines.push(`| 1 class (exclusive) | ${singleClass.toLocaleString()} |`);

  // Most widely shared spells (available to 10+ classes)
  const widelyShared = spellClassCounts
    .filter(s => s.classCount >= 10)
    .sort((a, b) => b.classCount - a.classCount || a.name.localeCompare(b.name));

  if (widelyShared.length > 0) {
    lines.push('', `## Most Widely Shared Spells (10+ classes, showing top 30)`, '');
    lines.push('| Spell | Classes | Available To |');
    lines.push('|-------|---------|--------------|');
    for (const s of widelyShared.slice(0, 30)) {
      lines.push(`| ${s.name} | ${s.classCount} | ${s.classes.join(', ')} |`);
    }
    if (widelyShared.length > 30) {
      lines.push(``, `*${widelyShared.length} total spells shared by 10+ classes*`);
    }
  }

  // Per-class sharing stats
  lines.push('', '## Class Sharing Summary', '');
  lines.push('| Class | Total Spells | Exclusive | Shared |');
  lines.push('|-------|-------------|-----------|--------|');

  for (let classId = 1; classId <= 16; classId++) {
    const classIndex = classId - 1;
    let total = 0;
    let exclusive = 0;
    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classIndex]) || 255;
      if (level <= 0 || level >= 255) continue;
      total++;
      let otherCount = 0;
      for (let otherId = 1; otherId <= 16; otherId++) {
        if (otherId === classId) continue;
        const otherLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + otherId - 1]) || 255;
        if (otherLevel > 0 && otherLevel < 255) otherCount++;
      }
      if (otherCount === 0) exclusive++;
    }
    lines.push(`| ${CLASS_IDS[classId]} | ${total.toLocaleString()} | ${exclusive.toLocaleString()} | ${(total - exclusive).toLocaleString()} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL DURATION OVERVIEW ============

export async function getSpellDurationOverview(className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classId: number | undefined;
  let classFullName = 'All Classes';
  if (className) {
    classId = CLASS_NAME_TO_ID[className.toLowerCase()];
    if (!classId) {
      return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;
    }
    classFullName = CLASS_IDS[classId];
  }

  // Duration formula explanations
  const DURATION_FORMULAS: Record<number, string> = {
    0: 'None (instant)',
    1: 'level/2 ticks (max 6s per tick)',
    2: 'level/5 + 1 ticks',
    3: 'level * 30 ticks',
    4: '50 ticks (~5 minutes)',
    5: '2 ticks (~12 seconds)',
    6: 'level/2 ticks',
    7: 'level ticks',
    8: 'level + 10 ticks',
    9: 'level * 2 + 10 ticks',
    10: 'level * 3 + 10 ticks',
    11: '(value) ticks',
    12: 'Permanent',
    50: '(value) ticks (fixed)',
    3600: '(value) seconds (fixed)',
  };

  // Categorize spells by duration type
  const formulaCounts = new Map<number, number>();
  const durationBuckets = new Map<string, number>();
  let totalSpells = 0;

  for (const spell of spells.values()) {
    if (classId) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
    }
    totalSpells++;

    const formula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const value = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    formulaCounts.set(formula, (formulaCounts.get(formula) || 0) + 1);

    // Bucket by approximate duration
    let bucket: string;
    if (formula === 0 && value === 0) bucket = 'Instant';
    else if (formula === 12) bucket = 'Permanent';
    else if (value <= 1) bucket = '≤6s';
    else if (value <= 5) bucket = '6-30s';
    else if (value <= 10) bucket = '30s-1m';
    else if (value <= 50) bucket = '1-5m';
    else if (value <= 150) bucket = '5-15m';
    else if (value <= 600) bucket = '15-60m';
    else bucket = '60m+';

    durationBuckets.set(bucket, (durationBuckets.get(bucket) || 0) + 1);
  }

  const lines = [`# Spell Duration Overview — ${classFullName}`, ''];
  lines.push(`**${totalSpells.toLocaleString()} spells analyzed**`, '');

  // Duration formula breakdown
  lines.push('## Duration Formulas', '');
  lines.push('| Formula | Description | Spells | % |');
  lines.push('|---------|-------------|--------|---|');

  const sortedFormulas = [...formulaCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [formula, count] of sortedFormulas.slice(0, 20)) {
    const desc = DURATION_FORMULAS[formula] || `Formula ${formula}`;
    const pct = ((count / totalSpells) * 100).toFixed(1);
    lines.push(`| ${formula} | ${desc} | ${count.toLocaleString()} | ${pct}% |`);
  }
  if (sortedFormulas.length > 20) {
    lines.push(`| ... | ${sortedFormulas.length - 20} more formulas | | |`);
  }

  // Duration buckets
  const bucketOrder = ['Instant', '≤6s', '6-30s', '30s-1m', '1-5m', '5-15m', '15-60m', '60m+', 'Permanent'];
  lines.push('', '## Duration Distribution', '');
  lines.push('| Duration | Spells | % |');
  lines.push('|----------|--------|---|');

  for (const bucket of bucketOrder) {
    const count = durationBuckets.get(bucket) || 0;
    if (count > 0) {
      const pct = ((count / totalSpells) * 100).toFixed(1);
      const bar = '█'.repeat(Math.round(parseFloat(pct) / 2));
      lines.push(`| ${bucket} | ${count.toLocaleString()} | ${pct}% ${bar} |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: RESIST TYPE CLASS COMPARISON ============

export async function getResistTypeComparison(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Build a matrix: class x resist type -> detrimental spell count
  const matrix: Record<number, Record<number, number>> = {};
  for (let classId = 1; classId <= 16; classId++) {
    matrix[classId] = {};
  }

  for (const spell of spells.values()) {
    if (spell.fields[SF.BENEFICIAL] === '1') continue; // Only detrimental

    const resistType = parseInt(spell.fields[SF.RESIST_TYPE]) || 0;
    if (resistType === 0) continue; // Skip unresistable

    for (let classId = 1; classId <= 16; classId++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
      matrix[classId][resistType] = (matrix[classId][resistType] || 0) + 1;
    }
  }

  // Find all resist types that appear
  const resistTypes = new Set<number>();
  for (const classData of Object.values(matrix)) {
    for (const rt of Object.keys(classData)) {
      resistTypes.add(parseInt(rt));
    }
  }
  const sortedResists = [...resistTypes].sort((a, b) => a - b);

  const lines = ['# Resist Type Distribution by Class (Detrimental Spells)', ''];

  // Build header
  const header = ['| Class', ...sortedResists.map(rt => RESIST_TYPES[rt] || `R${rt}`), 'Total |'];
  const sep = ['|------', ...sortedResists.map(() => '---'), '-----|'];
  lines.push(header.join(' | '));
  lines.push(sep.join(' | '));

  for (let classId = 1; classId <= 16; classId++) {
    const cells = [CLASS_SHORT[classId]];
    let total = 0;
    for (const rt of sortedResists) {
      const count = matrix[classId][rt] || 0;
      total += count;
      cells.push(count > 0 ? count.toString() : '-');
    }
    cells.push(total.toString());
    lines.push(`| ${cells.join(' | ')} |`);
  }

  // Find dominant resist type per class
  lines.push('', '## Dominant Resist Type by Class', '');

  for (let classId = 1; classId <= 16; classId++) {
    let maxType = 0;
    let maxCount = 0;
    for (const [rt, count] of Object.entries(matrix[classId])) {
      if (count > maxCount) {
        maxCount = count;
        maxType = parseInt(rt);
      }
    }
    if (maxCount > 0) {
      lines.push(`- **${CLASS_IDS[classId]}:** ${RESIST_TYPES[maxType]} (${maxCount} spells)`);
    }
  }

  return lines.join('\n');
}

// ============ TOOL #153: SPELL REQUIREMENT OVERVIEW ============

export async function getSpellRequirementOverview(): Promise<string> {
  await loadSpellRequirements();
  await loadSpells();

  if (!spellRequirements || spellRequirements.size === 0) {
    return 'Spell requirement data not available.';
  }

  const lines = ['# Spell Requirement Associations Overview', ''];

  // Basic stats
  let totalEntries = 0;
  const reqIdFreq: Record<number, number> = {};
  const reqsPerAssoc: Record<number, number> = {}; // count of requirements -> frequency
  const subIdFreq: Record<number, number> = {};

  for (const [assocId, reqs] of spellRequirements) {
    totalEntries += reqs.length;
    const count = reqs.length;
    reqsPerAssoc[count] = (reqsPerAssoc[count] || 0) + 1;

    for (const req of reqs) {
      reqIdFreq[req.reqId] = (reqIdFreq[req.reqId] || 0) + 1;
      subIdFreq[req.subId] = (subIdFreq[req.subId] || 0) + 1;
    }
  }

  lines.push(`- **Total spell associations with requirements:** ${spellRequirements.size}`);
  lines.push(`- **Total requirement entries:** ${totalEntries}`);
  lines.push(`- **Unique requirement IDs:** ${Object.keys(reqIdFreq).length}`);
  lines.push(`- **Unique sub-IDs:** ${Object.keys(subIdFreq).length}`);

  // Requirements per association distribution
  lines.push('', '## Requirements per Spell Association', '');
  const sortedCounts = Object.entries(reqsPerAssoc).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
  for (const [count, freq] of sortedCounts) {
    const pct = ((freq / spellRequirements.size) * 100).toFixed(1);
    lines.push(`- **${count} requirement${parseInt(count) !== 1 ? 's' : ''}:** ${freq} spells (${pct}%)`);
  }

  // Most common requirement IDs
  lines.push('', '## Most Common Requirement IDs', '');
  lines.push('| Req ID | Occurrences | % of Total |');
  lines.push('|--------|------------|------------|');
  const sortedReqIds = Object.entries(reqIdFreq).sort((a, b) => b[1] - a[1]).slice(0, 25);
  for (const [reqId, count] of sortedReqIds) {
    const pct = ((count / totalEntries) * 100).toFixed(1);
    lines.push(`| ${reqId} | ${count} | ${pct}% |`);
  }

  // Requirement ID ranges
  const allReqIds = Object.keys(reqIdFreq).map(Number).sort((a, b) => a - b);
  lines.push('', '## Requirement ID Range Analysis', '');
  const ranges: Record<string, number> = {};
  for (const id of allReqIds) {
    let range: string;
    if (id < 100) range = '1-99';
    else if (id < 500) range = '100-499';
    else if (id < 1000) range = '500-999';
    else if (id < 5000) range = '1000-4999';
    else if (id < 10000) range = '5000-9999';
    else range = '10000+';
    ranges[range] = (ranges[range] || 0) + 1;
  }
  for (const [range, count] of Object.entries(ranges)) {
    lines.push(`- **${range}:** ${count} unique requirement IDs`);
  }

  // Try to match association IDs to spell names
  lines.push('', '## Sample Spell-Requirement Mappings', '');
  lines.push('| Association ID | Spell Name | # Requirements | Req IDs |');
  lines.push('|---------------|-----------|---------------|---------|');
  let shown = 0;
  for (const [assocId, reqs] of spellRequirements) {
    if (shown >= 20) break;
    const spell = spells?.get(assocId);
    const name = spell ? spell.name : `(Assoc ${assocId})`;
    const reqIds = reqs.map(r => r.reqId).join(', ');
    lines.push(`| ${assocId} | ${name} | ${reqs.length} | ${reqIds} |`);
    shown++;
  }

  // Sub-ID distribution
  lines.push('', '## Sub-ID Distribution', '');
  const sortedSubIds = Object.entries(subIdFreq).sort((a, b) => b[1] - a[1]).slice(0, 10);
  for (const [subId, count] of sortedSubIds) {
    const pct = ((count / totalEntries) * 100).toFixed(1);
    lines.push(`- **Sub-ID ${subId}:** ${count} entries (${pct}%)`);
  }

  // Most complex spells (most requirements)
  lines.push('', '## Spells with Most Requirements', '');
  const byReqCount = [...spellRequirements.entries()].sort((a, b) => b[1].length - a[1].length).slice(0, 10);
  for (const [assocId, reqs] of byReqCount) {
    const spell = spells?.get(assocId);
    const name = spell ? spell.name : `Association ${assocId}`;
    lines.push(`- **${name}** (ID ${assocId}): ${reqs.length} requirements — IDs: ${reqs.map(r => r.reqId).join(', ')}`);
  }

  return lines.join('\n');
}

// ============ TOOL #154: FACTION MODIFIER OVERVIEW ============

export async function getFactionModifierOverview(): Promise<string> {
  await loadFactions();

  if (!factionModifierNames || factionModifierNames.size === 0) {
    return 'Faction modifier data not available.';
  }

  const lines = ['# Faction Modifier Overview', ''];

  // Group modifiers by type
  const raceModifiers: [number, string][] = [];
  const classModifiers: [number, string][] = [];
  const deityModifiers: [number, string][] = [];
  const otherModifiers: [number, string][] = [];

  for (const [id, name] of factionModifierNames) {
    if (name.startsWith('Race:') || (id >= 51 && id <= 200 && !name.startsWith('Class:'))) {
      raceModifiers.push([id, name]);
    } else if (name.startsWith('Class:') || (id >= 1 && id <= 16)) {
      classModifiers.push([id, name]);
    } else if (name.startsWith('Deity:') || name.includes('Deity')) {
      deityModifiers.push([id, name]);
    } else {
      otherModifiers.push([id, name]);
    }
  }

  lines.push(`- **Total faction modifiers:** ${factionModifierNames.size}`);
  lines.push(`- **Race modifiers:** ${raceModifiers.length}`);
  lines.push(`- **Class modifiers:** ${classModifiers.length}`);
  lines.push(`- **Deity modifiers:** ${deityModifiers.length}`);
  if (otherModifiers.length > 0) lines.push(`- **Other modifiers:** ${otherModifiers.length}`);

  // Class modifiers
  if (classModifiers.length > 0) {
    lines.push('', '## Class Modifiers', '');
    lines.push('| ID | Name |');
    lines.push('|----|------|');
    for (const [id, name] of classModifiers.sort((a, b) => a[0] - b[0])) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  // Race modifiers
  if (raceModifiers.length > 0) {
    lines.push('', '## Race Modifiers', '');
    lines.push('| ID | Name |');
    lines.push('|----|------|');
    for (const [id, name] of raceModifiers.sort((a, b) => a[0] - b[0])) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  // Deity modifiers
  if (deityModifiers.length > 0) {
    lines.push('', '## Deity Modifiers', '');
    lines.push('| ID | Name |');
    lines.push('|----|------|');
    for (const [id, name] of deityModifiers.sort((a, b) => a[0] - b[0])) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  // Other modifiers
  if (otherModifiers.length > 0) {
    lines.push('', '## Other Modifiers', '');
    lines.push('| ID | Name |');
    lines.push('|----|------|');
    for (const [id, name] of otherModifiers.sort((a, b) => a[0] - b[0])) {
      lines.push(`| ${id} | ${name} |`);
    }
  }

  // Usage analysis: how many factions reference each modifier
  if (factions) {
    const modUsage: Record<number, number> = {};
    let factionsWithStarting = 0;
    let totalAssociations = 0;

    for (const faction of factions.values()) {
      if (faction.startingValues && faction.startingValues.length > 0) {
        factionsWithStarting++;
        for (const sv of faction.startingValues) {
          modUsage[sv.modifierId] = (modUsage[sv.modifierId] || 0) + 1;
          totalAssociations++;
        }
      }
    }

    lines.push('', '## Modifier Usage in Factions', '');
    lines.push(`- **Factions with starting value adjustments:** ${factionsWithStarting} of ${factions.size}`);
    lines.push(`- **Total faction-modifier associations:** ${totalAssociations}`);

    lines.push('', '### Most Used Modifiers', '');
    lines.push('| Modifier | Factions Using It |');
    lines.push('|----------|------------------|');
    const sortedUsage = Object.entries(modUsage)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 30);
    for (const [modId, count] of sortedUsage) {
      const name = factionModifierNames.get(parseInt(modId)) || `Modifier ${modId}`;
      lines.push(`| ${name} (ID ${modId}) | ${count} |`);
    }

    // Starting value ranges
    lines.push('', '### Starting Value Distribution', '');
    const valueBuckets: Record<string, number> = {};
    for (const faction of factions.values()) {
      if (!faction.startingValues) continue;
      for (const sv of faction.startingValues) {
        let bucket: string;
        if (sv.value < -500) bucket = 'Very Negative (< -500)';
        else if (sv.value < -100) bucket = 'Negative (-500 to -101)';
        else if (sv.value < 0) bucket = 'Slightly Negative (-100 to -1)';
        else if (sv.value === 0) bucket = 'Neutral (0)';
        else if (sv.value <= 100) bucket = 'Slightly Positive (1 to 100)';
        else if (sv.value <= 500) bucket = 'Positive (101 to 500)';
        else bucket = 'Very Positive (> 500)';
        valueBuckets[bucket] = (valueBuckets[bucket] || 0) + 1;
      }
    }
    const bucketOrder = [
      'Very Negative (< -500)', 'Negative (-500 to -101)', 'Slightly Negative (-100 to -1)',
      'Neutral (0)', 'Slightly Positive (1 to 100)', 'Positive (101 to 500)', 'Very Positive (> 500)'
    ];
    for (const bucket of bucketOrder) {
      if (valueBuckets[bucket]) {
        lines.push(`- **${bucket}:** ${valueBuckets[bucket]} associations`);
      }
    }
  }

  return lines.join('\n');
}

// ============ TOOL #155: OVERSEER SLOT ANALYSIS ============

export async function getOverseerSlotAnalysis(): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerMinions(); // loads trait names
  await loadOverseerEnhancements();

  if (!overseerQuests || overseerQuests.size === 0) {
    return 'Overseer quest data not available.';
  }

  const lines = ['# Overseer Quest Slot Analysis', ''];

  // Gather all slot data
  let totalSlots = 0;
  let totalRequired = 0;
  let totalOptional = 0;
  let questsWithSlots = 0;
  const jobDemand: Record<number, { required: number; optional: number }> = {};
  const traitFreq: Record<number, number> = {};
  const slotCountDist: Record<number, number> = {}; // total slots per quest -> freq
  const questsBySlotCount: { quest: OverseerQuest; total: number }[] = [];

  for (const quest of overseerQuests.values()) {
    if (quest.slotDetails.length === 0) continue;
    questsWithSlots++;
    const total = quest.slotDetails.length;
    totalSlots += total;
    totalRequired += quest.requiredSlots;
    totalOptional += quest.optionalSlots;
    slotCountDist[total] = (slotCountDist[total] || 0) + 1;
    questsBySlotCount.push({ quest, total });

    for (const slot of quest.slotDetails) {
      if (!jobDemand[slot.jobTypeId]) jobDemand[slot.jobTypeId] = { required: 0, optional: 0 };
      if (slot.isRequired) {
        jobDemand[slot.jobTypeId].required++;
      } else {
        jobDemand[slot.jobTypeId].optional++;
      }
      for (const traitId of slot.bonusTraitIds) {
        traitFreq[traitId] = (traitFreq[traitId] || 0) + 1;
      }
    }
  }

  lines.push(`- **Quests with slot data:** ${questsWithSlots} of ${overseerQuests.size}`);
  lines.push(`- **Total agent slots:** ${totalSlots}`);
  lines.push(`- **Required slots:** ${totalRequired} (${((totalRequired / totalSlots) * 100).toFixed(1)}%)`);
  lines.push(`- **Optional slots:** ${totalOptional} (${((totalOptional / totalSlots) * 100).toFixed(1)}%)`);
  if (questsWithSlots > 0) {
    lines.push(`- **Average slots per quest:** ${(totalSlots / questsWithSlots).toFixed(1)}`);
  }

  // Slot count distribution
  lines.push('', '## Slots per Quest Distribution', '');
  const sortedSlotCounts = Object.entries(slotCountDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
  for (const [count, freq] of sortedSlotCounts) {
    const bar = '#'.repeat(Math.min(freq, 50));
    lines.push(`- **${count} slots:** ${freq} quests ${bar}`);
  }

  // Job type demand
  lines.push('', '## Job Type Demand', '');
  lines.push('| Job | Required | Optional | Total | % of All Slots |');
  lines.push('|-----|---------|---------|-------|---------------|');
  const sortedJobs = Object.entries(jobDemand)
    .sort((a, b) => (b[1].required + b[1].optional) - (a[1].required + a[1].optional));
  for (const [jobId, counts] of sortedJobs) {
    const name = overseerJobNames?.get(parseInt(jobId)) || `Job ${jobId}`;
    const total = counts.required + counts.optional;
    const pct = ((total / totalSlots) * 100).toFixed(1);
    lines.push(`| ${name} | ${counts.required} | ${counts.optional} | ${total} | ${pct}% |`);
  }

  // Most demanded job (required slots only)
  const topRequired = sortedJobs.sort((a, b) => b[1].required - a[1].required)[0];
  if (topRequired) {
    const topName = overseerJobNames?.get(parseInt(topRequired[0])) || `Job ${topRequired[0]}`;
    lines.push('', `**Most required job type:** ${topName} (${topRequired[1].required} required slots)`);
  }

  // Bonus trait frequency
  const traitNames = dbStrings?.get(DBSTR_TYPES.OVERSEER_TRAIT) || new Map<number, string>();
  if (Object.keys(traitFreq).length > 0) {
    lines.push('', '## Bonus Trait Frequency', '');
    lines.push('| Trait | Slots with Bonus | % of Total Slots |');
    lines.push('|-------|-----------------|-----------------|');
    const sortedTraits = Object.entries(traitFreq).sort((a, b) => b[1] - a[1]).slice(0, 25);
    for (const [traitId, count] of sortedTraits) {
      const name = traitNames.get(parseInt(traitId)) || `Trait ${traitId}`;
      const pct = ((count / totalSlots) * 100).toFixed(1);
      lines.push(`| ${name} | ${count} | ${pct}% |`);
    }
    lines.push('', `- **Total unique bonus traits:** ${Object.keys(traitFreq).length}`);
    lines.push(`- **Total bonus trait assignments:** ${Object.values(traitFreq).reduce((s, v) => s + v, 0)}`);
  }

  // Quests by difficulty with slot analysis
  if (overseerDifficulties && overseerDifficulties.size > 0) {
    lines.push('', '## Slots by Difficulty Level', '');
    const byDiff: Record<number, { quests: number; totalSlots: number; required: number; optional: number }> = {};
    for (const quest of overseerQuests.values()) {
      if (quest.slotDetails.length === 0) continue;
      if (!byDiff[quest.difficulty]) byDiff[quest.difficulty] = { quests: 0, totalSlots: 0, required: 0, optional: 0 };
      byDiff[quest.difficulty].quests++;
      byDiff[quest.difficulty].totalSlots += quest.slotDetails.length;
      byDiff[quest.difficulty].required += quest.requiredSlots;
      byDiff[quest.difficulty].optional += quest.optionalSlots;
    }

    lines.push('| Difficulty | Quests | Total Slots | Avg Slots | Required | Optional |');
    lines.push('|-----------|--------|------------|-----------|---------|---------|');
    for (const [diff, data] of Object.entries(byDiff).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
      const diffName = overseerDifficulties.get(parseInt(diff)) || `Level ${diff}`;
      const avg = (data.totalSlots / data.quests).toFixed(1);
      lines.push(`| ${diffName} | ${data.quests} | ${data.totalSlots} | ${avg} | ${data.required} | ${data.optional} |`);
    }
  }

  // Most demanding quests
  questsBySlotCount.sort((a, b) => b.total - a.total);
  lines.push('', '## Most Agent-Demanding Quests (Top 10)', '');
  for (const { quest, total } of questsBySlotCount.slice(0, 10)) {
    const cat = overseerCategories?.get(quest.categoryId) || '';
    lines.push(`- **${quest.name}** — ${total} slots (${quest.requiredSlots} req, ${quest.optionalSlots} opt)${cat ? ` [${cat}]` : ''}`);
  }

  // Least demanding quests (with at least 1 slot)
  lines.push('', '## Least Agent-Demanding Quests (Bottom 10)', '');
  for (const { quest, total } of questsBySlotCount.slice(-10).reverse()) {
    const cat = overseerCategories?.get(quest.categoryId) || '';
    lines.push(`- **${quest.name}** — ${total} slots (${quest.requiredSlots} req, ${quest.optionalSlots} opt)${cat ? ` [${cat}]` : ''}`);
  }

  return lines.join('\n');
}

// ============ TOOL #156: DB STRING TYPE OVERVIEW ============

export async function getDbStringTypeOverview(): Promise<string> {
  if (!isGameDataAvailable()) {
    return 'Game data directory not available.';
  }

  // Read raw dbstr_us.txt and count entries per type
  const data = await readGameFile('dbstr_us.txt');
  const lineArr = data.split('\n');

  const typeCounts: Record<number, number> = {};
  const typeSamples: Record<number, string[]> = {}; // first 3 samples per type

  for (const line of lineArr) {
    if (!line.trim()) continue;
    const fields = line.split('^');
    if (fields.length < 3) continue;
    const type = parseInt(fields[1]);
    const text = fields[2];
    if (isNaN(type)) continue;

    typeCounts[type] = (typeCounts[type] || 0) + 1;
    if (!typeSamples[type]) typeSamples[type] = [];
    if (typeSamples[type].length < 3 && text && text.length > 0) {
      typeSamples[type].push(text.length > 60 ? text.substring(0, 57) + '...' : text);
    }
  }

  // Reverse map DBSTR_TYPES to get names
  const typeNames: Record<number, string> = {};
  for (const [name, id] of Object.entries(DBSTR_TYPES)) {
    typeNames[id] = name;
  }

  const lines = ['# DB String Types Overview (dbstr_us.txt)', ''];

  const totalEntries = Object.values(typeCounts).reduce((s, v) => s + v, 0);
  const totalTypes = Object.keys(typeCounts).length;
  const knownTypes = Object.keys(typeCounts).filter(t => typeNames[parseInt(t)]).length;

  lines.push(`- **Total entries:** ${totalEntries.toLocaleString()}`);
  lines.push(`- **Total unique types:** ${totalTypes}`);
  lines.push(`- **Known/named types:** ${knownTypes}`);
  lines.push(`- **Unknown types:** ${totalTypes - knownTypes}`);

  // Table of all types sorted by type ID
  lines.push('', '## All String Types', '');
  lines.push('| Type ID | Name | Entries | Samples |');
  lines.push('|---------|------|---------|---------|');
  const sortedTypes = Object.entries(typeCounts).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
  for (const [typeId, count] of sortedTypes) {
    const id = parseInt(typeId);
    const name = typeNames[id] || '(unknown)';
    const samples = (typeSamples[id] || []).map(s => s.replace(/\|/g, '\\|')).join('; ');
    lines.push(`| ${id} | ${name} | ${count.toLocaleString()} | ${samples} |`);
  }

  // Top 10 by entry count
  lines.push('', '## Largest Types by Entry Count', '');
  const byCount = [...sortedTypes].sort((a, b) => b[1] - a[1]).slice(0, 10);
  for (const [typeId, count] of byCount) {
    const id = parseInt(typeId);
    const name = typeNames[id] || `Type ${id}`;
    const pct = ((count / totalEntries) * 100).toFixed(1);
    lines.push(`- **${name}** (type ${id}): ${count.toLocaleString()} entries (${pct}%)`);
  }

  return lines.join('\n');
}

// ============ TOOL #157: SPELL LEVEL DISTRIBUTION ============

export async function getSpellLevelDistribution(className: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) =>
    name.toLowerCase() === className.toLowerCase()
  )?.[0];
  if (!classId) {
    const validClasses = Object.values(CLASS_IDS).join(', ');
    return `Unknown class "${className}". Valid classes: ${validClasses}`;
  }
  const cid = parseInt(classId);
  const fieldIdx = SF.CLASS_LEVEL_START + cid - 1;

  // Collect spells by level
  const byLevel: Record<number, { name: string; id: number; beneficial: boolean; category: string }[]> = {};
  let totalSpells = 0;

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[fieldIdx]) || 255;
    if (level <= 0 || level >= 255) continue;

    totalSpells++;
    if (!byLevel[level]) byLevel[level] = [];
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(catId) || '';
    byLevel[level].push({ name: spell.name, id: spell.id, beneficial, category });
  }

  const lines = [`# Spell Level Distribution: ${CLASS_IDS[cid]}`, ''];
  lines.push(`- **Total spells:** ${totalSpells}`);

  const levels = Object.keys(byLevel).map(Number).sort((a, b) => a - b);
  lines.push(`- **Level range:** ${levels[0]} to ${levels[levels.length - 1]}`);
  lines.push(`- **Levels with spells:** ${levels.length}`);

  // Distribution by level bracket
  lines.push('', '## Spells by Level Bracket', '');
  const brackets: [string, number, number][] = [
    ['1-10', 1, 10], ['11-20', 11, 20], ['21-30', 21, 30], ['31-40', 31, 40],
    ['41-50', 41, 50], ['51-60', 51, 60], ['61-70', 61, 70], ['71-80', 71, 80],
    ['81-90', 81, 90], ['91-100', 91, 100], ['101-110', 101, 110], ['111-125', 111, 125],
  ];
  for (const [label, min, max] of brackets) {
    let count = 0;
    let beneficialCount = 0;
    for (let l = min; l <= max; l++) {
      if (byLevel[l]) {
        count += byLevel[l].length;
        beneficialCount += byLevel[l].filter(s => s.beneficial).length;
      }
    }
    if (count > 0) {
      const bar = '#'.repeat(Math.min(Math.round(count / 5), 50));
      const detrCount = count - beneficialCount;
      lines.push(`- **${label}:** ${count} spells (${beneficialCount} ben, ${detrCount} det) ${bar}`);
    }
  }

  // Level-by-level detail
  lines.push('', '## Spells per Level', '');
  lines.push('| Level | Count | Beneficial | Detrimental |');
  lines.push('|-------|-------|-----------|------------|');
  for (const level of levels) {
    const spellsAtLevel = byLevel[level];
    const ben = spellsAtLevel.filter(s => s.beneficial).length;
    const det = spellsAtLevel.length - ben;
    lines.push(`| ${level} | ${spellsAtLevel.length} | ${ben} | ${det} |`);
  }

  // Levels with the most spells
  const peakLevels = [...levels].sort((a, b) => byLevel[b].length - byLevel[a].length).slice(0, 5);
  lines.push('', '## Peak Spell Levels', '');
  for (const level of peakLevels) {
    const spellNames = byLevel[level].slice(0, 5).map(s => s.name).join(', ');
    const more = byLevel[level].length > 5 ? ` (+${byLevel[level].length - 5} more)` : '';
    lines.push(`- **Level ${level}:** ${byLevel[level].length} spells — ${spellNames}${more}`);
  }

  // Gaps in spell levels
  const gaps: number[] = [];
  for (let l = levels[0]; l <= levels[levels.length - 1]; l++) {
    if (!byLevel[l]) gaps.push(l);
  }
  if (gaps.length > 0 && gaps.length <= 30) {
    lines.push('', '## Levels with No Spells', '');
    lines.push(gaps.join(', '));
  } else if (gaps.length > 30) {
    lines.push('', `## Levels with No Spells: ${gaps.length} gaps`);
  }

  return lines.join('\n');
}

// ============ TOOL #158: SPELL CAST TIME ANALYSIS ============

export async function getSpellCastTimeAnalysis(className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classFilter: number | undefined;
  let classLabel = 'All Classes';
  if (className) {
    const classId = Object.entries(CLASS_IDS).find(([, name]) =>
      name.toLowerCase() === className.toLowerCase()
    )?.[0];
    if (!classId) {
      const validClasses = Object.values(CLASS_IDS).join(', ');
      return `Unknown class "${className}". Valid classes: ${validClasses}`;
    }
    classFilter = parseInt(classId);
    classLabel = CLASS_IDS[classFilter];
  }

  // Collect timing data
  const castTimes: number[] = [];
  const recoveryTimes: number[] = [];
  const recastTimes: number[] = [];
  let totalSpells = 0;

  const castBuckets: Record<string, number> = {};
  const recastBuckets: Record<string, number> = {};

  for (const spell of spells.values()) {
    if (classFilter) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
    }

    totalSpells++;
    const castMs = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    const recoveryMs = parseInt(spell.fields[SF.RECOVERY_TIME]) || 0;
    const recastMs = parseInt(spell.fields[SF.RECAST_TIME]) || 0;

    castTimes.push(castMs);
    recoveryTimes.push(recoveryMs);
    recastTimes.push(recastMs);

    // Cast time buckets
    const castSec = castMs / 1000;
    let castBucket: string;
    if (castSec === 0) castBucket = 'Instant (0s)';
    else if (castSec <= 0.5) castBucket = 'Very Fast (0.1-0.5s)';
    else if (castSec <= 1.5) castBucket = 'Fast (0.6-1.5s)';
    else if (castSec <= 3) castBucket = 'Medium (1.6-3.0s)';
    else if (castSec <= 6) castBucket = 'Slow (3.1-6.0s)';
    else if (castSec <= 12) castBucket = 'Very Slow (6.1-12s)';
    else castBucket = 'Ultra Slow (>12s)';
    castBuckets[castBucket] = (castBuckets[castBucket] || 0) + 1;

    // Recast time buckets
    const recastSec = recastMs / 1000;
    let recastBucket: string;
    if (recastSec === 0) recastBucket = 'None (0s)';
    else if (recastSec <= 6) recastBucket = 'Short (1-6s)';
    else if (recastSec <= 15) recastBucket = 'Medium (7-15s)';
    else if (recastSec <= 30) recastBucket = 'Long (16-30s)';
    else if (recastSec <= 60) recastBucket = 'Very Long (31-60s)';
    else if (recastSec <= 300) recastBucket = 'Extended (1-5min)';
    else if (recastSec <= 900) recastBucket = 'Cooldown (5-15min)';
    else recastBucket = 'Discipline (>15min)';
    recastBuckets[recastBucket] = (recastBuckets[recastBucket] || 0) + 1;
  }

  if (totalSpells === 0) return 'No spells found for the given criteria.';

  const lines = [`# Spell Cast Time Analysis: ${classLabel}`, ''];
  lines.push(`- **Total spells analyzed:** ${totalSpells}`);

  // Helper for stats
  const stats = (arr: number[]) => {
    const sorted = [...arr].sort((a, b) => a - b);
    const sum = sorted.reduce((s, v) => s + v, 0);
    const avg = sum / sorted.length;
    const median = sorted[Math.floor(sorted.length / 2)];
    const min = sorted[0];
    const max = sorted[sorted.length - 1];
    const nonZero = sorted.filter(v => v > 0).length;
    return { avg, median, min, max, nonZero };
  };

  // Cast time stats
  const cs = stats(castTimes);
  lines.push('', '## Cast Time', '');
  lines.push(`- **Average:** ${(cs.avg / 1000).toFixed(2)}s`);
  lines.push(`- **Median:** ${(cs.median / 1000).toFixed(2)}s`);
  lines.push(`- **Range:** ${(cs.min / 1000).toFixed(1)}s to ${(cs.max / 1000).toFixed(1)}s`);
  lines.push(`- **Instant cast spells:** ${totalSpells - cs.nonZero} (${(((totalSpells - cs.nonZero) / totalSpells) * 100).toFixed(1)}%)`);

  // Cast time distribution
  lines.push('', '### Cast Time Distribution', '');
  const castOrder = ['Instant (0s)', 'Very Fast (0.1-0.5s)', 'Fast (0.6-1.5s)', 'Medium (1.6-3.0s)', 'Slow (3.1-6.0s)', 'Very Slow (6.1-12s)', 'Ultra Slow (>12s)'];
  for (const bucket of castOrder) {
    const count = castBuckets[bucket] || 0;
    if (count > 0) {
      const pct = ((count / totalSpells) * 100).toFixed(1);
      const bar = '#'.repeat(Math.min(Math.round(count / (totalSpells / 50)), 50));
      lines.push(`- **${bucket}:** ${count} (${pct}%) ${bar}`);
    }
  }

  // Recovery time stats
  const rs = stats(recoveryTimes);
  lines.push('', '## Recovery Time (Global Cooldown)', '');
  lines.push(`- **Average:** ${(rs.avg / 1000).toFixed(2)}s`);
  lines.push(`- **Median:** ${(rs.median / 1000).toFixed(2)}s`);
  lines.push(`- **Spells with recovery time:** ${rs.nonZero} (${((rs.nonZero / totalSpells) * 100).toFixed(1)}%)`);

  // Recast time stats
  const rcs = stats(recastTimes);
  lines.push('', '## Recast Time (Cooldown)', '');
  lines.push(`- **Average:** ${(rcs.avg / 1000).toFixed(2)}s`);
  lines.push(`- **Median:** ${(rcs.median / 1000).toFixed(2)}s`);
  lines.push(`- **Range:** ${(rcs.min / 1000).toFixed(1)}s to ${(rcs.max / 1000).toFixed(1)}s`);
  lines.push(`- **No recast cooldown:** ${totalSpells - rcs.nonZero} (${(((totalSpells - rcs.nonZero) / totalSpells) * 100).toFixed(1)}%)`);

  // Recast time distribution
  lines.push('', '### Recast Time Distribution', '');
  const recastOrder = ['None (0s)', 'Short (1-6s)', 'Medium (7-15s)', 'Long (16-30s)', 'Very Long (31-60s)', 'Extended (1-5min)', 'Cooldown (5-15min)', 'Discipline (>15min)'];
  for (const bucket of recastOrder) {
    const count = recastBuckets[bucket] || 0;
    if (count > 0) {
      const pct = ((count / totalSpells) * 100).toFixed(1);
      const bar = '#'.repeat(Math.min(Math.round(count / (totalSpells / 50)), 50));
      lines.push(`- **${bucket}:** ${count} (${pct}%) ${bar}`);
    }
  }

  // Longest cast time spells
  lines.push('', '## Longest Cast Time Spells (Top 10)', '');
  const byCast = [...spells.values()]
    .filter(s => {
      if (!classFilter) return true;
      const level = parseInt(s.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
      return level > 0 && level < 255;
    })
    .sort((a, b) => (parseInt(b.fields[SF.CAST_TIME]) || 0) - (parseInt(a.fields[SF.CAST_TIME]) || 0))
    .slice(0, 10);
  for (const spell of byCast) {
    const ms = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    lines.push(`- **${spell.name}:** ${(ms / 1000).toFixed(1)}s cast`);
  }

  // Longest recast time spells
  lines.push('', '## Longest Recast Time Spells (Top 10)', '');
  const byRecast = [...spells.values()]
    .filter(s => {
      if (!classFilter) return true;
      const level = parseInt(s.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
      return level > 0 && level < 255;
    })
    .sort((a, b) => (parseInt(b.fields[SF.RECAST_TIME]) || 0) - (parseInt(a.fields[SF.RECAST_TIME]) || 0))
    .slice(0, 10);
  for (const spell of byRecast) {
    const ms = parseInt(spell.fields[SF.RECAST_TIME]) || 0;
    const sec = ms / 1000;
    const display = sec >= 60 ? `${(sec / 60).toFixed(1)}min` : `${sec.toFixed(1)}s`;
    lines.push(`- **${spell.name}:** ${display} recast`);
  }

  return lines.join('\n');
}

// ============ TOOL #159: SPELL MANA COST OVERVIEW ============

export async function getSpellManaCostOverview(className?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classFilter: number | undefined;
  let classLabel = 'All Classes';
  if (className) {
    const classId = Object.entries(CLASS_IDS).find(([, name]) =>
      name.toLowerCase() === className.toLowerCase()
    )?.[0];
    if (!classId) {
      const validClasses = Object.values(CLASS_IDS).join(', ');
      return `Unknown class "${className}". Valid classes: ${validClasses}`;
    }
    classFilter = parseInt(classId);
    classLabel = CLASS_IDS[classFilter];
  }

  let totalSpells = 0;
  let zeroMana = 0;
  let enduranceOnly = 0;
  const manaCosts: number[] = [];
  const manaBuckets: Record<string, number> = {};
  const manaByLevel: Record<number, number[]> = {}; // level bracket -> mana values

  for (const spell of spells.values()) {
    if (classFilter) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
    }

    totalSpells++;
    const mana = parseInt(spell.fields[SF.MANA]) || 0;
    const endurance = parseInt(spell.fields[SF.ENDURANCE]) || 0;

    if (mana === 0 && endurance > 0) {
      enduranceOnly++;
      continue; // Skip endurance-only abilities for mana analysis
    }
    if (mana === 0) {
      zeroMana++;
      continue;
    }

    manaCosts.push(mana);

    // Mana cost buckets
    let bucket: string;
    if (mana <= 10) bucket = '1-10';
    else if (mana <= 50) bucket = '11-50';
    else if (mana <= 100) bucket = '51-100';
    else if (mana <= 250) bucket = '101-250';
    else if (mana <= 500) bucket = '251-500';
    else if (mana <= 1000) bucket = '501-1000';
    else if (mana <= 5000) bucket = '1001-5000';
    else if (mana <= 10000) bucket = '5001-10000';
    else bucket = '10000+';
    manaBuckets[bucket] = (manaBuckets[bucket] || 0) + 1;

    // Mana by level bracket
    if (classFilter) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 0;
      const bracket = Math.floor((level - 1) / 10) * 10 + 1;
      if (!manaByLevel[bracket]) manaByLevel[bracket] = [];
      manaByLevel[bracket].push(mana);
    }
  }

  const lines = [`# Spell Mana Cost Overview: ${classLabel}`, ''];
  lines.push(`- **Total spells:** ${totalSpells}`);
  lines.push(`- **Spells with mana cost:** ${manaCosts.length} (${((manaCosts.length / totalSpells) * 100).toFixed(1)}%)`);
  lines.push(`- **Zero mana (free):** ${zeroMana}`);
  lines.push(`- **Endurance-only (combat abilities):** ${enduranceOnly}`);

  if (manaCosts.length > 0) {
    const sorted = [...manaCosts].sort((a, b) => a - b);
    const sum = sorted.reduce((s, v) => s + v, 0);
    lines.push(`- **Average mana cost:** ${Math.round(sum / sorted.length)}`);
    lines.push(`- **Median mana cost:** ${sorted[Math.floor(sorted.length / 2)]}`);
    lines.push(`- **Range:** ${sorted[0]} to ${sorted[sorted.length - 1]}`);

    // Distribution
    lines.push('', '## Mana Cost Distribution', '');
    const bucketOrder = ['1-10', '11-50', '51-100', '101-250', '251-500', '501-1000', '1001-5000', '5001-10000', '10000+'];
    for (const bucket of bucketOrder) {
      const count = manaBuckets[bucket] || 0;
      if (count > 0) {
        const pct = ((count / manaCosts.length) * 100).toFixed(1);
        const bar = '#'.repeat(Math.min(Math.round(count / (manaCosts.length / 50)), 50));
        lines.push(`- **${bucket} mana:** ${count} (${pct}%) ${bar}`);
      }
    }

    // Mana by level bracket (class only)
    if (classFilter && Object.keys(manaByLevel).length > 0) {
      lines.push('', '## Average Mana Cost by Level', '');
      lines.push('| Level Range | Spells | Avg Mana | Min | Max |');
      lines.push('|------------|--------|---------|-----|-----|');
      for (const bracket of Object.keys(manaByLevel).map(Number).sort((a, b) => a - b)) {
        const values = manaByLevel[bracket];
        const avg = Math.round(values.reduce((s, v) => s + v, 0) / values.length);
        const min = Math.min(...values);
        const max = Math.max(...values);
        const end = bracket + 9;
        lines.push(`| ${bracket}-${end} | ${values.length} | ${avg} | ${min} | ${max} |`);
      }
    }

    // Most expensive spells
    lines.push('', '## Most Mana-Expensive Spells (Top 15)', '');
    const byMana = [...spells.values()]
      .filter(s => {
        if (!classFilter) return true;
        const level = parseInt(s.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
        return level > 0 && level < 255;
      })
      .filter(s => (parseInt(s.fields[SF.MANA]) || 0) > 0)
      .sort((a, b) => (parseInt(b.fields[SF.MANA]) || 0) - (parseInt(a.fields[SF.MANA]) || 0))
      .slice(0, 15);
    for (const spell of byMana) {
      const mana = parseInt(spell.fields[SF.MANA]) || 0;
      const ben = spell.fields[SF.BENEFICIAL] === '1' ? 'beneficial' : 'detrimental';
      lines.push(`- **${spell.name}:** ${mana.toLocaleString()} mana (${ben})`);
    }
  }

  return lines.join('\n');
}

// ============ TOOL #160: SPELL SUBCATEGORY OVERVIEW ============

export async function getSpellSubcategoryOverview(className?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classFilter: number | undefined;
  let classLabel = 'All Classes';
  if (className) {
    const classId = Object.entries(CLASS_IDS).find(([, name]) =>
      name.toLowerCase() === className.toLowerCase()
    )?.[0];
    if (!classId) {
      const validClasses = Object.values(CLASS_IDS).join(', ');
      return `Unknown class "${className}". Valid classes: ${validClasses}`;
    }
    classFilter = parseInt(classId);
    classLabel = CLASS_IDS[classFilter];
  }

  // Build category -> subcategory -> count tree
  const tree: Record<string, Record<string, { total: number; beneficial: number; detrimental: number }>> = {};
  let totalSpells = 0;

  for (const spell of spells.values()) {
    if (classFilter) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
    }

    totalSpells++;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const subId = parseInt(spell.fields[SF.SUBCATEGORY]) || 0;
    const category = (catId > 0 && spellCategories?.get(catId)) || 'Uncategorized';
    const subcategory = (subId > 0 && spellCategories?.get(subId)) || 'General';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    if (!tree[category]) tree[category] = {};
    if (!tree[category][subcategory]) tree[category][subcategory] = { total: 0, beneficial: 0, detrimental: 0 };
    tree[category][subcategory].total++;
    if (beneficial) tree[category][subcategory].beneficial++;
    else tree[category][subcategory].detrimental++;
  }

  const lines = [`# Spell Category & Subcategory Tree: ${classLabel}`, ''];
  lines.push(`- **Total spells:** ${totalSpells}`);
  lines.push(`- **Categories:** ${Object.keys(tree).length}`);

  const totalSubcats = Object.values(tree).reduce((s, subs) => s + Object.keys(subs).length, 0);
  lines.push(`- **Subcategories:** ${totalSubcats}`);

  // Sort categories by total spell count
  const sortedCats = Object.entries(tree).sort((a, b) => {
    const totalA = Object.values(a[1]).reduce((s, v) => s + v.total, 0);
    const totalB = Object.values(b[1]).reduce((s, v) => s + v.total, 0);
    return totalB - totalA;
  });

  lines.push('', '## Category Tree', '');
  for (const [category, subcats] of sortedCats) {
    const catTotal = Object.values(subcats).reduce((s, v) => s + v.total, 0);
    const catBen = Object.values(subcats).reduce((s, v) => s + v.beneficial, 0);
    const catDet = Object.values(subcats).reduce((s, v) => s + v.detrimental, 0);
    const pct = ((catTotal / totalSpells) * 100).toFixed(1);
    lines.push(`### ${category} (${catTotal} spells, ${pct}%) — ${catBen} ben / ${catDet} det`);

    const sortedSubs = Object.entries(subcats).sort((a, b) => b[1].total - a[1].total);
    for (const [subcategory, counts] of sortedSubs) {
      const subPct = ((counts.total / catTotal) * 100).toFixed(0);
      lines.push(`  - ${subcategory}: ${counts.total} (${subPct}%) — ${counts.beneficial} ben / ${counts.detrimental} det`);
    }
    lines.push('');
  }

  // Largest subcategories across all categories
  lines.push('## Largest Subcategories (Top 15)', '');
  const allSubs: { category: string; subcategory: string; total: number }[] = [];
  for (const [category, subcats] of Object.entries(tree)) {
    for (const [subcategory, counts] of Object.entries(subcats)) {
      allSubs.push({ category, subcategory, total: counts.total });
    }
  }
  allSubs.sort((a, b) => b.total - a.total);
  for (const { category, subcategory, total } of allSubs.slice(0, 15)) {
    lines.push(`- **${category} > ${subcategory}:** ${total} spells`);
  }

  return lines.join('\n');
}

// ============ TOOL #161: CLASS UNIQUE SPELL ANALYSIS ============

export async function getClassUniqueSpellAnalysis(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) =>
    name.toLowerCase() === className.toLowerCase()
  )?.[0];
  if (!classId) {
    const validClasses = Object.values(CLASS_IDS).join(', ');
    return `Unknown class "${className}". Valid classes: ${validClasses}`;
  }
  const cid = parseInt(classId);
  const fieldIdx = SF.CLASS_LEVEL_START + cid - 1;

  // Find spells exclusive to this class
  const exclusiveSpells: { name: string; id: number; level: number; category: string; beneficial: boolean }[] = [];
  const sharedSpells: { name: string; id: number; level: number; sharedWith: number }[] = [];
  let totalClassSpells = 0;

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[fieldIdx]) || 255;
    if (level <= 0 || level >= 255) continue;
    totalClassSpells++;

    // Check how many other classes can use this spell
    let otherClassCount = 0;
    for (let i = 1; i <= 16; i++) {
      if (i === cid) continue;
      const otherLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (otherLevel > 0 && otherLevel < 255) otherClassCount++;
    }

    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = (catId > 0 && spellCategories?.get(catId)) || 'Uncategorized';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    if (otherClassCount === 0) {
      exclusiveSpells.push({ name: spell.name, id: spell.id, level, category, beneficial });
    } else {
      sharedSpells.push({ name: spell.name, id: spell.id, level, sharedWith: otherClassCount });
    }
  }

  const lines = [`# ${CLASS_IDS[cid]} Unique Spell Analysis`, ''];
  lines.push(`- **Total class spells:** ${totalClassSpells}`);
  lines.push(`- **Exclusive (only ${CLASS_IDS[cid]}):** ${exclusiveSpells.length} (${((exclusiveSpells.length / totalClassSpells) * 100).toFixed(1)}%)`);
  lines.push(`- **Shared with others:** ${sharedSpells.length} (${((sharedSpells.length / totalClassSpells) * 100).toFixed(1)}%)`);

  // Exclusive spell categories
  const excCats: Record<string, number> = {};
  const excByCat: Record<string, typeof exclusiveSpells> = {};
  for (const spell of exclusiveSpells) {
    excCats[spell.category] = (excCats[spell.category] || 0) + 1;
    if (!excByCat[spell.category]) excByCat[spell.category] = [];
    excByCat[spell.category].push(spell);
  }

  lines.push('', '## Exclusive Spells by Category', '');
  const sortedExcCats = Object.entries(excCats).sort((a, b) => b[1] - a[1]);
  for (const [cat, count] of sortedExcCats) {
    lines.push(`### ${cat} (${count} exclusive spells)`);
    const spellsInCat = excByCat[cat].sort((a, b) => a.level - b.level);
    for (const spell of spellsInCat.slice(0, 10)) {
      const type = spell.beneficial ? 'ben' : 'det';
      lines.push(`  - Lv ${spell.level}: ${spell.name} (${type})`);
    }
    if (spellsInCat.length > 10) {
      lines.push(`  - *(+${spellsInCat.length - 10} more)*`);
    }
    lines.push('');
  }

  // Level distribution of exclusive spells
  lines.push('## Exclusive Spell Level Distribution', '');
  const excByLevel: Record<number, number> = {};
  for (const spell of exclusiveSpells) {
    const bracket = Math.floor((spell.level - 1) / 10) * 10 + 1;
    excByLevel[bracket] = (excByLevel[bracket] || 0) + 1;
  }
  for (const bracket of Object.keys(excByLevel).map(Number).sort((a, b) => a - b)) {
    const count = excByLevel[bracket];
    const bar = '#'.repeat(Math.min(Math.round(count / 2), 50));
    lines.push(`- **${bracket}-${bracket + 9}:** ${count} exclusive spells ${bar}`);
  }

  // Sharing distribution
  lines.push('', '## Shared Spell Distribution', '');
  const sharingDist: Record<number, number> = {};
  for (const spell of sharedSpells) {
    sharingDist[spell.sharedWith] = (sharingDist[spell.sharedWith] || 0) + 1;
  }
  for (const [shared, count] of Object.entries(sharingDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    const pct = ((count / sharedSpells.length) * 100).toFixed(1);
    lines.push(`- **Shared with ${shared} class${parseInt(shared) !== 1 ? 'es' : ''}:** ${count} spells (${pct}%)`);
  }

  // Most shared spells
  const mostShared = [...sharedSpells].sort((a, b) => b.sharedWith - a.sharedWith).slice(0, 10);
  if (mostShared.length > 0) {
    lines.push('', '## Most Widely Shared Spells', '');
    for (const spell of mostShared) {
      lines.push(`- **${spell.name}** (Lv ${spell.level}): shared with ${spell.sharedWith} classes`);
    }
  }

  return lines.join('\n');
}

// ============ TOOL #162: TELEPORT SPELL OVERVIEW ============

export async function getTeleportSpellOverview(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Collect all teleport spells
  const teleports: { id: number; name: string; zone: string; classes: string[] }[] = [];
  const zoneSpellCount: Record<string, number> = {};
  const zoneNames = new Set<string>();

  for (const [id, spell] of spells) {
    const tz = spell.fields[SF.TELEPORT_ZONE]?.trim();
    if (!tz || !/^[a-z_]+[a-z0-9_]*$/.test(tz)) continue;

    // Find which classes can use this spell
    const classes: string[] = [];
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < 255) classes.push(CLASS_SHORT[i]);
    }

    teleports.push({ id, name: spell.name, zone: tz, classes });
    zoneSpellCount[tz] = (zoneSpellCount[tz] || 0) + 1;
    zoneNames.add(tz);
  }

  if (teleports.length === 0) return 'No teleport spells found.';

  const lines = ['# Teleport Spell Overview', ''];
  lines.push(`- **Total teleport spells:** ${teleports.length}`);
  lines.push(`- **Unique destinations:** ${zoneNames.size}`);

  // Most-served zones
  lines.push('', '## Most-Served Destinations (Top 20)', '');
  lines.push('| Zone | Spells | Sample Spell Names |');
  lines.push('|------|--------|-------------------|');
  const sortedZones = Object.entries(zoneSpellCount).sort((a, b) => b[1] - a[1]).slice(0, 20);
  for (const [zone, count] of sortedZones) {
    const samples = teleports
      .filter(t => t.zone === zone)
      .slice(0, 3)
      .map(t => t.name)
      .join(', ');
    lines.push(`| ${zone} | ${count} | ${samples} |`);
  }

  // Class availability of teleport spells
  lines.push('', '## Teleport Spells by Class', '');
  const classTeleports: Record<string, number> = {};
  const classDestinations: Record<string, Set<string>> = {};
  for (const t of teleports) {
    for (const cls of t.classes) {
      classTeleports[cls] = (classTeleports[cls] || 0) + 1;
      if (!classDestinations[cls]) classDestinations[cls] = new Set();
      classDestinations[cls].add(t.zone);
    }
  }

  lines.push('| Class | Teleport Spells | Unique Destinations |');
  lines.push('|-------|----------------|-------------------|');
  const sortedClasses = Object.entries(classTeleports).sort((a, b) => b[1] - a[1]);
  for (const [cls, count] of sortedClasses) {
    const dests = classDestinations[cls]?.size || 0;
    lines.push(`| ${cls} | ${count} | ${dests} |`);
  }

  // Spells that teleport to unique/rare destinations (only 1 spell goes there)
  const uniqueDests = Object.entries(zoneSpellCount).filter(([, c]) => c === 1);
  if (uniqueDests.length > 0) {
    lines.push('', `## Unique Destinations (only 1 spell): ${uniqueDests.length} zones`, '');
    const udSpells = uniqueDests.slice(0, 20).map(([zone]) => {
      const spell = teleports.find(t => t.zone === zone)!;
      return `- **${zone}** — ${spell.name} (${spell.classes.join('/')})`;
    });
    lines.push(...udSpells);
    if (uniqueDests.length > 20) lines.push(`- *(+${uniqueDests.length - 20} more)*`);
  }

  // Alphabetical zone listing
  lines.push('', '## All Teleport Destinations (A-Z)', '');
  const allZones = [...zoneNames].sort();
  lines.push(allZones.join(', '));

  return lines.join('\n');
}

// ============ TOOL #163: COMBAT ABILITY OVERVIEW ============

export async function getCombatAbilityOverview(): Promise<string> {
  await loadCombatAbilities();
  if (!combatAbilities || combatAbilities.size === 0) return 'Combat ability data not available.';

  const lines = ['# Combat Ability Overview', ''];
  lines.push(`- **Total combat abilities/disciplines:** ${combatAbilities.size}`);

  // Word frequency analysis
  const wordFreq: Record<string, number> = {};
  const prefixes: Record<string, number> = {};
  const suffixes: Record<string, number> = {};
  const rankCounts: Record<string, number> = {};

  for (const name of combatAbilities.values()) {
    const words = name.split(/\s+/);
    for (const word of words) {
      const lower = word.toLowerCase().replace(/[^a-z]/g, '');
      if (lower.length >= 3) {
        wordFreq[lower] = (wordFreq[lower] || 0) + 1;
      }
    }

    // First word as prefix
    if (words.length > 0) {
      const prefix = words[0];
      prefixes[prefix] = (prefixes[prefix] || 0) + 1;
    }

    // Check for rank suffixes (Rk. II, Rk. III, etc.)
    const rankMatch = name.match(/Rk\.\s*(I+|IV|V+|X+)/);
    if (rankMatch) {
      const rank = `Rk. ${rankMatch[1]}`;
      rankCounts[rank] = (rankCounts[rank] || 0) + 1;
    }
  }

  // ID ranges
  const ids = [...combatAbilities.keys()].sort((a, b) => a - b);
  lines.push(`- **ID range:** ${ids[0]} to ${ids[ids.length - 1]}`);

  // Rank distribution
  const totalRanked = Object.values(rankCounts).reduce((s, v) => s + v, 0);
  const baseAbilities = combatAbilities.size - totalRanked;
  lines.push(`- **Base abilities (no rank):** ${baseAbilities}`);
  lines.push(`- **Ranked variants:** ${totalRanked}`);

  if (Object.keys(rankCounts).length > 0) {
    lines.push('', '## Rank Distribution', '');
    for (const [rank, count] of Object.entries(rankCounts).sort((a, b) => b[1] - a[1])) {
      lines.push(`- **${rank}:** ${count}`);
    }
  }

  // Most common words
  lines.push('', '## Most Common Words in Ability Names', '');
  const topWords = Object.entries(wordFreq)
    .filter(([w]) => !['rk', 'ii', 'iii', 'iv'].includes(w))
    .sort((a, b) => b[1] - a[1])
    .slice(0, 25);
  for (const [word, count] of topWords) {
    lines.push(`- **${word}:** ${count} occurrences`);
  }

  // Most common name prefixes (first word)
  lines.push('', '## Most Common Name Prefixes', '');
  const topPrefixes = Object.entries(prefixes).sort((a, b) => b[1] - a[1]).slice(0, 20);
  for (const [prefix, count] of topPrefixes) {
    lines.push(`- **${prefix}:** ${count} abilities`);
  }

  // Name length statistics
  const nameLengths = [...combatAbilities.values()].map(n => n.length);
  const avgLen = nameLengths.reduce((s, v) => s + v, 0) / nameLengths.length;
  const longest = [...combatAbilities.entries()].sort((a, b) => b[1].length - a[1].length).slice(0, 5);
  const shortest = [...combatAbilities.entries()].sort((a, b) => a[1].length - b[1].length).slice(0, 5);

  lines.push('', '## Name Statistics', '');
  lines.push(`- **Average name length:** ${avgLen.toFixed(1)} characters`);
  lines.push('', '**Longest names:**');
  for (const [id, name] of longest) {
    lines.push(`- ${name} (ID ${id}, ${name.length} chars)`);
  }
  lines.push('', '**Shortest names:**');
  for (const [id, name] of shortest) {
    lines.push(`- ${name} (ID ${id}, ${name.length} chars)`);
  }

  return lines.join('\n');
}

// ============ TOOL #164: ITEM EFFECT OVERVIEW ============

export async function getItemEffectOverview(): Promise<string> {
  await loadItemEffects();
  if (!itemEffectDescs || itemEffectDescs.size === 0) return 'Item effect data not available.';

  const lines = ['# Item Effect Descriptions Overview', ''];
  lines.push(`- **Total item effects:** ${itemEffectDescs.size}`);

  // Analyze descriptions
  const wordFreq: Record<string, number> = {};
  const descLengths: number[] = [];
  const keywordBuckets: Record<string, number> = {};

  const keywords = [
    'increase', 'decrease', 'damage', 'heal', 'resist', 'mana', 'strength',
    'stamina', 'agility', 'dexterity', 'wisdom', 'intelligence', 'charisma',
    'haste', 'slow', 'stun', 'root', 'snare', 'dot', 'proc', 'focus',
    'attack', 'defense', 'armor', 'hit points', 'regeneration', 'critical',
    'spell', 'melee', 'range', 'fire', 'cold', 'magic', 'poison', 'disease',
    'corruption', 'chromatic', 'prismatic', 'heroic', 'purity', 'luck',
  ];

  for (const desc of itemEffectDescs.values()) {
    descLengths.push(desc.length);
    const lower = desc.toLowerCase();

    // Keyword analysis
    for (const kw of keywords) {
      if (lower.includes(kw)) {
        keywordBuckets[kw] = (keywordBuckets[kw] || 0) + 1;
      }
    }

    // Word frequency
    const words = lower.split(/[^a-z]+/).filter(w => w.length >= 4);
    for (const word of words) {
      wordFreq[word] = (wordFreq[word] || 0) + 1;
    }
  }

  // Description length stats
  const sortedLens = [...descLengths].sort((a, b) => a - b);
  const avgLen = sortedLens.reduce((s, v) => s + v, 0) / sortedLens.length;
  lines.push(`- **Average description length:** ${avgLen.toFixed(0)} characters`);
  lines.push(`- **Shortest:** ${sortedLens[0]} characters`);
  lines.push(`- **Longest:** ${sortedLens[sortedLens.length - 1]} characters`);
  lines.push(`- **Median:** ${sortedLens[Math.floor(sortedLens.length / 2)]} characters`);

  // ID ranges
  const ids = [...itemEffectDescs.keys()].sort((a, b) => a - b);
  lines.push(`- **ID range:** ${ids[0]} to ${ids[ids.length - 1]}`);

  // Keyword frequency
  lines.push('', '## Effect Keyword Frequency', '');
  lines.push('| Keyword | Effects Mentioning | % of Total |');
  lines.push('|---------|-------------------|------------|');
  const sortedKeywords = Object.entries(keywordBuckets).sort((a, b) => b[1] - a[1]);
  for (const [kw, count] of sortedKeywords) {
    const pct = ((count / itemEffectDescs.size) * 100).toFixed(1);
    lines.push(`| ${kw} | ${count} | ${pct}% |`);
  }

  // Most common words
  lines.push('', '## Most Common Words in Descriptions', '');
  const topWords = Object.entries(wordFreq)
    .filter(([w]) => !['this', 'that', 'with', 'from', 'your', 'will', 'have', 'when', 'been', 'they', 'their'].includes(w))
    .sort((a, b) => b[1] - a[1])
    .slice(0, 25);
  for (const [word, count] of topWords) {
    lines.push(`- **${word}:** ${count}`);
  }

  // Sample effects by keyword category
  lines.push('', '## Sample Effects', '');
  const categories = [
    { name: 'Healing', keyword: 'heal' },
    { name: 'Damage', keyword: 'damage' },
    { name: 'Stat Boost', keyword: 'increase' },
    { name: 'Haste', keyword: 'haste' },
    { name: 'Focus', keyword: 'focus' },
    { name: 'Proc', keyword: 'proc' },
  ];
  for (const cat of categories) {
    const samples: string[] = [];
    for (const [id, desc] of itemEffectDescs) {
      if (samples.length >= 3) break;
      if (desc.toLowerCase().includes(cat.keyword)) {
        const truncated = desc.length > 80 ? desc.substring(0, 77) + '...' : desc;
        samples.push(`  - ID ${id}: ${truncated}`);
      }
    }
    if (samples.length > 0) {
      lines.push(`### ${cat.name}`);
      lines.push(...samples);
      lines.push('');
    }
  }

  return lines.join('\n');
}

// ============ TOOL #165: SPELL STACKING OVERVIEW ============

export async function getSpellStackingOverview(): Promise<string> {
  await loadSpellStacking();
  await loadSpells();
  if (!spellStacking || !spellGroupNames || spellGroupNames.size === 0) {
    return 'Spell stacking data not available.';
  }

  const lines = ['# Spell Stacking Group Overview', ''];
  lines.push(`- **Total stacking groups:** ${spellGroupNames.size}`);

  // Count spells per group
  const groupSpellCounts: Record<number, number> = {};
  const groupClassCoverage: Record<number, Set<number>> = {};

  for (const [spellId, entries] of spellStacking) {
    for (const entry of entries) {
      groupSpellCounts[entry.stackingGroup] = (groupSpellCounts[entry.stackingGroup] || 0) + 1;

      // Track which classes can use spells in this group
      const spell = spells?.get(spellId);
      if (spell) {
        if (!groupClassCoverage[entry.stackingGroup]) groupClassCoverage[entry.stackingGroup] = new Set();
        for (let i = 1; i <= 16; i++) {
          const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
          if (level > 0 && level < 255) groupClassCoverage[entry.stackingGroup].add(i);
        }
      }
    }
  }

  // Group size distribution
  const sizeDist: Record<number, number> = {};
  const groupSizes = Object.values(groupSpellCounts);
  for (const size of groupSizes) {
    const bucket = size <= 5 ? size : size <= 10 ? 10 : size <= 20 ? 20 : size <= 50 ? 50 : 100;
    sizeDist[bucket] = (sizeDist[bucket] || 0) + 1;
  }

  const totalSpellsInGroups = groupSizes.reduce((s, v) => s + v, 0);
  const avgSize = totalSpellsInGroups / groupSizes.length;
  lines.push(`- **Total spells with stacking data:** ${spellStacking.size}`);
  lines.push(`- **Average group size:** ${avgSize.toFixed(1)} spells`);

  lines.push('', '## Group Size Distribution', '');
  const sizeLabels: Record<number, string> = {
    1: '1 spell', 2: '2 spells', 3: '3 spells', 4: '4 spells', 5: '5 spells',
    10: '6-10 spells', 20: '11-20 spells', 50: '21-50 spells', 100: '51+ spells',
  };
  for (const [bucket, count] of Object.entries(sizeDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    const label = sizeLabels[parseInt(bucket)] || `${bucket} spells`;
    const bar = '#'.repeat(Math.min(count, 50));
    lines.push(`- **${label}:** ${count} groups ${bar}`);
  }

  // Largest groups
  lines.push('', '## Largest Stacking Groups (Top 15)', '');
  lines.push('| Group | Spells | Classes |');
  lines.push('|-------|--------|---------|');
  const sortedGroups = Object.entries(groupSpellCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 15);
  for (const [groupId, count] of sortedGroups) {
    const gid = parseInt(groupId);
    const name = spellGroupNames.get(gid) || `Group ${gid}`;
    const classCount = groupClassCoverage[gid]?.size || 0;
    lines.push(`| ${name} | ${count} | ${classCount} |`);
  }

  // Stacking type analysis
  const stackTypes: Record<number, number> = {};
  for (const entries of spellStacking.values()) {
    for (const entry of entries) {
      stackTypes[entry.stackingType] = (stackTypes[entry.stackingType] || 0) + 1;
    }
  }
  lines.push('', '## Stacking Type Distribution', '');
  for (const [type, count] of Object.entries(stackTypes).sort((a, b) => b[1] - a[1])) {
    const pct = ((count / totalSpellsInGroups) * 100).toFixed(1);
    lines.push(`- **Type ${type}:** ${count} entries (${pct}%)`);
  }

  // Class coverage analysis
  lines.push('', '## Groups by Class Coverage', '');
  const classCoverageDist: Record<number, number> = {};
  for (const classes of Object.values(groupClassCoverage)) {
    classCoverageDist[classes.size] = (classCoverageDist[classes.size] || 0) + 1;
  }
  for (const [classCount, groupCount] of Object.entries(classCoverageDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    lines.push(`- **${classCount} class${parseInt(classCount) !== 1 ? 'es' : ''}:** ${groupCount} groups`);
  }

  return lines.join('\n');
}

// ============ TOOL #166: SPELL AE ANALYSIS ============

export async function getSpellAEAnalysis(className?: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classFilter: number | undefined;
  let classLabel = 'All Classes';
  if (className) {
    const classId = Object.entries(CLASS_IDS).find(([, name]) =>
      name.toLowerCase() === className.toLowerCase()
    )?.[0];
    if (!classId) {
      const validClasses = Object.values(CLASS_IDS).join(', ');
      return `Unknown class "${className}". Valid classes: ${validClasses}`;
    }
    classFilter = parseInt(classId);
    classLabel = CLASS_IDS[classFilter];
  }

  // AE target types
  const AE_TYPES: Record<number, string> = {
    2: 'AE (PC v1)', 4: 'PB AE', 8: 'Targeted AE',
    40: 'AE (PC v2)', 42: 'Directional AE', 44: 'Beam',
    46: 'Target Ring AE',
  };

  let totalSpells = 0;
  let aeSpells = 0;
  const aeTypeCounts: Record<number, number> = {};
  const aeRanges: number[] = [];
  const aeRadii: number[] = [];
  const radiusBuckets: Record<string, number> = {};
  const aeByBeneficial: { beneficial: number; detrimental: number } = { beneficial: 0, detrimental: 0 };
  const largestAE: { name: string; radius: number; type: string }[] = [];

  for (const spell of spells.values()) {
    if (classFilter) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classFilter - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
    }
    totalSpells++;

    const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    if (!AE_TYPES[targetType]) continue;

    aeSpells++;
    aeTypeCounts[targetType] = (aeTypeCounts[targetType] || 0) + 1;

    const range = parseInt(spell.fields[SF.RANGE]) || 0;
    const aeRange = parseInt(spell.fields[SF.AE_RANGE]) || 0;
    if (range > 0) aeRanges.push(range);
    if (aeRange > 0) aeRadii.push(aeRange);

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    if (beneficial) aeByBeneficial.beneficial++;
    else aeByBeneficial.detrimental++;

    // Radius buckets
    let bucket: string;
    if (aeRange === 0) bucket = 'No radius';
    else if (aeRange <= 15) bucket = 'Small (1-15)';
    else if (aeRange <= 30) bucket = 'Medium (16-30)';
    else if (aeRange <= 50) bucket = 'Large (31-50)';
    else if (aeRange <= 100) bucket = 'Very Large (51-100)';
    else bucket = 'Massive (100+)';
    radiusBuckets[bucket] = (radiusBuckets[bucket] || 0) + 1;

    if (aeRange > 0) {
      largestAE.push({ name: spell.name, radius: aeRange, type: AE_TYPES[targetType] });
    }
  }

  const lines = [`# AE Spell Analysis: ${classLabel}`, ''];
  lines.push(`- **Total spells:** ${totalSpells}`);
  lines.push(`- **AE spells:** ${aeSpells} (${((aeSpells / totalSpells) * 100).toFixed(1)}%)`);
  lines.push(`- **Beneficial AE:** ${aeByBeneficial.beneficial}`);
  lines.push(`- **Detrimental AE:** ${aeByBeneficial.detrimental}`);

  // AE type breakdown
  lines.push('', '## AE Type Breakdown', '');
  lines.push('| Type | Count | % of AE Spells |');
  lines.push('|------|-------|---------------|');
  for (const [type, count] of Object.entries(aeTypeCounts).sort((a, b) => b[1] - a[1])) {
    const name = AE_TYPES[parseInt(type)];
    const pct = ((count / aeSpells) * 100).toFixed(1);
    lines.push(`| ${name} | ${count} | ${pct}% |`);
  }

  // Radius distribution
  if (aeRadii.length > 0) {
    const sorted = [...aeRadii].sort((a, b) => a - b);
    const avg = sorted.reduce((s, v) => s + v, 0) / sorted.length;
    lines.push('', '## AE Radius Statistics', '');
    lines.push(`- **AE spells with radius:** ${aeRadii.length}`);
    lines.push(`- **Average radius:** ${avg.toFixed(1)}`);
    lines.push(`- **Median radius:** ${sorted[Math.floor(sorted.length / 2)]}`);
    lines.push(`- **Range:** ${sorted[0]} to ${sorted[sorted.length - 1]}`);

    lines.push('', '### Radius Distribution', '');
    const bucketOrder = ['No radius', 'Small (1-15)', 'Medium (16-30)', 'Large (31-50)', 'Very Large (51-100)', 'Massive (100+)'];
    for (const bucket of bucketOrder) {
      const count = radiusBuckets[bucket] || 0;
      if (count > 0) {
        const pct = ((count / aeSpells) * 100).toFixed(1);
        lines.push(`- **${bucket}:** ${count} (${pct}%)`);
      }
    }
  }

  // Range analysis
  if (aeRanges.length > 0) {
    const sorted = [...aeRanges].sort((a, b) => a - b);
    const avg = sorted.reduce((s, v) => s + v, 0) / sorted.length;
    lines.push('', '## AE Spell Range to Target', '');
    lines.push(`- **Average range:** ${avg.toFixed(1)}`);
    lines.push(`- **Range:** ${sorted[0]} to ${sorted[sorted.length - 1]}`);
  }

  // Largest AE spells
  largestAE.sort((a, b) => b.radius - a.radius);
  lines.push('', '## Largest AE Radius Spells (Top 15)', '');
  for (const ae of largestAE.slice(0, 15)) {
    lines.push(`- **${ae.name}:** radius ${ae.radius} (${ae.type})`);
  }

  return lines.join('\n');
}

// ============ TOOL #167: OVERSEER MINION RARITY ANALYSIS ============

export async function getOverseerMinionRarityAnalysis(): Promise<string> {
  await loadOverseerMinions();
  await loadOverseerEnhancements();

  if (!overseerMinions || overseerMinions.size === 0) {
    return 'Overseer minion data not available.';
  }

  const lines = ['# Overseer Minion Rarity Analysis', ''];

  const RARITY_NAMES: Record<number, string> = {
    1: 'Common', 2: 'Uncommon', 3: 'Rare', 4: 'Elite', 5: 'Iconic',
  };

  // Rarity distribution
  const rarityDist: Record<number, number> = {};
  const rarityTraits: Record<number, Record<string, number>> = {}; // rarity -> trait -> count
  const rarityJobs: Record<number, Record<number, number>> = {}; // rarity -> jobTypeId -> count
  const rarityJobLevels: Record<number, number[]> = {}; // rarity -> job levels

  for (const minion of overseerMinions.values()) {
    rarityDist[minion.rarity] = (rarityDist[minion.rarity] || 0) + 1;

    if (!rarityTraits[minion.rarity]) rarityTraits[minion.rarity] = {};
    for (const trait of minion.traits) {
      rarityTraits[minion.rarity][trait] = (rarityTraits[minion.rarity][trait] || 0) + 1;
    }

    if (!rarityJobs[minion.rarity]) rarityJobs[minion.rarity] = {};
    if (!rarityJobLevels[minion.rarity]) rarityJobLevels[minion.rarity] = [];
    for (const job of minion.jobs) {
      rarityJobs[minion.rarity][job.jobTypeId] = (rarityJobs[minion.rarity][job.jobTypeId] || 0) + 1;
      rarityJobLevels[minion.rarity].push(job.level);
    }
  }

  lines.push(`- **Total minions:** ${overseerMinions.size}`);

  // Rarity distribution
  lines.push('', '## Rarity Distribution', '');
  for (const rarity of [1, 2, 3, 4, 5]) {
    const count = rarityDist[rarity] || 0;
    if (count > 0) {
      const pct = ((count / overseerMinions.size) * 100).toFixed(1);
      const bar = '#'.repeat(Math.min(Math.round(count / 3), 50));
      lines.push(`- **${RARITY_NAMES[rarity]}:** ${count} (${pct}%) ${bar}`);
    }
  }

  // Traits per rarity
  lines.push('', '## Average Traits by Rarity', '');
  for (const rarity of [1, 2, 3, 4, 5]) {
    const minionCount = rarityDist[rarity] || 0;
    if (minionCount === 0) continue;
    const totalTraits = Object.values(rarityTraits[rarity] || {}).reduce((s, v) => s + v, 0);
    const avg = totalTraits / minionCount;
    lines.push(`- **${RARITY_NAMES[rarity]}:** ${avg.toFixed(1)} traits per minion`);
  }

  // Job levels per rarity
  lines.push('', '## Job Levels by Rarity', '');
  lines.push('| Rarity | Avg Level | Min | Max | Jobs/Minion |');
  lines.push('|--------|-----------|-----|-----|-------------|');
  for (const rarity of [1, 2, 3, 4, 5]) {
    const levels = rarityJobLevels[rarity] || [];
    if (levels.length === 0) continue;
    const avg = levels.reduce((s, v) => s + v, 0) / levels.length;
    const min = Math.min(...levels);
    const max = Math.max(...levels);
    const minionCount = rarityDist[rarity] || 1;
    const jobsPerMinion = (levels.length / minionCount).toFixed(1);
    lines.push(`| ${RARITY_NAMES[rarity]} | ${avg.toFixed(1)} | ${min} | ${max} | ${jobsPerMinion} |`);
  }

  // Job type distribution per rarity
  lines.push('', '## Job Type Distribution by Rarity', '');
  for (const rarity of [1, 2, 3, 4, 5]) {
    const jobs = rarityJobs[rarity];
    if (!jobs || Object.keys(jobs).length === 0) continue;
    lines.push(`### ${RARITY_NAMES[rarity]}`);
    const sortedJobs = Object.entries(jobs).sort((a, b) => b[1] - a[1]);
    for (const [jobId, count] of sortedJobs) {
      const name = overseerJobNames?.get(parseInt(jobId)) || `Job ${jobId}`;
      lines.push(`  - ${name}: ${count}`);
    }
    lines.push('');
  }

  // Most common traits per rarity (top 5 each)
  lines.push('## Top Traits by Rarity', '');
  for (const rarity of [1, 2, 3, 4, 5]) {
    const traits = rarityTraits[rarity];
    if (!traits || Object.keys(traits).length === 0) continue;
    lines.push(`### ${RARITY_NAMES[rarity]}`);
    const topTraits = Object.entries(traits).sort((a, b) => b[1] - a[1]).slice(0, 5);
    for (const [trait, count] of topTraits) {
      lines.push(`  - ${trait}: ${count} minions`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL PUSHBACK OVERVIEW ============

export async function getSpellPushbackOverview(className?: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  let classId = 0;
  if (className) {
    const cn = className.toLowerCase().trim();
    const entry = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === cn);
    if (!entry) return `Unknown class: "${className}". Valid: ${Object.values(CLASS_IDS).join(', ')}`;
    classId = parseInt(entry[0]);
  }

  const title = classId ? CLASS_IDS[classId] : 'All Classes';
  const lines = [`# Spell Pushback/Positioning Overview: ${title}`, ''];

  // Collect spells with pushback or pushup
  const pushbackSpells: { name: string; pushBack: number; pushUp: number; beneficial: boolean }[] = [];
  let totalSpells = 0;

  for (const spell of spells.values()) {
    if (classId) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]);
      if (isNaN(level) || level < 1 || level > 254) continue;
    }
    totalSpells++;

    const pushBack = parseFloat(spell.fields[SF.PUSH_BACK]) || 0;
    const pushUp = parseFloat(spell.fields[SF.PUSH_UP]) || 0;
    if (pushBack > 0 || pushUp > 0) {
      pushbackSpells.push({
        name: spell.name,
        pushBack,
        pushUp,
        beneficial: spell.fields[SF.BENEFICIAL] === '1',
      });
    }
  }

  lines.push(`- **Total spells:** ${totalSpells.toLocaleString()}`);
  lines.push(`- **Spells with positioning effects:** ${pushbackSpells.length} (${(pushbackSpells.length / totalSpells * 100).toFixed(1)}%)`);

  const withPushback = pushbackSpells.filter(s => s.pushBack > 0);
  const withPushup = pushbackSpells.filter(s => s.pushUp > 0);
  const withBoth = pushbackSpells.filter(s => s.pushBack > 0 && s.pushUp > 0);

  lines.push(`- **With pushback:** ${withPushback.length}`);
  lines.push(`- **With pushup (launch):** ${withPushup.length}`);
  lines.push(`- **With both pushback AND pushup:** ${withBoth.length}`);
  lines.push(`- **Beneficial with positioning:** ${pushbackSpells.filter(s => s.beneficial).length}`);
  lines.push(`- **Detrimental with positioning:** ${pushbackSpells.filter(s => !s.beneficial).length}`);

  // Pushback value distribution
  const pushbackBuckets = new Map<string, number>();
  for (const s of withPushback) {
    const bucket = s.pushBack <= 1 ? '0-1' : s.pushBack <= 5 ? '2-5' : s.pushBack <= 10 ? '6-10' : s.pushBack <= 25 ? '11-25' : s.pushBack <= 50 ? '26-50' : '51+';
    pushbackBuckets.set(bucket, (pushbackBuckets.get(bucket) || 0) + 1);
  }

  if (pushbackBuckets.size > 0) {
    lines.push('', '## Pushback Value Distribution', '');
    lines.push('| Range | Count |');
    lines.push('|-------|-------|');
    for (const bucket of ['0-1', '2-5', '6-10', '11-25', '26-50', '51+']) {
      const count = pushbackBuckets.get(bucket) || 0;
      if (count > 0) lines.push(`| ${bucket} | ${count} |`);
    }
  }

  // Pushup value distribution
  const pushupBuckets = new Map<string, number>();
  for (const s of withPushup) {
    const bucket = s.pushUp <= 1 ? '0-1' : s.pushUp <= 5 ? '2-5' : s.pushUp <= 10 ? '6-10' : s.pushUp <= 25 ? '11-25' : s.pushUp <= 50 ? '26-50' : '51+';
    pushupBuckets.set(bucket, (pushupBuckets.get(bucket) || 0) + 1);
  }

  if (pushupBuckets.size > 0) {
    lines.push('', '## Pushup (Launch) Value Distribution', '');
    lines.push('| Range | Count |');
    lines.push('|-------|-------|');
    for (const bucket of ['0-1', '2-5', '6-10', '11-25', '26-50', '51+']) {
      const count = pushupBuckets.get(bucket) || 0;
      if (count > 0) lines.push(`| ${bucket} | ${count} |`);
    }
  }

  // Top pushback spells
  const topPushback = [...withPushback].sort((a, b) => b.pushBack - a.pushBack).slice(0, 15);
  if (topPushback.length > 0) {
    lines.push('', '## Highest Pushback Spells (Top 15)', '');
    lines.push('| Spell | Pushback | Pushup | Type |');
    lines.push('|-------|----------|--------|------|');
    for (const s of topPushback) {
      lines.push(`| ${s.name} | ${s.pushBack} | ${s.pushUp || '-'} | ${s.beneficial ? 'Beneficial' : 'Detrimental'} |`);
    }
  }

  // Top pushup spells
  const topPushup = [...withPushup].sort((a, b) => b.pushUp - a.pushUp).slice(0, 15);
  if (topPushup.length > 0) {
    lines.push('', '## Highest Pushup (Launch) Spells (Top 15)', '');
    lines.push('| Spell | Pushup | Pushback | Type |');
    lines.push('|-------|--------|----------|------|');
    for (const s of topPushup) {
      lines.push(`| ${s.name} | ${s.pushUp} | ${s.pushBack || '-'} | ${s.beneficial ? 'Beneficial' : 'Detrimental'} |`);
    }
  }

  // Spells with both pushback AND pushup
  if (withBoth.length > 0) {
    lines.push('', '## Spells with Both Pushback AND Pushup', '');
    const sorted = [...withBoth].sort((a, b) => (b.pushBack + b.pushUp) - (a.pushBack + a.pushUp)).slice(0, 20);
    for (const s of sorted) {
      lines.push(`- **${s.name}**: pushback=${s.pushBack}, pushup=${s.pushUp} (${s.beneficial ? 'Beneficial' : 'Detrimental'})`);
    }
  }

  // Class comparison (only if showing all classes)
  if (!classId) {
    lines.push('', '## Positioning Spells by Class', '');
    lines.push('| Class | Pushback | Pushup | Both | Total |');
    lines.push('|-------|----------|--------|------|-------|');

    for (let cid = 1; cid <= 16; cid++) {
      let pb = 0, pu = 0, both = 0, total = 0;
      for (const spell of spells.values()) {
        const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]);
        if (isNaN(level) || level < 1 || level > 254) continue;
        const pushBack = parseFloat(spell.fields[SF.PUSH_BACK]) || 0;
        const pushUp = parseFloat(spell.fields[SF.PUSH_UP]) || 0;
        if (pushBack > 0 || pushUp > 0) {
          total++;
          if (pushBack > 0) pb++;
          if (pushUp > 0) pu++;
          if (pushBack > 0 && pushUp > 0) both++;
        }
      }
      if (total > 0) {
        lines.push(`| ${CLASS_SHORT[cid]} | ${pb} | ${pu} | ${both} | ${total} |`);
      }
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: ACHIEVEMENT REQUIREMENT ANALYSIS ============

export async function getAchievementRequirementAnalysis(): Promise<string> {
  await loadAchievementComponents();
  await loadAchievements();
  if (!achievementComponents || achievementComponents.size === 0) return 'Achievement component data not available.';

  const lines = ['# Achievement Requirement Value Analysis', ''];

  // Collect all requirement values
  const allRequirements: number[] = [];
  const reqByType = new Map<number, number[]>();
  let zeroReqs = 0;
  let maxReq = 0;
  let maxReqName = '';
  let maxReqAchId = 0;

  for (const [achId, components] of achievementComponents) {
    for (const comp of components) {
      allRequirements.push(comp.requirement);
      if (comp.requirement === 0) zeroReqs++;
      if (comp.requirement > maxReq) {
        maxReq = comp.requirement;
        maxReqAchId = achId;
        maxReqName = comp.description || `Component ${comp.componentNum}`;
      }

      if (!reqByType.has(comp.type)) reqByType.set(comp.type, []);
      reqByType.get(comp.type)!.push(comp.requirement);
    }
  }

  const nonZero = allRequirements.filter(r => r > 0);
  const avg = nonZero.length > 0 ? nonZero.reduce((a, b) => a + b, 0) / nonZero.length : 0;
  nonZero.sort((a, b) => a - b);
  const median = nonZero.length > 0 ? nonZero[Math.floor(nonZero.length / 2)] : 0;

  lines.push(`- **Total components:** ${allRequirements.length.toLocaleString()}`);
  lines.push(`- **Zero-requirement components:** ${zeroReqs.toLocaleString()} (${(zeroReqs / allRequirements.length * 100).toFixed(1)}%)`);
  lines.push(`- **Non-zero requirements:** ${nonZero.length.toLocaleString()}`);
  lines.push(`- **Average requirement (non-zero):** ${avg.toFixed(1)}`);
  lines.push(`- **Median requirement (non-zero):** ${median.toLocaleString()}`);
  lines.push(`- **Maximum requirement:** ${maxReq.toLocaleString()}`);

  // Look up achievement name for max requirement
  if (maxReqAchId && achievements) {
    const ach = achievements.get(maxReqAchId);
    if (ach) {
      lines.push(`  - Achievement: ${ach.name}, Component: ${maxReqName}`);
    }
  }

  // Requirement value buckets
  const buckets = new Map<string, number>();
  const bucketOrder = ['0', '1', '2-5', '6-10', '11-25', '26-50', '51-100', '101-500', '501-1000', '1001-5000', '5001+'];
  for (const r of allRequirements) {
    const bucket = r === 0 ? '0' : r === 1 ? '1' : r <= 5 ? '2-5' : r <= 10 ? '6-10' : r <= 25 ? '11-25' : r <= 50 ? '26-50' : r <= 100 ? '51-100' : r <= 500 ? '101-500' : r <= 1000 ? '501-1000' : r <= 5000 ? '1001-5000' : '5001+';
    buckets.set(bucket, (buckets.get(bucket) || 0) + 1);
  }

  lines.push('', '## Requirement Value Distribution', '');
  lines.push('| Range | Count | % |');
  lines.push('|-------|-------|---|');
  for (const bucket of bucketOrder) {
    const count = buckets.get(bucket) || 0;
    if (count > 0) {
      lines.push(`| ${bucket} | ${count.toLocaleString()} | ${(count / allRequirements.length * 100).toFixed(1)}% |`);
    }
  }

  // Requirements by component type
  lines.push('', '## Requirement Statistics by Component Type', '');
  lines.push('| Type | Count | Avg Req | Median Req | Max Req |');
  lines.push('|------|-------|---------|------------|---------|');
  const sortedTypes = [...reqByType.entries()].sort((a, b) => b[1].length - a[1].length);
  for (const [type, reqs] of sortedTypes) {
    const nz = reqs.filter(r => r > 0);
    nz.sort((a, b) => a - b);
    const typeAvg = nz.length > 0 ? nz.reduce((a, b) => a + b, 0) / nz.length : 0;
    const typeMedian = nz.length > 0 ? nz[Math.floor(nz.length / 2)] : 0;
    const typeMax = nz.length > 0 ? nz[nz.length - 1] : 0;
    lines.push(`| ${type} | ${reqs.length} | ${typeAvg.toFixed(1)} | ${typeMedian.toLocaleString()} | ${typeMax.toLocaleString()} |`);
  }

  // Top 15 highest requirement components
  const topReqs: { achId: number; comp: AchievementComponent }[] = [];
  for (const [achId, components] of achievementComponents) {
    for (const comp of components) {
      topReqs.push({ achId, comp });
    }
  }
  topReqs.sort((a, b) => b.comp.requirement - a.comp.requirement);

  lines.push('', '## Highest Requirement Components (Top 15)', '');
  lines.push('| Achievement | Component | Type | Requirement |');
  lines.push('|-------------|-----------|------|-------------|');
  for (const { achId, comp } of topReqs.slice(0, 15)) {
    const achName = achievements?.get(achId)?.name || `#${achId}`;
    const desc = comp.description || `Step ${comp.componentNum}`;
    lines.push(`| ${achName} | ${desc.substring(0, 50)} | ${comp.type} | ${comp.requirement.toLocaleString()} |`);
  }

  // Achievements with most total requirements (sum)
  const achTotalReqs: { achId: number; total: number; count: number }[] = [];
  for (const [achId, components] of achievementComponents) {
    const total = components.reduce((sum, c) => sum + c.requirement, 0);
    achTotalReqs.push({ achId, total, count: components.length });
  }
  achTotalReqs.sort((a, b) => b.total - a.total);

  lines.push('', '## Most Demanding Achievements (Highest Total Requirements)', '');
  lines.push('| Achievement | Steps | Total Requirement |');
  lines.push('|-------------|-------|-------------------|');
  for (const { achId, total, count } of achTotalReqs.slice(0, 15)) {
    const achName = achievements?.get(achId)?.name || `#${achId}`;
    lines.push(`| ${achName} | ${count} | ${total.toLocaleString()} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: FACTION STARTING VALUE ANALYSIS ============

export async function getFactionStartingValueAnalysis(): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Faction Starting Value Analysis', ''];

  // Collect all factions with starting values
  const factionsWithModifiers: { id: number; name: string; startingValues: { modifierId: number; value: number }[] }[] = [];
  let totalModifiers = 0;

  for (const [, faction] of factions) {
    if (faction.startingValues && faction.startingValues.length > 0) {
      factionsWithModifiers.push({ id: faction.id, name: faction.name, startingValues: faction.startingValues });
      totalModifiers += faction.startingValues.length;
    }
  }

  lines.push(`- **Total factions:** ${factions.size.toLocaleString()}`);
  lines.push(`- **Factions with starting modifiers:** ${factionsWithModifiers.length}`);
  lines.push(`- **Total starting modifiers:** ${totalModifiers.toLocaleString()}`);
  lines.push(`- **Average modifiers per faction (with any):** ${(totalModifiers / factionsWithModifiers.length).toFixed(1)}`);

  // Separate race, class, deity modifiers
  const raceModifiers: { factionName: string; raceName: string; value: number }[] = [];
  const classModifiers: { factionName: string; className: string; value: number }[] = [];
  const deityModifiers: { factionName: string; deityName: string; value: number }[] = [];
  const otherModifiers: { factionName: string; modId: number; value: number }[] = [];

  for (const faction of factionsWithModifiers) {
    for (const sv of faction.startingValues) {
      const modName = factionModifierNames?.get(sv.modifierId) || '';
      if (PLAYABLE_RACE_MODIFIER_IDS.has(sv.modifierId) || modName.startsWith('Race:')) {
        raceModifiers.push({ factionName: faction.name, raceName: modName.replace(/^Race:\s*/, '') || `Race ${sv.modifierId}`, value: sv.value });
      } else if (DEITY_MODIFIER_IDS.has(sv.modifierId)) {
        deityModifiers.push({ factionName: faction.name, deityName: modName.replace(/^Deity:\s*/, '') || `Deity ${sv.modifierId}`, value: sv.value });
      } else if (modName.startsWith('Class:')) {
        classModifiers.push({ factionName: faction.name, className: modName.replace(/^Class:\s*/, ''), value: sv.value });
      } else {
        otherModifiers.push({ factionName: faction.name, modId: sv.modifierId, value: sv.value });
      }
    }
  }

  lines.push(`- **Race modifiers:** ${raceModifiers.length}`);
  lines.push(`- **Class modifiers:** ${classModifiers.length}`);
  lines.push(`- **Deity modifiers:** ${deityModifiers.length}`);
  if (otherModifiers.length > 0) lines.push(`- **Other modifiers:** ${otherModifiers.length}`);

  // Value distribution (positive vs negative)
  const allValues = [...raceModifiers.map(m => m.value), ...classModifiers.map(m => m.value), ...deityModifiers.map(m => m.value)];
  const positiveValues = allValues.filter(v => v > 0);
  const negativeValues = allValues.filter(v => v < 0);
  const zeroValues = allValues.filter(v => v === 0);

  lines.push('', '## Value Distribution', '');
  lines.push(`- **Positive (friendly):** ${positiveValues.length} (${(positiveValues.length / allValues.length * 100).toFixed(1)}%)`);
  lines.push(`- **Negative (hostile):** ${negativeValues.length} (${(negativeValues.length / allValues.length * 100).toFixed(1)}%)`);
  if (zeroValues.length > 0) lines.push(`- **Zero:** ${zeroValues.length}`);

  if (positiveValues.length > 0) {
    positiveValues.sort((a, b) => a - b);
    lines.push(`- **Positive range:** ${positiveValues[0]} to ${positiveValues[positiveValues.length - 1]}`);
  }
  if (negativeValues.length > 0) {
    negativeValues.sort((a, b) => a - b);
    lines.push(`- **Negative range:** ${negativeValues[0]} to ${negativeValues[negativeValues.length - 1]}`);
  }

  // Race impact summary
  if (raceModifiers.length > 0) {
    lines.push('', '## Race Starting Faction Impact', '');

    const byRace = new Map<string, { positive: number; negative: number; total: number; sumPositive: number; sumNegative: number }>();
    for (const m of raceModifiers) {
      if (!byRace.has(m.raceName)) byRace.set(m.raceName, { positive: 0, negative: 0, total: 0, sumPositive: 0, sumNegative: 0 });
      const entry = byRace.get(m.raceName)!;
      entry.total++;
      if (m.value > 0) { entry.positive++; entry.sumPositive += m.value; }
      else if (m.value < 0) { entry.negative++; entry.sumNegative += m.value; }
    }

    lines.push('| Race | Factions Affected | Positive | Negative | Net Balance |');
    lines.push('|------|-------------------|----------|----------|-------------|');
    const sortedRaces = [...byRace.entries()].sort((a, b) => b[1].total - a[1].total);
    for (const [race, data] of sortedRaces) {
      const net = data.sumPositive + data.sumNegative;
      lines.push(`| ${race} | ${data.total} | ${data.positive} (+${data.sumPositive}) | ${data.negative} (${data.sumNegative}) | ${net >= 0 ? '+' : ''}${net} |`);
    }
  }

  // Class impact summary
  if (classModifiers.length > 0) {
    lines.push('', '## Class Starting Faction Impact', '');

    const byClass = new Map<string, { positive: number; negative: number; total: number; sumPositive: number; sumNegative: number }>();
    for (const m of classModifiers) {
      if (!byClass.has(m.className)) byClass.set(m.className, { positive: 0, negative: 0, total: 0, sumPositive: 0, sumNegative: 0 });
      const entry = byClass.get(m.className)!;
      entry.total++;
      if (m.value > 0) { entry.positive++; entry.sumPositive += m.value; }
      else if (m.value < 0) { entry.negative++; entry.sumNegative += m.value; }
    }

    lines.push('| Class | Factions Affected | Positive | Negative | Net Balance |');
    lines.push('|-------|-------------------|----------|----------|-------------|');
    const sortedClasses = [...byClass.entries()].sort((a, b) => b[1].total - a[1].total);
    for (const [cls, data] of sortedClasses) {
      const net = data.sumPositive + data.sumNegative;
      lines.push(`| ${cls} | ${data.total} | ${data.positive} (+${data.sumPositive}) | ${data.negative} (${data.sumNegative}) | ${net >= 0 ? '+' : ''}${net} |`);
    }
  }

  // Deity impact summary
  if (deityModifiers.length > 0) {
    lines.push('', '## Deity Starting Faction Impact', '');

    const byDeity = new Map<string, { positive: number; negative: number; total: number; sumPositive: number; sumNegative: number }>();
    for (const m of deityModifiers) {
      if (!byDeity.has(m.deityName)) byDeity.set(m.deityName, { positive: 0, negative: 0, total: 0, sumPositive: 0, sumNegative: 0 });
      const entry = byDeity.get(m.deityName)!;
      entry.total++;
      if (m.value > 0) { entry.positive++; entry.sumPositive += m.value; }
      else if (m.value < 0) { entry.negative++; entry.sumNegative += m.value; }
    }

    lines.push('| Deity | Factions Affected | Positive | Negative | Net Balance |');
    lines.push('|-------|-------------------|----------|----------|-------------|');
    const sortedDeities = [...byDeity.entries()].sort((a, b) => b[1].total - a[1].total);
    for (const [deity, data] of sortedDeities) {
      const net = data.sumPositive + data.sumNegative;
      lines.push(`| ${deity} | ${data.total} | ${data.positive} (+${data.sumPositive}) | ${data.negative} (${data.sumNegative}) | ${net >= 0 ? '+' : ''}${net} |`);
    }
  }

  // Factions most affected by starting modifiers (most modifiers)
  const sortedFactions = [...factionsWithModifiers].sort((a, b) => b.startingValues.length - a.startingValues.length);
  lines.push('', '## Most Modified Factions (Most Starting Value Adjustments)', '');
  lines.push('| Faction | Modifiers | Most Positive | Most Negative |');
  lines.push('|---------|-----------|---------------|---------------|');
  for (const faction of sortedFactions.slice(0, 15)) {
    const sorted = [...faction.startingValues].sort((a, b) => b.value - a.value);
    const bestMod = sorted[0];
    const worstMod = sorted[sorted.length - 1];
    const bestName = factionModifierNames?.get(bestMod.modifierId) || `#${bestMod.modifierId}`;
    const worstName = factionModifierNames?.get(worstMod.modifierId) || `#${worstMod.modifierId}`;
    lines.push(`| ${faction.name} | ${faction.startingValues.length} | ${bestName}: +${bestMod.value} | ${worstName}: ${worstMod.value} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: MERCENARY TIER ANALYSIS ============

export async function getMercenaryTierAnalysis(): Promise<string> {
  await loadMercenaries();
  if (!mercenaries || mercenaries.size === 0) return 'Mercenary data not available.';

  const lines = ['# Mercenary Tier & Proficiency Analysis', ''];

  // Collect distributions
  const byConfidence: Record<string, number> = {};
  const byProficiency: Record<string, number> = {};
  const byTier: Record<string, number> = {};
  const byType: Record<string, number> = {};
  const tierByType: Record<string, Record<string, number>> = {};
  const confByProf: Record<string, Record<string, number>> = {};
  const raceByType: Record<string, Record<string, number>> = {};
  let withConfidence = 0;
  let withProficiency = 0;

  for (const merc of mercenaries.values()) {
    const tier = merc.tier || 'Unknown';
    const type = merc.type || 'Unknown';
    const confidence = merc.confidence || 'Unknown';
    const proficiency = merc.proficiency || 'Unknown';
    const race = merc.race || 'Unknown';

    byTier[tier] = (byTier[tier] || 0) + 1;
    byType[type] = (byType[type] || 0) + 1;

    if (merc.confidence) {
      withConfidence++;
      byConfidence[confidence] = (byConfidence[confidence] || 0) + 1;
    }
    if (merc.proficiency) {
      withProficiency++;
      byProficiency[proficiency] = (byProficiency[proficiency] || 0) + 1;
    }

    // Tier by type matrix
    if (!tierByType[type]) tierByType[type] = {};
    tierByType[type][tier] = (tierByType[type][tier] || 0) + 1;

    // Confidence by proficiency cross-tab
    if (merc.confidence && merc.proficiency) {
      if (!confByProf[confidence]) confByProf[confidence] = {};
      confByProf[confidence][proficiency] = (confByProf[confidence][proficiency] || 0) + 1;
    }

    // Race by type
    if (merc.race) {
      if (!raceByType[type]) raceByType[type] = {};
      raceByType[type][race] = (raceByType[type][race] || 0) + 1;
    }
  }

  lines.push(`- **Total mercenary templates:** ${mercenaries.size.toLocaleString()}`);
  lines.push(`- **With confidence level:** ${withConfidence.toLocaleString()}`);
  lines.push(`- **With proficiency level:** ${withProficiency.toLocaleString()}`);
  lines.push(`- **Unique tiers:** ${Object.keys(byTier).length}`);
  lines.push(`- **Unique types:** ${Object.keys(byType).length}`);

  // Confidence distribution
  if (Object.keys(byConfidence).length > 0) {
    lines.push('', '## Confidence Level Distribution', '');
    lines.push('| Confidence | Count | % |');
    lines.push('|------------|-------|---|');
    const sortedConf = Object.entries(byConfidence).sort((a, b) => b[1] - a[1]);
    for (const [conf, count] of sortedConf) {
      lines.push(`| ${conf} | ${count.toLocaleString()} | ${(count / mercenaries.size * 100).toFixed(1)}% |`);
    }
  }

  // Proficiency distribution
  if (Object.keys(byProficiency).length > 0) {
    lines.push('', '## Proficiency Level Distribution', '');
    lines.push('| Proficiency | Count | % |');
    lines.push('|-------------|-------|---|');
    const sortedProf = Object.entries(byProficiency).sort((a, b) => b[1] - a[1]);
    for (const [prof, count] of sortedProf) {
      lines.push(`| ${prof} | ${count.toLocaleString()} | ${(count / mercenaries.size * 100).toFixed(1)}% |`);
    }
  }

  // Tier by type matrix
  const types = Object.keys(tierByType).sort();
  const allTiers = [...new Set(Object.values(tierByType).flatMap(t => Object.keys(t)))].sort();
  if (types.length > 0 && allTiers.length > 0) {
    lines.push('', '## Type by Tier Matrix', '');
    lines.push(`| Type | ${allTiers.join(' | ')} | Total |`);
    lines.push(`|------|${allTiers.map(() => '---').join('|')}|-------|`);
    for (const type of types) {
      const total = Object.values(tierByType[type]).reduce((a, b) => a + b, 0);
      const cells = allTiers.map(tier => tierByType[type][tier] || 0);
      lines.push(`| ${type} | ${cells.join(' | ')} | ${total} |`);
    }
  }

  // Confidence by proficiency cross-tab
  const confs = Object.keys(confByProf).sort();
  const allProfs = [...new Set(Object.values(confByProf).flatMap(p => Object.keys(p)))].sort();
  if (confs.length > 0 && allProfs.length > 0) {
    lines.push('', '## Confidence by Proficiency Cross-Tab', '');
    lines.push(`| Confidence | ${allProfs.join(' | ')} | Total |`);
    lines.push(`|------------|${allProfs.map(() => '---').join('|')}|-------|`);
    for (const conf of confs) {
      const total = Object.values(confByProf[conf]).reduce((a, b) => a + b, 0);
      const cells = allProfs.map(prof => confByProf[conf][prof] || 0);
      lines.push(`| ${conf} | ${cells.join(' | ')} | ${total} |`);
    }
  }

  // Race by type (top races per type)
  if (Object.keys(raceByType).length > 0) {
    lines.push('', '## Top Races by Mercenary Type', '');
    for (const type of types) {
      if (!raceByType[type]) continue;
      const sorted = Object.entries(raceByType[type]).sort((a, b) => b[1] - a[1]).slice(0, 8);
      lines.push(`### ${type}`);
      for (const [race, count] of sorted) {
        lines.push(`  - ${race}: ${count}`);
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL RECOURSE OVERVIEW ============

export async function getSpellRecourseOverview(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';
  await loadSpellDescriptions();

  const lines = ['# Spell Recourse System Overview', ''];
  lines.push('*A recourse spell is automatically cast on the caster when the main spell successfully lands on a target.*', '');

  // Collect all recourse relationships
  const recourseSpells: { id: number; name: string; recourseId: number; recourseName: string; catId: number; beneficial: boolean }[] = [];
  const recourseTargets = new Map<number, string[]>(); // recourseId -> [main spell names]

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const recourseId = parseInt(spell.fields[SF.RECOURSE]);
    if (!recourseId || recourseId <= 0 || recourseId === spell.id) continue;

    const recourseSpell = spells.get(recourseId);
    const recourseName = recourseSpell ? recourseSpell.name : `Spell #${recourseId}`;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    recourseSpells.push({ id: spell.id, name: spell.name, recourseId, recourseName, catId, beneficial });

    if (!recourseTargets.has(recourseId)) recourseTargets.set(recourseId, []);
    recourseTargets.get(recourseId)!.push(spell.name);
  }

  lines.push(`- **Spells with recourse effects:** ${recourseSpells.length.toLocaleString()}`);
  lines.push(`- **Unique recourse targets:** ${recourseTargets.size.toLocaleString()}`);
  lines.push(`- **Beneficial with recourse:** ${recourseSpells.filter(s => s.beneficial).length}`);
  lines.push(`- **Detrimental with recourse:** ${recourseSpells.filter(s => !s.beneficial).length}`);

  // Check for recourse chains (A triggers B, B triggers C)
  const chains: { chain: string[]; depth: number }[] = [];
  for (const spell of recourseSpells) {
    const chain = [spell.name];
    let currentId = spell.recourseId;
    const visited = new Set<number>([spell.id]);
    while (currentId && !visited.has(currentId)) {
      visited.add(currentId);
      const next = spells.get(currentId);
      if (!next) break;
      chain.push(next.name);
      const nextRecourse = parseInt(next.fields[SF.RECOURSE]);
      if (!nextRecourse || nextRecourse <= 0 || nextRecourse === currentId) break;
      currentId = nextRecourse;
    }
    if (chain.length > 2) {
      chains.push({ chain, depth: chain.length });
    }
  }

  if (chains.length > 0) {
    lines.push(`- **Recourse chains (depth > 2):** ${chains.length}`);
    lines.push('', '## Recourse Chains (Multi-Step)', '');
    const sortedChains = chains.sort((a, b) => b.depth - a.depth).slice(0, 15);
    for (const { chain } of sortedChains) {
      lines.push(`- ${chain.join(' → ')}`);
    }
  }

  // Most common recourse targets (spells triggered by many different spells)
  const sortedTargets = [...recourseTargets.entries()].sort((a, b) => b[1].length - a[1].length);
  lines.push('', '## Most Common Recourse Targets (Triggered by Multiple Spells)', '');
  lines.push('| Recourse Spell | Triggered By | Sample Main Spells |');
  lines.push('|----------------|-------------|-------------------|');
  for (const [recId, mainSpells] of sortedTargets.slice(0, 20)) {
    const recSpell = spells.get(recId);
    const recName = recSpell ? recSpell.name : `#${recId}`;
    const sample = mainSpells.slice(0, 3).join(', ');
    lines.push(`| ${recName} | ${mainSpells.length} spells | ${sample} |`);
  }

  // Category distribution
  const catCounts = new Map<string, number>();
  for (const spell of recourseSpells) {
    const catName = (spellCategories && spellCategories.get(spell.catId)) || 'Unknown';
    catCounts.set(catName, (catCounts.get(catName) || 0) + 1);
  }

  lines.push('', '## Recourse Spells by Category', '');
  lines.push('| Category | Count | % |');
  lines.push('|----------|-------|---|');
  const sortedCats = [...catCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [cat, count] of sortedCats.slice(0, 15)) {
    lines.push(`| ${cat} | ${count} | ${(count / recourseSpells.length * 100).toFixed(1)}% |`);
  }

  // Class distribution
  lines.push('', '## Recourse Spells by Class', '');
  lines.push('| Class | Recourse Spells |');
  lines.push('|-------|----------------|');
  for (let cid = 1; cid <= 16; cid++) {
    let count = 0;
    for (const spell of recourseSpells) {
      const s = spells.get(spell.id);
      if (!s) continue;
      const level = parseInt(s.fields[SF.CLASS_LEVEL_START + cid - 1]);
      if (!isNaN(level) && level >= 1 && level <= 254) count++;
    }
    if (count > 0) {
      lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${count} |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: TRIBUTE BENEFIT ANALYSIS ============

export async function getTributeBenefitAnalysis(): Promise<string> {
  await loadTributes();
  if (!tributes || tributes.size === 0) return 'Tribute data not available.';

  const lines = ['# Tribute System Analysis', ''];

  let personalCount = 0;
  let guildCount = 0;
  let withDesc = 0;
  let totalDescLen = 0;

  const keywords = new Map<string, number>();
  const keywordPatterns = [
    'hit points', 'mana', 'endurance', 'attack', 'damage', 'healing',
    'haste', 'resist', 'armor class', 'regenerat', 'accuracy', 'avoidance',
    'strength', 'stamina', 'agility', 'dexterity', 'wisdom', 'intelligence', 'charisma',
    'critical', 'flurry', 'shield', 'proc', 'spell', 'melee',
    'focus', 'combat', 'experience', 'mod2', 'heroic',
  ];

  const nameWords = new Map<string, number>();

  for (const tribute of tributes.values()) {
    if (tribute.isGuild) guildCount++;
    else personalCount++;

    if (tribute.description && tribute.description.length > 0) {
      withDesc++;
      totalDescLen += tribute.description.length;

      const lowerDesc = tribute.description.toLowerCase();
      for (const kw of keywordPatterns) {
        if (lowerDesc.includes(kw)) {
          keywords.set(kw, (keywords.get(kw) || 0) + 1);
        }
      }
    }

    // Name word frequency
    const words = tribute.name.toLowerCase().split(/\s+/);
    for (const word of words) {
      if (word.length > 2) {
        nameWords.set(word, (nameWords.get(word) || 0) + 1);
      }
    }
  }

  lines.push(`- **Total tributes:** ${tributes.size.toLocaleString()}`);
  lines.push(`- **Personal tributes:** ${personalCount.toLocaleString()}`);
  lines.push(`- **Guild tributes:** ${guildCount.toLocaleString()}`);
  lines.push(`- **With descriptions:** ${withDesc.toLocaleString()}`);
  if (withDesc > 0) {
    lines.push(`- **Average description length:** ${Math.round(totalDescLen / withDesc)} chars`);
  }

  // Keyword frequency
  if (keywords.size > 0) {
    lines.push('', '## Tribute Benefit Keywords', '');
    lines.push('| Keyword | Tributes | % |');
    lines.push('|---------|----------|---|');
    const sortedKw = [...keywords.entries()].sort((a, b) => b[1] - a[1]);
    for (const [kw, count] of sortedKw) {
      if (count > 0) {
        lines.push(`| ${kw} | ${count} | ${(count / tributes.size * 100).toFixed(1)}% |`);
      }
    }
  }

  // Name word frequency
  if (nameWords.size > 0) {
    lines.push('', '## Most Common Tribute Name Words', '');
    const sortedWords = [...nameWords.entries()].sort((a, b) => b[1] - a[1]).slice(0, 20);
    for (const [word, count] of sortedWords) {
      lines.push(`- **${word}**: ${count} tributes`);
    }
  }

  // Sample tributes by type
  const personalSample = [...tributes.values()].filter(t => !t.isGuild).slice(0, 10);
  const guildSample = [...tributes.values()].filter(t => t.isGuild).slice(0, 10);

  if (personalSample.length > 0) {
    lines.push('', '## Sample Personal Tributes', '');
    for (const t of personalSample) {
      const desc = t.description ? t.description.substring(0, 80) : 'No description';
      lines.push(`- **${t.name}**: ${desc}`);
    }
  }

  if (guildSample.length > 0) {
    lines.push('', '## Sample Guild Tributes', '');
    for (const t of guildSample) {
      const desc = t.description ? t.description.substring(0, 80) : 'No description';
      lines.push(`- **${t.name}**: ${desc}`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL DURATION FORMULA ANALYSIS ============

export async function getSpellDurationFormulaAnalysis(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const DURATION_FORMULAS: Record<number, string> = {
    0: 'None (instant)',
    1: 'level/2 ticks (max value)',
    2: 'level/5 + 1 ticks',
    3: 'level * 30 ticks',
    4: '50 ticks (~5 minutes)',
    5: '2 ticks (~12 seconds)',
    6: 'level/2 ticks',
    7: 'level ticks',
    8: 'level + 10 ticks',
    9: 'level * 2 + 10 ticks',
    10: 'level * 3 + 10 ticks',
    11: '(value) ticks',
    12: 'Permanent',
    50: '(value) ticks (fixed)',
    3600: '(value) seconds (fixed)',
  };

  const lines = ['# Spell Duration Formula × Value Analysis', ''];

  // Collect formula-value pairs
  const formulaValues = new Map<number, number[]>();
  let totalSpells = 0;

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    totalSpells++;
    const formula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const value = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    if (!formulaValues.has(formula)) formulaValues.set(formula, []);
    formulaValues.get(formula)!.push(value);
  }

  lines.push(`- **Total spells analyzed:** ${totalSpells.toLocaleString()}`);
  lines.push(`- **Unique duration formulas:** ${formulaValues.size}`);

  // For each formula, show value statistics
  lines.push('', '## Formula-Value Interaction Statistics', '');
  lines.push('| Formula | Description | Spells | Min Val | Max Val | Avg Val | Median Val | Unique Values |');
  lines.push('|---------|-------------|--------|---------|---------|---------|------------|---------------|');

  const sortedFormulas = [...formulaValues.entries()].sort((a, b) => b[1].length - a[1].length);
  for (const [formula, values] of sortedFormulas) {
    const desc = DURATION_FORMULAS[formula] || `Formula ${formula}`;
    const sorted = [...values].sort((a, b) => a - b);
    const min = sorted[0];
    const max = sorted[sorted.length - 1];
    const avg = values.reduce((a, b) => a + b, 0) / values.length;
    const median = sorted[Math.floor(sorted.length / 2)];
    const unique = new Set(values).size;
    lines.push(`| ${formula} | ${desc} | ${values.length.toLocaleString()} | ${min} | ${max} | ${avg.toFixed(1)} | ${median} | ${unique} |`);
  }

  // Value frequency across all formulas
  const valueCounts = new Map<number, number>();
  for (const values of formulaValues.values()) {
    for (const v of values) {
      valueCounts.set(v, (valueCounts.get(v) || 0) + 1);
    }
  }

  lines.push('', '## Most Common Duration Values (All Formulas)', '');
  lines.push('| Value | Spells | Used with Formulas |');
  lines.push('|-------|--------|-------------------|');
  const sortedValues = [...valueCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 20);
  for (const [value, count] of sortedValues) {
    const usedFormulas: number[] = [];
    for (const [formula, values] of formulaValues) {
      if (values.includes(value)) usedFormulas.push(formula);
    }
    lines.push(`| ${value} | ${count.toLocaleString()} | ${usedFormulas.join(', ')} |`);
  }

  // Anomalies: formulas where all values are identical
  lines.push('', '## Constant-Value Formulas (Same Value for All Spells)', '');
  for (const [formula, values] of sortedFormulas) {
    const unique = new Set(values).size;
    if (unique === 1 && values.length > 5) {
      const desc = DURATION_FORMULAS[formula] || `Formula ${formula}`;
      lines.push(`- **Formula ${formula}** (${desc}): all ${values.length} spells use value=${values[0]}`);
    }
  }

  // Beneficial vs detrimental duration patterns
  const benFormulas = new Map<number, number>();
  const detFormulas = new Map<number, number>();
  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const formula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const ben = spell.fields[SF.BENEFICIAL] === '1';
    if (ben) benFormulas.set(formula, (benFormulas.get(formula) || 0) + 1);
    else detFormulas.set(formula, (detFormulas.get(formula) || 0) + 1);
  }

  lines.push('', '## Beneficial vs Detrimental by Formula', '');
  lines.push('| Formula | Description | Beneficial | Detrimental | % Beneficial |');
  lines.push('|---------|-------------|------------|-------------|--------------|');
  for (const [formula] of sortedFormulas.slice(0, 15)) {
    const desc = DURATION_FORMULAS[formula] || `Formula ${formula}`;
    const ben = benFormulas.get(formula) || 0;
    const det = detFormulas.get(formula) || 0;
    const total = ben + det;
    const pct = total > 0 ? (ben / total * 100).toFixed(1) : '0.0';
    lines.push(`| ${formula} | ${desc} | ${ben} | ${det} | ${pct}% |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: MAP POI LABEL ANALYSIS ============

export async function getMapPOILabelAnalysis(): Promise<string> {
  await loadZones();

  const lines = ['# Map POI Label Analysis', ''];

  const mapDir = gamePath('maps');
  if (!existsSync(mapDir)) return 'Maps directory not found at ' + mapDir;

  const allFiles = await readdir(mapDir);
  const files = allFiles.filter((f: string) => f.endsWith('.txt') && !f.endsWith('_1.txt') && !f.endsWith('_2.txt') && !f.endsWith('_3.txt'));

  const wordFreq = new Map<string, number>();
  const labelPrefixes = new Map<string, number>();
  const colorCounts = new Map<string, number>();
  let totalPOIs = 0;
  let totalLabeled = 0;
  const zonePOICounts: { zone: string; count: number }[] = [];
  const emptyLabelZones: string[] = [];

  for (const file of files) {
    try {
      const content = await readFile(join(mapDir, file), 'utf-8');
      const poiLines = content.split('\n').filter((l: string) => l.startsWith('P '));
      const zoneName = file.replace('.txt', '');

      if (poiLines.length === 0) continue;
      zonePOICounts.push({ zone: zoneName, count: poiLines.length });
      totalPOIs += poiLines.length;

      let labeled = 0;
      for (const line of poiLines) {
        const parts = line.split(',');
        if (parts.length >= 8) {
          const label = parts.slice(7).join(',').trim();
          const r = parseInt(parts[4]) || 0;
          const g = parseInt(parts[5]) || 0;
          const b = parseInt(parts[6]) || 0;
          const colorKey = `${r},${g},${b}`;
          colorCounts.set(colorKey, (colorCounts.get(colorKey) || 0) + 1);

          if (label && label.length > 0) {
            labeled++;
            totalLabeled++;

            // Word frequency
            const words = label.toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
            for (const word of words) {
              if (word.length > 2) {
                wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
              }
            }

            // First word as prefix category
            const firstWord = words[0];
            if (firstWord && firstWord.length > 1) {
              labelPrefixes.set(firstWord, (labelPrefixes.get(firstWord) || 0) + 1);
            }
          }
        }
      }

      if (labeled === 0 && poiLines.length > 0) {
        emptyLabelZones.push(zoneName);
      }
    } catch {
      // Skip files that can't be read
    }
  }

  lines.push(`- **Total POIs analyzed:** ${totalPOIs.toLocaleString()}`);
  lines.push(`- **Labeled POIs:** ${totalLabeled.toLocaleString()} (${(totalLabeled / totalPOIs * 100).toFixed(1)}%)`);
  lines.push(`- **Unlabeled POIs:** ${(totalPOIs - totalLabeled).toLocaleString()}`);
  lines.push(`- **Zones with POIs:** ${zonePOICounts.length}`);

  // Most common POI label words
  lines.push('', '## Most Common POI Label Words', '');
  lines.push('| Word | Occurrences |');
  lines.push('|------|------------|');
  const sortedWords = [...wordFreq.entries()].sort((a, b) => b[1] - a[1]).slice(0, 30);
  for (const [word, count] of sortedWords) {
    lines.push(`| ${word} | ${count} |`);
  }

  // Label prefix categories
  lines.push('', '## POI Label Prefixes (First Word)', '');
  lines.push('| Prefix | Count | % |');
  lines.push('|--------|-------|---|');
  const sortedPrefixes = [...labelPrefixes.entries()].sort((a, b) => b[1] - a[1]).slice(0, 25);
  for (const [prefix, count] of sortedPrefixes) {
    lines.push(`| ${prefix} | ${count} | ${(count / totalLabeled * 100).toFixed(1)}% |`);
  }

  // Color distribution
  lines.push('', '## POI Color Distribution (Top 15)', '');
  lines.push('| Color (R,G,B) | Count | % |');
  lines.push('|---------------|-------|---|');
  const sortedColors = [...colorCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 15);
  for (const [color, count] of sortedColors) {
    lines.push(`| ${color} | ${count} | ${(count / totalPOIs * 100).toFixed(1)}% |`);
  }

  // Zones with most POIs
  zonePOICounts.sort((a, b) => b.count - a.count);
  lines.push('', '## Zones with Most POIs (Top 15)', '');
  for (const { zone, count } of zonePOICounts.slice(0, 15)) {
    lines.push(`- **${zone}**: ${count} POIs`);
  }

  // Zones with fewest POIs
  lines.push('', '## Zones with Fewest POIs (Bottom 10)', '');
  const bottom = zonePOICounts.slice(-10).reverse();
  for (const { zone, count } of bottom) {
    lines.push(`- **${zone}**: ${count} POIs`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: AA NAME GROUP ANALYSIS ============

export async function getAANameGroupAnalysis(): Promise<string> {
  await loadAAAbilities();
  if (!aaAbilities || aaAbilities.size === 0) return 'AA ability data not available.';

  const lines = ['# AA Ability Name Group Analysis', ''];

  // Group AAs by base name (strip rank numbers)
  const baseNameGroups = new Map<string, { names: string[]; ids: number[] }>();
  const rankPatterns = /\s+(Rk\.\s*\d+|Rank\s*\d+|[IVXLC]+)$/i;
  const numberSuffix = /\s+\d+$/;

  for (const aa of aaAbilities.values()) {
    // Strip rank/number suffix to find base name
    let baseName = aa.name.replace(rankPatterns, '').replace(numberSuffix, '').trim();
    if (baseName.length === 0) baseName = aa.name;

    if (!baseNameGroups.has(baseName)) baseNameGroups.set(baseName, { names: [], ids: [] });
    const group = baseNameGroups.get(baseName)!;
    group.names.push(aa.name);
    group.ids.push(aa.id);
  }

  const totalGroups = baseNameGroups.size;
  const multiRank = [...baseNameGroups.values()].filter(g => g.names.length > 1);
  const singleRank = [...baseNameGroups.values()].filter(g => g.names.length === 1);

  lines.push(`- **Total AA abilities:** ${aaAbilities.size.toLocaleString()}`);
  lines.push(`- **Unique base names:** ${totalGroups.toLocaleString()}`);
  lines.push(`- **Multi-rank AA lines:** ${multiRank.length.toLocaleString()}`);
  lines.push(`- **Single-rank AAs:** ${singleRank.length.toLocaleString()}`);

  // Rank distribution
  const rankSizes = new Map<number, number>();
  for (const group of baseNameGroups.values()) {
    const size = group.names.length;
    rankSizes.set(size, (rankSizes.get(size) || 0) + 1);
  }

  lines.push('', '## Rank Count Distribution', '');
  lines.push('| Ranks | AA Lines |');
  lines.push('|-------|----------|');
  const sortedSizes = [...rankSizes.entries()].sort((a, b) => a[0] - b[0]);
  for (const [size, count] of sortedSizes.slice(0, 15)) {
    const bar = '#'.repeat(Math.min(count, 50));
    lines.push(`| ${size} | ${count} ${bar} |`);
  }

  // Largest AA lines (most ranks)
  const sortedGroups = [...baseNameGroups.entries()].sort((a, b) => b[1].names.length - a[1].names.length);
  lines.push('', '## Longest AA Lines (Most Ranks)', '');
  lines.push('| Base Name | Ranks |');
  lines.push('|-----------|-------|');
  for (const [name, group] of sortedGroups.slice(0, 20)) {
    lines.push(`| ${name} | ${group.names.length} |`);
  }

  // First word frequency (common prefixes/themes)
  const firstWords = new Map<string, number>();
  for (const aa of aaAbilities.values()) {
    const firstWord = aa.name.split(/\s+/)[0].toLowerCase();
    if (firstWord.length > 2) {
      firstWords.set(firstWord, (firstWords.get(firstWord) || 0) + 1);
    }
  }

  lines.push('', '## Most Common AA Name Prefixes', '');
  lines.push('| Prefix | Count |');
  lines.push('|--------|-------|');
  const sortedPrefixes = [...firstWords.entries()].sort((a, b) => b[1] - a[1]).slice(0, 20);
  for (const [prefix, count] of sortedPrefixes) {
    lines.push(`| ${prefix} | ${count} |`);
  }

  // Keyword themes in AA names
  const themeKeywords = [
    'strike', 'blast', 'fury', 'ward', 'shield', 'bolt', 'burn', 'heal',
    'focus', 'mastery', 'enhanced', 'improved', 'critical', 'natural',
    'weapon', 'spell', 'pet', 'companion', 'gift', 'blessing',
  ];
  const themes = new Map<string, number>();
  for (const aa of aaAbilities.values()) {
    const lowerName = aa.name.toLowerCase();
    for (const kw of themeKeywords) {
      if (lowerName.includes(kw)) {
        themes.set(kw, (themes.get(kw) || 0) + 1);
      }
    }
  }

  if (themes.size > 0) {
    lines.push('', '## AA Name Themes (Keyword Frequency)', '');
    lines.push('| Theme | AAs |');
    lines.push('|-------|-----|');
    const sortedThemes = [...themes.entries()].sort((a, b) => b[1] - a[1]);
    for (const [theme, count] of sortedThemes) {
      lines.push(`| ${theme} | ${count} |`);
    }
  }

  // AA name length stats
  const nameLengths = [...aaAbilities.values()].map(a => a.name.length);
  nameLengths.sort((a, b) => a - b);
  const avgLen = nameLengths.reduce((a, b) => a + b, 0) / nameLengths.length;
  const medianLen = nameLengths[Math.floor(nameLengths.length / 2)];

  lines.push('', '## AA Name Length Statistics', '');
  lines.push(`- **Shortest name:** ${nameLengths[0]} chars`);
  lines.push(`- **Longest name:** ${nameLengths[nameLengths.length - 1]} chars`);
  lines.push(`- **Average name length:** ${avgLen.toFixed(1)} chars`);
  lines.push(`- **Median name length:** ${medianLen} chars`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL EFFECT COMBINATION ANALYSIS ============

export async function getSpellEffectCombinationAnalysis(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Effect Combination Analysis', ''];
  lines.push('*Which spell effects (SPA types) most often appear together on the same spell.*', '');

  // Parse effect slots from all spells
  const pairCounts = new Map<string, number>();
  const effectsPerSpell: number[][] = [];
  const slotPositionSPA = new Map<number, Map<number, number>>(); // position -> spa -> count
  let totalWithEffects = 0;
  let totalSlots = 0;

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) {
        effectField = spell.fields[i];
        break;
      }
    }
    if (!effectField) continue;

    const slots = effectField.split('$');
    const spas: number[] = [];
    let slotPos = 0;

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length < 3) continue;
      const spa = parseInt(parts[1]);
      if (isNaN(spa) || spa <= 0) continue;
      spas.push(spa);
      totalSlots++;
      slotPos++;

      // Track SPA by slot position
      if (!slotPositionSPA.has(slotPos)) slotPositionSPA.set(slotPos, new Map());
      const posMap = slotPositionSPA.get(slotPos)!;
      posMap.set(spa, (posMap.get(spa) || 0) + 1);
    }

    if (spas.length > 0) {
      totalWithEffects++;
      effectsPerSpell.push(spas);

      // Count pairs
      const unique = [...new Set(spas)].sort((a, b) => a - b);
      for (let i = 0; i < unique.length; i++) {
        for (let j = i + 1; j < unique.length; j++) {
          const key = `${unique[i]}:${unique[j]}`;
          pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
        }
      }
    }
  }

  // Effect count distribution
  const slotCounts = new Map<number, number>();
  for (const spas of effectsPerSpell) {
    const count = spas.length;
    const bucket = count <= 5 ? count : count <= 10 ? 10 : count <= 15 ? 15 : 20;
    slotCounts.set(bucket, (slotCounts.get(bucket) || 0) + 1);
  }

  lines.push(`- **Spells with effect data:** ${totalWithEffects.toLocaleString()}`);
  lines.push(`- **Total effect slots:** ${totalSlots.toLocaleString()}`);
  lines.push(`- **Average effects per spell:** ${(totalSlots / totalWithEffects).toFixed(1)}`);
  lines.push(`- **Unique effect pairs observed:** ${pairCounts.size.toLocaleString()}`);

  lines.push('', '## Effects Per Spell Distribution', '');
  lines.push('| Effect Count | Spells |');
  lines.push('|-------------|--------|');
  for (const bucket of [1, 2, 3, 4, 5, 10, 15, 20]) {
    const count = slotCounts.get(bucket) || 0;
    if (count > 0) {
      const label = bucket <= 5 ? `${bucket}` : bucket === 10 ? '6-10' : bucket === 15 ? '11-15' : '16+';
      lines.push(`| ${label} | ${count.toLocaleString()} |`);
    }
  }

  // Most common pairs
  const sortedPairs = [...pairCounts.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('', '## Most Common Effect Combinations (Top 25)', '');
  lines.push('| Effect 1 | Effect 2 | Co-occurrence |');
  lines.push('|----------|----------|--------------|');
  for (const [pair, count] of sortedPairs.slice(0, 25)) {
    const [spa1, spa2] = pair.split(':').map(Number);
    const name1 = SPA_NAMES[spa1] || `SPA ${spa1}`;
    const name2 = SPA_NAMES[spa2] || `SPA ${spa2}`;
    lines.push(`| ${name1} (${spa1}) | ${name2} (${spa2}) | ${count.toLocaleString()} |`);
  }

  // Slot position analysis (what effects are most common in slot 1, 2, 3...)
  lines.push('', '## Most Common Effect by Slot Position', '');
  lines.push('| Slot | Most Common SPA | Name | Count |');
  lines.push('|------|----------------|------|-------|');
  const sortedPositions = [...slotPositionSPA.entries()].sort((a, b) => a[0] - b[0]);
  for (const [pos, spaMap] of sortedPositions.slice(0, 12)) {
    const sorted = [...spaMap.entries()].sort((a, b) => b[1] - a[1]);
    if (sorted.length > 0) {
      const [topSPA, topCount] = sorted[0];
      const name = SPA_NAMES[topSPA] || `SPA ${topSPA}`;
      lines.push(`| ${pos} | ${topSPA} | ${name} | ${topCount.toLocaleString()} |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: EXPANSION CONTENT DENSITY ============

export async function getExpansionContentDensity(): Promise<string> {
  await loadFactions();
  await loadAchievements();
  await loadAchievementCategories();
  await loadZones();
  await loadSpells();

  const lines = ['# Expansion Content Density Analysis', ''];
  lines.push('*Cross-reference of content across major game systems by expansion.*', '');

  // Factions by expansion
  const factionsByExpansion = new Map<string, number>();
  if (factions) {
    for (const faction of factions.values()) {
      const exp = faction.category || 'Uncategorized';
      factionsByExpansion.set(exp, (factionsByExpansion.get(exp) || 0) + 1);
    }
  }

  // Achievements by top-level category
  const achievementsByCat = new Map<string, number>();
  if (achievementCategories && categoryToAchievements) {
    // Count achievements under each top-level category
    const topLevelCats: { id: number; name: string }[] = [];
    for (const [, cat] of achievementCategories) {
      if (cat.parentId === 0 || cat.parentId === -1) {
        topLevelCats.push({ id: cat.id, name: cat.name });
      }
    }

    // For each top-level category, count all achievements (including sub-categories)
    const countForCategory = (catId: number): number => {
      let count = (categoryToAchievements!.get(catId) || []).length;
      for (const [, cat] of achievementCategories!) {
        if (cat.parentId === catId) {
          count += countForCategory(cat.id);
        }
      }
      return count;
    };

    for (const cat of topLevelCats) {
      const count = countForCategory(cat.id);
      if (count > 0) {
        achievementsByCat.set(cat.name, count);
      }
    }
  }

  // Zone level ranges distribution
  const zoneLevelBuckets = new Map<string, number>();
  if (zones) {
    for (const zone of zones.values()) {
      if (zone.levelMin <= 0 && zone.levelMax <= 0) {
        zoneLevelBuckets.set('No Level', (zoneLevelBuckets.get('No Level') || 0) + 1);
      } else {
        const avgLevel = (zone.levelMin + zone.levelMax) / 2;
        const bucket = avgLevel <= 20 ? '1-20' : avgLevel <= 40 ? '21-40' : avgLevel <= 60 ? '41-60' : avgLevel <= 80 ? '61-80' : avgLevel <= 100 ? '81-100' : '101+';
        zoneLevelBuckets.set(bucket, (zoneLevelBuckets.get(bucket) || 0) + 1);
      }
    }
  }

  // Summary counts
  lines.push('## Content Summary', '');
  lines.push(`- **Total factions:** ${factions?.size.toLocaleString() || 0}`);
  lines.push(`- **Faction expansion categories:** ${factionsByExpansion.size}`);
  lines.push(`- **Total achievements:** ${achievements?.size.toLocaleString() || 0}`);
  lines.push(`- **Achievement categories:** ${achievementsByCat.size}`);
  lines.push(`- **Total zones:** ${zones?.size.toLocaleString() || 0}`);
  lines.push(`- **Total spells:** ${spells?.size.toLocaleString() || 0}`);

  // Factions by expansion
  if (factionsByExpansion.size > 0) {
    lines.push('', '## Factions by Expansion', '');
    lines.push('| Expansion | Factions |');
    lines.push('|-----------|---------|');
    const sortedFactions = [...factionsByExpansion.entries()].sort((a, b) => b[1] - a[1]);
    for (const [exp, count] of sortedFactions) {
      const bar = '#'.repeat(Math.min(Math.round(count / 2), 30));
      lines.push(`| ${exp} | ${count} ${bar} |`);
    }
  }

  // Achievements by category
  if (achievementsByCat.size > 0) {
    lines.push('', '## Achievements by Top-Level Category', '');
    lines.push('| Category | Achievements |');
    lines.push('|----------|-------------|');
    const sortedAch = [...achievementsByCat.entries()].sort((a, b) => b[1] - a[1]);
    for (const [cat, count] of sortedAch) {
      const bar = '#'.repeat(Math.min(Math.round(count / 10), 30));
      lines.push(`| ${cat} | ${count} ${bar} |`);
    }
  }

  // Zone level distribution
  if (zoneLevelBuckets.size > 0) {
    lines.push('', '## Zones by Level Range', '');
    lines.push('| Level Range | Zones |');
    lines.push('|-------------|-------|');
    for (const bucket of ['1-20', '21-40', '41-60', '61-80', '81-100', '101+', 'No Level']) {
      const count = zoneLevelBuckets.get(bucket) || 0;
      if (count > 0) {
        const bar = '#'.repeat(Math.min(count, 30));
        lines.push(`| ${bucket} | ${count} ${bar} |`);
      }
    }
  }

  // Content ratio analysis
  if (factions && zones && achievements && spells) {
    lines.push('', '## Content Ratios', '');
    lines.push(`- **Spells per zone:** ${(spells.size / zones.size).toFixed(1)}`);
    lines.push(`- **Factions per zone:** ${(factions.size / zones.size).toFixed(2)}`);
    lines.push(`- **Achievements per zone:** ${(achievements.size / zones.size).toFixed(1)}`);
    lines.push(`- **Spells per faction:** ${(spells.size / factions.size).toFixed(1)}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS SPELL DIVERSITY INDEX ============

export async function getClassSpellDiversityIndex(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Spell Diversity Index', ''];
  lines.push('*Measures each class\'s breadth of spell effects: how many distinct SPA effect types they can access.*', '');

  // For each class, collect distinct SPA effects
  const classData: {
    classId: number; name: string; short: string;
    totalSpells: number; distinctSPAs: Set<number>;
    benCount: number; detCount: number;
  }[] = [];

  for (let cid = 1; cid <= 16; cid++) {
    const distinctSPAs = new Set<number>();
    let totalSpells = 0;
    let benCount = 0;
    let detCount = 0;

    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]);
      if (isNaN(level) || level < 1 || level > 254) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
      totalSpells++;

      if (spell.fields[SF.BENEFICIAL] === '1') benCount++;
      else detCount++;

      // Parse effect slots
      let effectField = '';
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i].includes('|')) {
          effectField = spell.fields[i];
          break;
        }
      }
      if (!effectField) continue;

      const slots = effectField.split('$');
      for (const slot of slots) {
        const parts = slot.split('|');
        if (parts.length < 3) continue;
        const spa = parseInt(parts[1]);
        if (!isNaN(spa) && spa > 0) distinctSPAs.add(spa);
      }
    }

    classData.push({
      classId: cid,
      name: CLASS_IDS[cid],
      short: CLASS_SHORT[cid],
      totalSpells,
      distinctSPAs,
      benCount,
      detCount,
    });
  }

  // Sort by diversity (distinct SPAs)
  classData.sort((a, b) => b.distinctSPAs.size - a.distinctSPAs.size);

  lines.push('## Class Diversity Rankings', '');
  lines.push('| Rank | Class | Total Spells | Distinct Effects | Ben/Det | Diversity Score |');
  lines.push('|------|-------|-------------|-----------------|---------|----------------|');
  for (let i = 0; i < classData.length; i++) {
    const c = classData[i];
    const diversityScore = c.totalSpells > 0 ? (c.distinctSPAs.size / c.totalSpells * 100).toFixed(2) : '0';
    lines.push(`| ${i + 1} | ${c.name} (${c.short}) | ${c.totalSpells.toLocaleString()} | ${c.distinctSPAs.size} | ${c.benCount}/${c.detCount} | ${diversityScore}% |`);
  }

  // Find class-exclusive effects (SPAs only available to one class)
  const spaToClasses = new Map<number, Set<number>>();
  for (const c of classData) {
    for (const spa of c.distinctSPAs) {
      if (!spaToClasses.has(spa)) spaToClasses.set(spa, new Set());
      spaToClasses.get(spa)!.add(c.classId);
    }
  }

  const exclusiveEffects = new Map<number, number[]>(); // classId -> [spa ids]
  for (const [spa, classes] of spaToClasses) {
    if (classes.size === 1) {
      const classId = [...classes][0];
      if (!exclusiveEffects.has(classId)) exclusiveEffects.set(classId, []);
      exclusiveEffects.get(classId)!.push(spa);
    }
  }

  if (exclusiveEffects.size > 0) {
    lines.push('', '## Class-Exclusive Effects (SPA Available to Only One Class)', '');
    lines.push('| Class | Exclusive Effects | Sample Effects |');
    lines.push('|-------|-------------------|----------------|');
    const sortedExcl = [...exclusiveEffects.entries()].sort((a, b) => b[1].length - a[1].length);
    for (const [classId, spas] of sortedExcl) {
      const sample = spas.slice(0, 5).map(s => SPA_NAMES[s] || `SPA ${s}`).join(', ');
      lines.push(`| ${CLASS_IDS[classId]} | ${spas.length} | ${sample} |`);
    }
  }

  // Universal effects (available to ALL classes)
  const universalSPAs: number[] = [];
  for (const [spa, classes] of spaToClasses) {
    if (classes.size === 16) universalSPAs.push(spa);
  }

  lines.push('', `## Universal Effects (Available to All 16 Classes): ${universalSPAs.length}`, '');
  const sortedUniversal = universalSPAs.sort((a, b) => a - b);
  for (const spa of sortedUniversal.slice(0, 30)) {
    lines.push(`- ${SPA_NAMES[spa] || `SPA ${spa}`} (${spa})`);
  }
  if (sortedUniversal.length > 30) {
    lines.push(`- *(+${sortedUniversal.length - 30} more)*`);
  }

  // Effect overlap matrix (top 5 classes)
  lines.push('', '## Effect Overlap Between Top Classes', '');
  const top5 = classData.slice(0, 5);
  lines.push(`| | ${top5.map(c => c.short).join(' | ')} |`);
  lines.push(`|---|${top5.map(() => '---').join('|')}|`);
  for (const c1 of top5) {
    const cells = top5.map(c2 => {
      if (c1.classId === c2.classId) return `**${c1.distinctSPAs.size}**`;
      let shared = 0;
      for (const spa of c1.distinctSPAs) {
        if (c2.distinctSPAs.has(spa)) shared++;
      }
      return `${shared}`;
    });
    lines.push(`| ${c1.short} | ${cells.join(' | ')} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: GAME DATA SUMMARY DASHBOARD ============

export async function getGameDataSummaryDashboard(): Promise<string> {
  // Load all data systems
  await Promise.all([
    loadSpells(), loadZones(), loadFactions(), loadAchievements(),
    loadAAAbilities(), loadMercenaries(), loadTributes(),
    loadCreatureTypes(), loadAltCurrencies(), loadCombatAbilities(),
    loadItemEffects(), loadOverseerMinions(), loadOverseerQuests(),
    loadSpellStacking(), loadGameEvents(), loadExpansions(),
    loadLore(), loadHelpTopics(), loadBannerCategories(),
  ]);

  const lines = ['# EverQuest Game Data Summary Dashboard', ''];

  const systems: { name: string; count: number | string; detail?: string }[] = [];

  // Spells
  if (spells) systems.push({ name: 'Spells', count: spells.size, detail: `${Object.keys(SPA_NAMES).length} effect types` });
  // Zones
  if (zones) systems.push({ name: 'Zones', count: zones.size });
  // Factions
  if (factions) {
    const withMods = [...factions.values()].filter(f => f.startingValues && f.startingValues.length > 0).length;
    systems.push({ name: 'Factions', count: factions.size, detail: `${withMods} with starting modifiers` });
  }
  // Achievements
  if (achievements) systems.push({ name: 'Achievements', count: achievements.size });
  if (achievementComponents) systems.push({ name: 'Achievement Components', count: `${achievementComponents.size} achievements` });
  // AA
  if (aaAbilities) systems.push({ name: 'AA Abilities', count: aaAbilities.size });
  // Mercenaries
  if (mercenaries) systems.push({ name: 'Mercenary Templates', count: mercenaries.size });
  // Tributes
  if (tributes) systems.push({ name: 'Tributes', count: tributes.size });
  // Creature Types
  if (creatureTypes) systems.push({ name: 'Creature Types', count: creatureTypes.size });
  // Currencies
  if (altCurrencies) systems.push({ name: 'Alternate Currencies', count: altCurrencies.size });
  // Combat Abilities
  if (combatAbilities) systems.push({ name: 'Combat Abilities', count: combatAbilities.size });
  // Item Effects
  if (itemEffectDescs) systems.push({ name: 'Item Effects', count: itemEffectDescs.size });
  // Overseer
  if (overseerMinions) systems.push({ name: 'Overseer Agents', count: overseerMinions.size });
  if (overseerQuests) systems.push({ name: 'Overseer Quests', count: overseerQuests.size });
  // Spell Stacking
  if (spellStacking) systems.push({ name: 'Spell Stacking Groups', count: spellStacking.size });
  // Game Events
  if (gameEvents) systems.push({ name: 'Game Events', count: gameEvents.size });
  // Expansions
  if (expansionNames) systems.push({ name: 'Expansions', count: expansionNames.size });
  // Lore
  if (loreEntries) systems.push({ name: 'Lore Entries', count: loreEntries.length });
  // Help Topics
  if (helpTopics) systems.push({ name: 'Help Topics', count: helpTopics.size });

  lines.push('## Data Systems Loaded', '');
  lines.push('| System | Entries | Details |');
  lines.push('|--------|---------|---------|');
  let totalEntries = 0;
  for (const sys of systems) {
    const countNum = typeof sys.count === 'number' ? sys.count : 0;
    totalEntries += countNum;
    lines.push(`| ${sys.name} | ${typeof sys.count === 'number' ? sys.count.toLocaleString() : sys.count} | ${sys.detail || ''} |`);
  }
  lines.push(`| **Total** | **${totalEntries.toLocaleString()}** | |`);

  // Key metrics
  lines.push('', '## Key Metrics', '');
  if (spells) {
    let benCount = 0, detCount = 0;
    for (const spell of spells.values()) {
      if (spell.fields[SF.BENEFICIAL] === '1') benCount++;
      else detCount++;
    }
    lines.push(`- **Spell balance:** ${benCount.toLocaleString()} beneficial / ${detCount.toLocaleString()} detrimental (${(benCount / spells.size * 100).toFixed(1)}% beneficial)`);
  }
  lines.push(`- **Playable races:** ${Object.keys(RACE_IDS).length}`);
  lines.push(`- **Playable classes:** ${Object.keys(CLASS_IDS).length}`);
  lines.push(`- **Resist types:** ${Object.keys(RESIST_TYPES).length}`);
  lines.push(`- **Target types:** ${Object.keys(TARGET_TYPES).length}`);

  return lines.join('\n');
}

// ============ PUBLIC API: FACTION NETWORK ANALYSIS ============

export async function getFactionNetworkAnalysis(): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Faction Relationship Network Analysis', ''];
  lines.push('*Factions connected through shared race/class/deity starting modifiers.*', '');

  // Build modifier → factions mapping
  const modifierToFactions = new Map<number, { factionIds: number[]; factionNames: string[] }>();

  for (const faction of factions.values()) {
    if (!faction.startingValues) continue;
    for (const sv of faction.startingValues) {
      if (!modifierToFactions.has(sv.modifierId)) {
        modifierToFactions.set(sv.modifierId, { factionIds: [], factionNames: [] });
      }
      const entry = modifierToFactions.get(sv.modifierId)!;
      entry.factionIds.push(faction.id);
      entry.factionNames.push(faction.name);
    }
  }

  lines.push(`- **Modifiers connecting factions:** ${modifierToFactions.size}`);

  // Find modifiers that connect the most factions
  const sortedModifiers = [...modifierToFactions.entries()]
    .filter(([, data]) => data.factionIds.length > 1)
    .sort((a, b) => b[1].factionIds.length - a[1].factionIds.length);

  lines.push(`- **Modifiers affecting multiple factions:** ${sortedModifiers.length}`);

  // Highest connectivity modifiers
  lines.push('', '## Most Connected Modifiers (Affecting Most Factions)', '');
  lines.push('| Modifier | Factions Affected | Sample Factions |');
  lines.push('|----------|-------------------|-----------------|');
  for (const [modId, data] of sortedModifiers.slice(0, 20)) {
    const modName = factionModifierNames?.get(modId) || `Modifier #${modId}`;
    const sample = data.factionNames.slice(0, 3).join(', ');
    lines.push(`| ${modName} | ${data.factionIds.length} | ${sample} |`);
  }

  // Faction co-occurrence: which factions are most often affected by the same modifier
  const pairCounts = new Map<string, number>();
  for (const [, data] of modifierToFactions) {
    const ids = data.factionIds;
    for (let i = 0; i < ids.length && i < 30; i++) {
      for (let j = i + 1; j < ids.length && j < 30; j++) {
        const key = ids[i] < ids[j] ? `${ids[i]}:${ids[j]}` : `${ids[j]}:${ids[i]}`;
        pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
      }
    }
  }

  const sortedPairs = [...pairCounts.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('', '## Most Connected Faction Pairs (Shared Modifiers)', '');
  lines.push('| Faction 1 | Faction 2 | Shared Modifiers |');
  lines.push('|-----------|-----------|-----------------|');
  for (const [pair, count] of sortedPairs.slice(0, 20)) {
    const [id1, id2] = pair.split(':').map(Number);
    const name1 = factions.get(id1)?.name || `#${id1}`;
    const name2 = factions.get(id2)?.name || `#${id2}`;
    lines.push(`| ${name1} | ${name2} | ${count} |`);
  }

  // Faction clusters: group factions by how many modifiers they share
  const factionConnections = new Map<number, number>();
  for (const faction of factions.values()) {
    if (!faction.startingValues) continue;
    let connections = 0;
    for (const sv of faction.startingValues) {
      const entry = modifierToFactions.get(sv.modifierId);
      if (entry) connections += entry.factionIds.length - 1; // Other factions sharing this modifier
    }
    factionConnections.set(faction.id, connections);
  }

  const sortedByConnections = [...factionConnections.entries()]
    .sort((a, b) => b[1] - a[1]);

  lines.push('', '## Most Connected Factions (Total Connections)', '');
  lines.push('| Faction | Connections | Modifiers |');
  lines.push('|---------|------------|-----------|');
  for (const [factionId, connections] of sortedByConnections.slice(0, 15)) {
    const faction = factions.get(factionId);
    if (!faction) continue;
    lines.push(`| ${faction.name} | ${connections} | ${faction.startingValues?.length || 0} |`);
  }

  // Isolated factions (no shared modifiers)
  const isolatedFactions = [...factions.values()].filter(f => {
    if (!f.startingValues || f.startingValues.length === 0) return false;
    return !factionConnections.has(f.id) || factionConnections.get(f.id) === 0;
  });

  if (isolatedFactions.length > 0) {
    lines.push('', `## Isolated Factions (Modifiers Not Shared): ${isolatedFactions.length}`, '');
    for (const f of isolatedFactions.slice(0, 10)) {
      lines.push(`- ${f.name} (${f.startingValues!.length} modifiers)`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL PROGRESSION ANALYSIS ============

export async function getSpellProgressionAnalysis(className: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const cn = className.toUpperCase().trim();
  // Try short code first (WAR, CLR, etc.), then full name
  let entry = Object.entries(CLASS_SHORT).find(([, short]) => short === cn);
  if (!entry) {
    entry = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase().trim());
  }
  if (!entry) return `Unknown class: "${className}". Valid short codes: ${Object.values(CLASS_SHORT).join(', ')}. Full names: ${Object.values(CLASS_IDS).join(', ')}`;
  const classId = parseInt(entry[0]);
  const classFullName = CLASS_IDS[classId];

  const lines = [`# ${classFullName} Spell Progression Analysis`, ''];
  lines.push(`*How ${classFullName} spells evolve across levels — new effects gained, power curve, and milestone levels.*`, '');

  // Collect spells by level
  const spellsByLevel = new Map<number, { name: string; beneficial: boolean; catId: number; spas: number[] }[]>();
  const spaFirstSeen = new Map<number, number>(); // spa -> first level seen

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]);
    if (isNaN(level) || level < 1 || level > 254) continue;
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;

    // Parse SPA effects
    const spas: number[] = [];
    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) {
        effectField = spell.fields[i];
        break;
      }
    }
    if (effectField) {
      const slots = effectField.split('$');
      for (const slot of slots) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spa = parseInt(parts[1]);
          if (!isNaN(spa) && spa > 0) {
            spas.push(spa);
            if (!spaFirstSeen.has(spa) || level < spaFirstSeen.get(spa)!) {
              spaFirstSeen.set(spa, level);
            }
          }
        }
      }
    }

    if (!spellsByLevel.has(level)) spellsByLevel.set(level, []);
    spellsByLevel.get(level)!.push({ name: spell.name, beneficial, catId, spas });
  }

  const totalSpells = [...spellsByLevel.values()].reduce((sum, arr) => sum + arr.length, 0);
  const levels = [...spellsByLevel.keys()].sort((a, b) => a - b);
  const distinctSPAs = spaFirstSeen.size;

  lines.push(`- **Total spells:** ${totalSpells.toLocaleString()}`);
  lines.push(`- **Level range:** ${levels[0]} to ${levels[levels.length - 1]}`);
  lines.push(`- **Levels with new spells:** ${levels.length}`);
  lines.push(`- **Distinct effect types gained:** ${distinctSPAs}`);

  // Spells per level bracket
  const brackets = [
    { label: '1-10', min: 1, max: 10 },
    { label: '11-20', min: 11, max: 20 },
    { label: '21-30', min: 21, max: 30 },
    { label: '31-40', min: 31, max: 40 },
    { label: '41-50', min: 41, max: 50 },
    { label: '51-60', min: 51, max: 60 },
    { label: '61-70', min: 61, max: 70 },
    { label: '71-80', min: 71, max: 80 },
    { label: '81-90', min: 81, max: 90 },
    { label: '91-100', min: 91, max: 100 },
    { label: '101-110', min: 101, max: 110 },
    { label: '111+', min: 111, max: 999 },
  ];

  lines.push('', '## Spell Gain by Level Bracket', '');
  lines.push('| Bracket | New Spells | New Effects | Ben/Det |');
  lines.push('|---------|-----------|-------------|---------|');

  for (const bracket of brackets) {
    let spellCount = 0, newEffects = 0, ben = 0, det = 0;
    const bracketSPAs = new Set<number>();
    for (const [level, spellList] of spellsByLevel) {
      if (level >= bracket.min && level <= bracket.max) {
        spellCount += spellList.length;
        for (const s of spellList) {
          if (s.beneficial) ben++;
          else det++;
          for (const spa of s.spas) {
            if (spaFirstSeen.get(spa) === level && !bracketSPAs.has(spa)) {
              bracketSPAs.add(spa);
              newEffects++;
            }
          }
        }
      }
    }
    if (spellCount > 0) {
      lines.push(`| ${bracket.label} | ${spellCount} | ${newEffects} | ${ben}/${det} |`);
    }
  }

  // Milestone levels (first time gaining key effects)
  const keyEffects = [0, 15, 34, 35, 57, 26, 80, 82, 21, 22, 23, 74, 31, 87, 33, 11, 85, 119, 200, 202, 140];
  const milestones: { level: number; effect: string; spa: number }[] = [];
  for (const spa of keyEffects) {
    if (spaFirstSeen.has(spa)) {
      milestones.push({ level: spaFirstSeen.get(spa)!, effect: SPA_NAMES[spa] || `SPA ${spa}`, spa });
    }
  }
  milestones.sort((a, b) => a.level - b.level);

  if (milestones.length > 0) {
    lines.push('', '## Key Effect Milestones', '');
    lines.push('| Level | Effect | SPA |');
    lines.push('|-------|--------|-----|');
    for (const m of milestones) {
      lines.push(`| ${m.level} | ${m.effect} | ${m.spa} |`);
    }
  }

  // Peak levels (most new spells)
  const levelCounts = [...spellsByLevel.entries()]
    .map(([level, list]) => ({ level, count: list.length }))
    .sort((a, b) => b.count - a.count);

  lines.push('', '## Peak Spell Levels (Most New Spells)', '');
  for (const { level, count } of levelCounts.slice(0, 10)) {
    const bar = '#'.repeat(Math.min(count, 30));
    lines.push(`- **Level ${level}:** ${count} new spells ${bar}`);
  }

  return lines.join('\n');
}

// ============ TELEPORT NETWORK ANALYSIS ============

export async function getTeleportNetworkAnalysis(): Promise<string> {
  await loadSpells();
  await loadZones();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Teleport Network Analysis', ''];
  lines.push('*Zone connectivity via teleport spells — hub zones, class access, and network topology.*', '');

  // Collect teleport spells with class info
  interface TeleportEdge {
    spellId: number;
    spellName: string;
    destZone: string;
    classes: Set<string>;
    minLevel: number;
  }

  const destMap = new Map<string, TeleportEdge[]>(); // zone -> edges targeting it
  const classDestinations = new Map<string, Set<string>>(); // class -> destinations

  for (const spell of spells.values()) {
    const tz = spell.fields[SF.TELEPORT_ZONE]?.trim();
    if (!tz || !/^[a-z_]+[a-z0-9_]*$/.test(tz)) continue;
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const classes = new Set<string>();
    let minLevel = 255;
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < 255) {
        classes.add(CLASS_SHORT[i]);
        if (level < minLevel) minLevel = level;
      }
    }

    if (!destMap.has(tz)) destMap.set(tz, []);
    destMap.get(tz)!.push({ spellId: spell.id, spellName: spell.name, destZone: tz, classes, minLevel });

    for (const cls of classes) {
      if (!classDestinations.has(cls)) classDestinations.set(cls, new Set());
      classDestinations.get(cls)!.add(tz);
    }
  }

  const totalDestinations = destMap.size;
  const totalTeleportSpells = [...destMap.values()].reduce((s, edges) => s + edges.length, 0);

  lines.push(`- **Total teleport spells:** ${totalTeleportSpells.toLocaleString()}`);
  lines.push(`- **Unique destinations:** ${totalDestinations}`);
  lines.push(`- **Classes with teleports:** ${classDestinations.size}`, '');

  // Hub zones (most teleport spells targeting them)
  lines.push('## Hub Zones (Most Teleport Access)', '');
  lines.push('| Zone | Spells | Classes With Access | Earliest Level |');
  lines.push('|------|--------|--------------------|--------------:|');
  const hubZones = [...destMap.entries()]
    .map(([zone, edges]) => {
      const allClasses = new Set<string>();
      let earliest = 255;
      for (const e of edges) {
        for (const c of e.classes) allClasses.add(c);
        if (e.minLevel < earliest) earliest = e.minLevel;
      }
      return { zone, spellCount: edges.length, classes: allClasses, earliest };
    })
    .sort((a, b) => b.spellCount - a.spellCount);

  for (const h of hubZones.slice(0, 20)) {
    const classStr = [...h.classes].sort().join(', ');
    lines.push(`| ${h.zone} | ${h.spellCount} | ${classStr} | ${h.earliest} |`);
  }

  // Class teleport access rankings
  lines.push('', '## Class Teleport Access Rankings', '');
  lines.push('| Class | Unique Destinations | Teleport Spells |');
  lines.push('|-------|--------------------:|----------------:|');
  const classRankings = [...classDestinations.entries()]
    .map(([cls, dests]) => {
      let spellCount = 0;
      for (const edges of destMap.values()) {
        for (const e of edges) {
          if (e.classes.has(cls)) spellCount++;
        }
      }
      return { cls, dests: dests.size, spellCount };
    })
    .sort((a, b) => b.dests - a.dests);
  for (const r of classRankings) {
    lines.push(`| ${r.cls} | ${r.dests} | ${r.spellCount} |`);
  }

  // Zones with level data cross-referenced
  if (zones && zones.size > 0) {
    lines.push('', '## Teleport Destinations by Level Range', '');
    lines.push('| Level Range | Zones With Teleport | Total Zones | Coverage % |');
    lines.push('|-------------|--------------------:|------------:|-----------:|');

    const brackets = [
      [1, 10], [11, 20], [21, 30], [31, 40], [41, 50],
      [51, 60], [61, 70], [71, 80], [81, 90], [91, 100], [101, 125]
    ];

    // Find teleport zone names that match actual zone names
    const teleportZoneNames = new Set([...destMap.keys()].map(z => z.toLowerCase()));

    for (const [lo, hi] of brackets) {
      let totalZones = 0;
      let teleportZones = 0;
      for (const z of zones.values()) {
        if (z.levelMin >= lo && z.levelMin <= hi) {
          totalZones++;
          // Check if this zone's name matches any teleport destination
          const zoneNameLower = z.name.toLowerCase().replace(/[^a-z0-9]/g, '');
          if (teleportZoneNames.has(zoneNameLower)) teleportZones++;
        }
      }
      if (totalZones > 0) {
        const pct = ((teleportZones / totalZones) * 100).toFixed(1);
        lines.push(`| ${lo}-${hi} | ${teleportZones} | ${totalZones} | ${pct}% |`);
      }
    }
  }

  // Exclusive destinations (only one class can reach)
  const exclusiveDests: { zone: string; cls: string; spellName: string }[] = [];
  for (const [zone, edges] of destMap) {
    const allClasses = new Set<string>();
    for (const e of edges) {
      for (const c of e.classes) allClasses.add(c);
    }
    if (allClasses.size === 1) {
      const cls = [...allClasses][0];
      exclusiveDests.push({ zone, cls, spellName: edges[0].spellName });
    }
  }

  if (exclusiveDests.length > 0) {
    lines.push('', '## Class-Exclusive Destinations', '');
    lines.push('| Zone | Exclusive To | Sample Spell |');
    lines.push('|------|-------------|-------------|');
    for (const d of exclusiveDests.slice(0, 20)) {
      lines.push(`| ${d.zone} | ${d.cls} | ${d.spellName} |`);
    }
    if (exclusiveDests.length > 20) {
      lines.push(`| ... | ${exclusiveDests.length - 20} more | |`);
    }
  }

  return lines.join('\n');
}

// ============ ZONE CONTENT DENSITY RANKING ============

export async function getZoneContentDensityRanking(): Promise<string> {
  await loadZones();
  await loadSpells();
  await buildMapDirIndex();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const lines = ['# Zone Content Density Ranking', ''];
  lines.push('*Zones ranked by content richness — map POIs, teleport accessibility, and level range.*', '');

  // Collect teleport spells per zone (keyed by short name)
  const teleportsByZone = new Map<string, number>();
  if (spells) {
    for (const spell of spells.values()) {
      const tz = spell.fields[SF.TELEPORT_ZONE]?.trim();
      if (!tz || !/^[a-z_]+[a-z0-9_]*$/.test(tz)) continue;
      teleportsByZone.set(tz, (teleportsByZone.get(tz) || 0) + 1);
    }
  }

  // Count POIs per zone short name from map directory index
  const mapPOICount = new Map<string, number>();
  if (mapDirIndex && mapDirIndex.size > 0) {
    for (const [shortName, dir] of mapDirIndex) {
      try {
        const content = await readFile(join(dir, `${shortName}.txt`), 'utf-8');
        let poiCount = 0;
        for (const line of content.split('\n')) {
          if (line.startsWith('P ')) poiCount++;
        }
        if (poiCount > 0) mapPOICount.set(shortName, poiCount);
      } catch { /* skip unreadable */ }
    }
  }

  // Build zone scores using deriveShortName for matching
  interface ZoneScore {
    name: string;
    shortName: string;
    levelMin: number;
    levelMax: number;
    levelRange: number;
    poiCount: number;
    teleportSpells: number;
    score: number;
  }

  const zoneScores: ZoneScore[] = [];
  for (const z of zones.values()) {
    const candidates = deriveShortName(z.name);

    // Find best matching short name
    let poiCount = 0;
    let teleportSpells = 0;
    let matchedShort = candidates[0] || '';
    for (const c of candidates) {
      const poi = mapPOICount.get(c) || 0;
      const tp = teleportsByZone.get(c) || 0;
      if (poi > poiCount || tp > teleportSpells) {
        poiCount = Math.max(poiCount, poi);
        teleportSpells = Math.max(teleportSpells, tp);
        matchedShort = c;
      }
      // Also check with underscores removed
      const noUnderscore = c.replace(/_/g, '');
      const poi2 = mapPOICount.get(noUnderscore) || 0;
      const tp2 = teleportsByZone.get(noUnderscore) || 0;
      if (poi2 > poiCount || tp2 > teleportSpells) {
        poiCount = Math.max(poiCount, poi2);
        teleportSpells = Math.max(teleportSpells, tp2);
        matchedShort = noUnderscore;
      }
    }

    const levelRange = z.levelMax > 0 ? z.levelMax - z.levelMin : 0;

    // Content density score: weighted combination
    const score = poiCount * 1 + teleportSpells * 5 + levelRange * 2;

    zoneScores.push({
      name: z.name,
      shortName: matchedShort,
      levelMin: z.levelMin,
      levelMax: z.levelMax,
      levelRange,
      poiCount,
      teleportSpells,
      score
    });
  }

  zoneScores.sort((a, b) => b.score - a.score);

  const withPOIs = zoneScores.filter(z => z.poiCount > 0).length;
  const withTeleports = zoneScores.filter(z => z.teleportSpells > 0).length;
  const withLevels = zoneScores.filter(z => z.levelMin > 0).length;

  lines.push(`- **Total zones:** ${zones.size}`);
  lines.push(`- **Zones with map POIs:** ${withPOIs}`);
  lines.push(`- **Zones with teleport access:** ${withTeleports}`);
  lines.push(`- **Zones with level ranges:** ${withLevels}`, '');

  // Top 30 most content-rich zones
  lines.push('## Most Content-Rich Zones (Top 30)', '');
  lines.push('| Rank | Zone | Level | POIs | Teleports | Score |');
  lines.push('|-----:|------|------:|-----:|----------:|------:|');
  for (let i = 0; i < Math.min(30, zoneScores.length); i++) {
    const z = zoneScores[i];
    if (z.score === 0) break;
    const levelStr = z.levelMin > 0 ? `${z.levelMin}-${z.levelMax}` : '-';
    lines.push(`| ${i + 1} | ${z.name} | ${levelStr} | ${z.poiCount} | ${z.teleportSpells} | ${z.score} |`);
  }

  // Bottom 20 (least content)
  const nonEmpty = zoneScores.filter(z => z.score > 0);
  if (nonEmpty.length > 30) {
    lines.push('', '## Least Content-Rich Zones (With Any Data)', '');
    lines.push('| Zone | Level | POIs | Teleports | Score |');
    lines.push('|------|------:|-----:|----------:|------:|');
    const bottom = nonEmpty.slice(-20).reverse();
    for (const z of bottom) {
      const levelStr = z.levelMin > 0 ? `${z.levelMin}-${z.levelMax}` : '-';
      lines.push(`| ${z.name} | ${levelStr} | ${z.poiCount} | ${z.teleportSpells} | ${z.score} |`);
    }
  }

  // POI density distribution
  lines.push('', '## Map POI Distribution', '');
  const poiBuckets = [0, 1, 10, 25, 50, 100, 250, 500, Infinity];
  lines.push('| POI Range | Zones |');
  lines.push('|-----------|------:|');
  for (let i = 0; i < poiBuckets.length - 1; i++) {
    const lo = poiBuckets[i];
    const hi = poiBuckets[i + 1];
    const count = zoneScores.filter(z => z.poiCount >= lo && z.poiCount < hi).length;
    const label = hi === Infinity ? `${lo}+` : `${lo}-${hi - 1}`;
    lines.push(`| ${label} | ${count} |`);
  }

  // Zones with no data at all
  const empty = zoneScores.filter(z => z.score === 0);
  if (empty.length > 0) {
    lines.push('', `## Zones With No Content Data: ${empty.length}`, '');
    lines.push('*These zones have no map POIs, no teleport spells, and no level range defined.*');
  }

  return lines.join('\n');
}

// ============ CLASS POWER MILESTONE TIMELINE ============

export async function getClassPowerMilestoneTimeline(className: string): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  await loadSkillCaps();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const cn = className.toUpperCase().trim();
  let entry = Object.entries(CLASS_SHORT).find(([, short]) => short === cn);
  if (!entry) {
    entry = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase().trim());
  }
  if (!entry) return `Unknown class: "${className}". Valid short codes: ${Object.values(CLASS_SHORT).join(', ')}. Full names: ${Object.values(CLASS_IDS).join(', ')}`;
  const classId = parseInt(entry[0]);
  const classFullName = CLASS_IDS[classId];

  const lines = [`# ${classFullName} Power Milestone Timeline`, ''];
  lines.push(`*Unified progression view — spells, stats, and skills across levels.*`, '');

  // Collect spells by level
  const spellsByLevel = new Map<number, { name: string; catId: number; beneficial: boolean; spas: number[] }[]>();
  const categoriesSeenByLevel = new Map<number, Set<number>>();

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]);
    if (isNaN(level) || level < 1 || level > 254) continue;
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    const spas: number[] = [];
    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) {
        effectField = spell.fields[i];
        break;
      }
    }
    if (effectField) {
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          if (!isNaN(spaId) && spaId > 0) spas.push(spaId);
        }
      }
    }

    if (!spellsByLevel.has(level)) spellsByLevel.set(level, []);
    spellsByLevel.get(level)!.push({ name: spell.name, catId, beneficial, spas });

    if (!categoriesSeenByLevel.has(level)) categoriesSeenByLevel.set(level, new Set());
    categoriesSeenByLevel.get(level)!.add(catId);
  }

  // Collect base stats by level
  const statsAtLevel = new Map<number, BaseStatEntry>();
  if (baseStats) {
    for (const s of baseStats) {
      if (s.classId === classId) statsAtLevel.set(s.level, s);
    }
  }

  // Collect skill cap milestones (new skills unlocked)
  const skillsUnlockedByLevel = new Map<number, number>(); // level -> number of new skills unlocked
  const skillNames: Record<number, string> = {
    0: '1H Blunt', 1: '1H Slash', 2: '2H Blunt', 3: '2H Slash', 4: 'Abjuration',
    5: 'Alteration', 6: 'Apply Poison', 7: 'Archery', 8: 'Backstab', 9: 'Bind Wound',
    10: 'Bash', 11: 'Block', 12: 'Brass', 13: 'Channeling', 14: 'Conjuration',
    15: 'Defense', 16: 'Disarm', 17: 'Disarm Traps', 18: 'Divination', 19: 'Dodge',
    20: 'Double Attack', 21: 'Dragon Punch', 22: 'Dual Wield', 23: 'Eagle Strike',
    24: 'Evocation', 25: 'Feign Death', 26: 'Flying Kick', 27: 'Forage', 28: 'Hand to Hand',
    29: 'Hide', 30: 'Kick', 31: 'Meditate', 32: 'Mend', 33: 'Offense', 34: 'Parry',
    35: 'Pick Lock', 36: 'Piercing', 37: 'Riposte', 38: 'Round Kick', 39: 'Safe Fall',
    40: 'Sense Heading', 41: 'Singing', 42: 'Sneak', 43: 'Specialize Abjure',
    44: 'Specialize Alter', 45: 'Specialize Conjure', 46: 'Specialize Divination',
    47: 'Specialize Evocation', 48: 'Spell Casting Mastery', 49: 'Swimming', 50: 'Throwing',
    51: 'Tiger Claw', 52: 'Tracking', 53: 'Wind', 54: 'Fishing', 55: 'Make Poison',
    56: 'Tinkering', 57: 'Research', 58: 'Alchemy', 59: 'Baking', 60: 'Tailoring',
    61: 'Sense Traps', 62: 'Blacksmithing', 63: 'Fletching', 64: 'Brewing', 65: 'Alcohol Tolerance',
    66: 'Begging', 67: 'Jewelry', 68: 'Pottery', 69: 'Percussion', 70: 'Intimidation',
    71: 'Berserking', 72: 'Taunt', 73: 'Frenzy', 74: '2H Piercing'
  };

  if (skillCaps) {
    // Track first level each skill becomes available (cap > 0)
    const skillFirstLevel = new Map<number, number>();
    for (const sc of skillCaps) {
      if (sc.classId !== classId || sc.cap <= 0) continue;
      if (!skillFirstLevel.has(sc.skillId) || sc.level < skillFirstLevel.get(sc.skillId)!) {
        skillFirstLevel.set(sc.skillId, sc.level);
      }
    }
    for (const [, level] of skillFirstLevel) {
      skillsUnlockedByLevel.set(level, (skillsUnlockedByLevel.get(level) || 0) + 1);
    }
  }

  // Build level brackets timeline
  const brackets = [
    [1, 5], [6, 10], [11, 15], [16, 20], [21, 25], [26, 30],
    [31, 35], [36, 40], [41, 45], [46, 50], [51, 55], [56, 60],
    [61, 65], [66, 70], [71, 75], [76, 80], [81, 85], [86, 90],
    [91, 95], [96, 100], [101, 105], [106, 110], [111, 115], [116, 120], [121, 125]
  ];

  lines.push('## Power Progression by Level Bracket', '');
  lines.push('| Bracket | Spells | New Categories | Skills Unlocked | HP | Mana | Endurance |');
  lines.push('|---------|-------:|---------------:|----------------:|---:|-----:|----------:|');

  const allCategoriesSeen = new Set<number>();
  for (const [lo, hi] of brackets) {
    let spellCount = 0;
    const bracketCategories = new Set<number>();
    let newCategories = 0;
    let skillsUnlocked = 0;

    for (let lvl = lo; lvl <= hi; lvl++) {
      const lvlSpells = spellsByLevel.get(lvl);
      if (lvlSpells) {
        spellCount += lvlSpells.length;
        for (const s of lvlSpells) {
          if (s.catId > 0) bracketCategories.add(s.catId);
        }
      }
      skillsUnlocked += skillsUnlockedByLevel.get(lvl) || 0;
    }

    for (const cat of bracketCategories) {
      if (!allCategoriesSeen.has(cat)) {
        newCategories++;
        allCategoriesSeen.add(cat);
      }
    }

    // Get stats at bracket end
    const endStats = statsAtLevel.get(hi);
    const hp = endStats ? endStats.hp.toLocaleString() : '-';
    const mana = endStats ? endStats.mana.toLocaleString() : '-';
    const endur = endStats ? endStats.endurance.toLocaleString() : '-';

    if (spellCount > 0 || skillsUnlocked > 0 || endStats) {
      lines.push(`| ${lo}-${hi} | ${spellCount} | ${newCategories > 0 ? '+' + newCategories : '-'} | ${skillsUnlocked > 0 ? '+' + skillsUnlocked : '-'} | ${hp} | ${mana} | ${endur} |`);
    }
  }

  // Key milestones (notable spell categories gained)
  lines.push('', '## Notable Milestones', '');
  const catFirstSeen: { catId: number; level: number }[] = [];
  const catSeenTracker = new Set<number>();
  const sortedLevels = [...spellsByLevel.keys()].sort((a, b) => a - b);
  for (const lvl of sortedLevels) {
    const lvlSpells = spellsByLevel.get(lvl)!;
    for (const s of lvlSpells) {
      if (s.catId > 0 && !catSeenTracker.has(s.catId)) {
        catSeenTracker.add(s.catId);
        catFirstSeen.push({ catId: s.catId, level: lvl });
      }
    }
  }

  if (catFirstSeen.length > 0) {
    lines.push('| Level | First Spell Category Gained |');
    lines.push('|------:|-----------------------------|');
    for (const { catId, level } of catFirstSeen.slice(0, 30)) {
      // Get category name from spell_categories if available
      const catName = spellCategories?.get(catId) || `Category ${catId}`;
      lines.push(`| ${level} | ${catName} |`);
    }
    if (catFirstSeen.length > 30) {
      lines.push(`| ... | +${catFirstSeen.length - 30} more categories |`);
    }
  }

  // Stat growth curve
  if (statsAtLevel.size > 0) {
    lines.push('', '## Stat Growth Curve', '');
    lines.push('| Level | HP | Mana | Endurance | HP Regen | Mana Regen |');
    lines.push('|------:|---:|-----:|----------:|---------:|-----------:|');
    const milestones = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 125];
    for (const lvl of milestones) {
      const s = statsAtLevel.get(lvl);
      if (s) {
        lines.push(`| ${lvl} | ${s.hp.toLocaleString()} | ${s.mana.toLocaleString()} | ${s.endurance.toLocaleString()} | ${s.hpRegen} | ${s.manaRegen} |`);
      }
    }
  }

  return lines.join('\n');
}

// ============ RESIST TYPE BY LEVEL ANALYSIS ============

export async function getResistTypeByLevelAnalysis(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Resist Type Distribution by Level', ''];
  lines.push('*Which resist types dominate detrimental spells at each level bracket — useful for gearing decisions.*', '');

  const RESIST_NAMES: Record<number, string> = {
    0: 'Unresistable', 1: 'Magic', 2: 'Fire', 3: 'Cold',
    4: 'Poison', 5: 'Disease', 6: 'Chromatic', 7: 'Prismatic',
    8: 'Physical', 9: 'Corruption'
  };

  // For each level bracket, count detrimental spells by resist type
  const brackets = [
    [1, 10], [11, 20], [21, 30], [31, 40], [41, 50],
    [51, 60], [61, 70], [71, 80], [81, 90], [91, 100],
    [101, 110], [111, 120], [121, 125]
  ];

  const bracketData: { range: string; counts: Record<number, number>; total: number }[] = [];
  const overallCounts: Record<number, number> = {};

  for (const [lo, hi] of brackets) {
    const counts: Record<number, number> = {};
    let total = 0;

    for (const spell of spells.values()) {
      if (spell.fields[SF.BENEFICIAL] === '1') continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      // Find minimum class level for this spell
      let minLevel = 255;
      for (let i = 1; i <= 16; i++) {
        const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
        if (level > 0 && level < minLevel) minLevel = level;
      }
      if (minLevel < lo || minLevel > hi) continue;

      const resistType = parseInt(spell.fields[SF.RESIST_TYPE]) || 0;
      counts[resistType] = (counts[resistType] || 0) + 1;
      overallCounts[resistType] = (overallCounts[resistType] || 0) + 1;
      total++;
    }

    if (total > 0) {
      bracketData.push({ range: `${lo}-${hi}`, counts, total });
    }
  }

  // Overall distribution
  const totalOverall = Object.values(overallCounts).reduce((s, v) => s + v, 0);
  lines.push('## Overall Resist Type Distribution (Detrimental Spells)', '');
  lines.push('| Resist Type | Count | % |');
  lines.push('|-------------|------:|--:|');
  const sortedOverall = Object.entries(overallCounts).sort((a, b) => parseInt(b[1].toString()) - parseInt(a[1].toString()));
  for (const [rt, count] of sortedOverall) {
    const name = RESIST_NAMES[parseInt(rt)] || `Unknown(${rt})`;
    const pct = ((count / totalOverall) * 100).toFixed(1);
    lines.push(`| ${name} | ${count.toLocaleString()} | ${pct}% |`);
  }

  // Matrix: bracket vs resist type
  const activeResists = [...new Set(Object.keys(overallCounts).map(Number))].sort((a, b) => a - b);
  lines.push('', '## Resist Type by Level Bracket', '');
  const header = ['Bracket', ...activeResists.map(r => RESIST_NAMES[r] || `R${r}`), 'Total', 'Dominant'];
  lines.push('| ' + header.join(' | ') + ' |');
  lines.push('|' + header.map(() => '---').join('|') + '|');

  for (const bd of bracketData) {
    let maxCount = 0;
    let dominant = '';
    const cells = [bd.range];
    for (const r of activeResists) {
      const count = bd.counts[r] || 0;
      cells.push(count.toString());
      if (count > maxCount) {
        maxCount = count;
        dominant = RESIST_NAMES[r] || `R${r}`;
      }
    }
    cells.push(bd.total.toString());
    cells.push(dominant);
    lines.push('| ' + cells.join(' | ') + ' |');
  }

  // Percentage matrix
  lines.push('', '## Resist Type % by Level Bracket', '');
  const pctHeader = ['Bracket', ...activeResists.map(r => RESIST_NAMES[r] || `R${r}`)];
  lines.push('| ' + pctHeader.join(' | ') + ' |');
  lines.push('|' + pctHeader.map(() => '---').join('|') + '|');

  for (const bd of bracketData) {
    const cells = [bd.range];
    for (const r of activeResists) {
      const count = bd.counts[r] || 0;
      const pct = bd.total > 0 ? ((count / bd.total) * 100).toFixed(0) : '0';
      cells.push(pct + '%');
    }
    lines.push('| ' + cells.join(' | ') + ' |');
  }

  // Gear recommendation summary
  lines.push('', '## Gearing Priority by Level Range', '');
  for (const bd of bracketData) {
    const sorted = Object.entries(bd.counts)
      .filter(([rt]) => parseInt(rt) > 0) // exclude unresistable
      .sort((a, b) => b[1] - a[1]);
    if (sorted.length >= 2) {
      const top = sorted.slice(0, 3).map(([rt, count]) => {
        const name = RESIST_NAMES[parseInt(rt)] || `R${rt}`;
        const pct = ((count / bd.total) * 100).toFixed(0);
        return `${name} (${pct}%)`;
      });
      lines.push(`- **Level ${bd.range}:** ${top.join(' > ')}`);
    }
  }

  return lines.join('\n');
}

// ============ CLASS ROLE ANALYSIS ============

export async function getClassRoleAnalysis(): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Role Analysis', ''];
  lines.push('*Each class classified by role based on spell effect distribution and base stat profile.*', '');

  // Define role indicators by SPA
  const HEAL_SPAS = new Set([0, 147]); // HP, Complete Heal
  const TANK_SPAS = new Set([1, 55, 69, 162, 172]); // AC, Absorb Damage, Max HP, Hate, Spell Shield
  const DPS_SPAS = new Set([0, 79, 85, 119, 330, 374, 413]); // HP (det), Spell Proc, Melee Proc, Crit, NukeDmg
  const CC_SPAS = new Set([21, 22, 23, 31, 74]); // Stun, Charm, Fear, Snare, Mesmerize
  const UTILITY_SPAS = new Set([3, 26, 57, 59, 106, 123]); // Movement, Gate, Levitate, Invis, Rez, Summon

  interface ClassRoleProfile {
    classId: number;
    name: string;
    short: string;
    healSpells: number;
    tankSpells: number;
    dpsSpells: number;
    ccSpells: number;
    utilitySpells: number;
    totalSpells: number;
    beneficialPct: number;
    hp: number;
    mana: number;
    endurance: number;
    primaryRole: string;
  }

  const profiles: ClassRoleProfile[] = [];

  for (let cid = 1; cid <= 16; cid++) {
    let healSpells = 0, tankSpells = 0, dpsSpells = 0, ccSpells = 0, utilitySpells = 0;
    let totalSpells = 0, beneficial = 0;

    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      totalSpells++;
      if (spell.fields[SF.BENEFICIAL] === '1') beneficial++;

      // Parse effects
      let effectField = '';
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
      }
      if (!effectField) continue;

      const spas = new Set<number>();
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          if (!isNaN(spaId) && spaId > 0) spas.add(spaId);
        }
      }

      const isBeneficial = spell.fields[SF.BENEFICIAL] === '1';
      for (const spa of spas) {
        if (HEAL_SPAS.has(spa) && isBeneficial) healSpells++;
        if (TANK_SPAS.has(spa)) tankSpells++;
        if (DPS_SPAS.has(spa) && !isBeneficial) dpsSpells++;
        if (CC_SPAS.has(spa)) ccSpells++;
        if (UTILITY_SPAS.has(spa)) utilitySpells++;
      }
    }

    // Get base stats at level 100
    let hp = 0, mana = 0, endurance = 0;
    if (baseStats) {
      const stat = baseStats.find(s => s.classId === cid && s.level === 100);
      if (stat) { hp = stat.hp; mana = stat.mana; endurance = stat.endurance; }
    }

    // Determine primary role
    const scores = { Tank: tankSpells, Healer: healSpells, DPS: dpsSpells, 'Crowd Control': ccSpells, Utility: utilitySpells };
    const primaryRole = Object.entries(scores).sort((a, b) => b[1] - a[1])[0][0];

    profiles.push({
      classId: cid,
      name: CLASS_IDS[cid],
      short: CLASS_SHORT[cid],
      healSpells, tankSpells, dpsSpells, ccSpells, utilitySpells,
      totalSpells,
      beneficialPct: totalSpells > 0 ? (beneficial / totalSpells) * 100 : 0,
      hp, mana, endurance,
      primaryRole
    });
  }

  // Role distribution table
  lines.push('## Spell Role Distribution by Class', '');
  lines.push('| Class | Total | Heal | Tank | DPS | CC | Utility | Buff % | Primary Role |');
  lines.push('|-------|------:|-----:|-----:|----:|---:|--------:|-------:|-------------|');
  for (const p of profiles) {
    lines.push(`| ${p.name} (${p.short}) | ${p.totalSpells.toLocaleString()} | ${p.healSpells} | ${p.tankSpells} | ${p.dpsSpells} | ${p.ccSpells} | ${p.utilitySpells} | ${p.beneficialPct.toFixed(0)}% | ${p.primaryRole} |`);
  }

  // Stat profiles
  if (baseStats && baseStats.length > 0) {
    lines.push('', '## Base Stat Profiles at Level 100', '');
    lines.push('| Class | HP | Mana | Endurance | HP/Mana Ratio | Archetype |');
    lines.push('|-------|---:|-----:|----------:|--------------:|-----------|');
    for (const p of profiles) {
      const ratio = p.mana > 0 ? (p.hp / p.mana).toFixed(2) : 'N/A';
      let archetype = 'Hybrid';
      if (p.mana === 0 || (p.hp > 0 && p.mana > 0 && p.hp / p.mana > 2)) archetype = 'Melee';
      else if (p.hp > 0 && p.mana > 0 && p.hp / p.mana < 1.2) archetype = 'Caster';
      lines.push(`| ${p.name} (${p.short}) | ${p.hp.toLocaleString()} | ${p.mana.toLocaleString()} | ${p.endurance.toLocaleString()} | ${ratio} | ${archetype} |`);
    }
  }

  // Role groupings
  lines.push('', '## Class Groupings by Role Strength', '');
  const roleNames = ['Tank', 'Healer', 'DPS', 'Crowd Control', 'Utility'];
  for (const role of roleNames) {
    const ranked = profiles
      .map(p => ({
        name: `${p.name} (${p.short})`,
        score: role === 'Tank' ? p.tankSpells : role === 'Healer' ? p.healSpells : role === 'DPS' ? p.dpsSpells : role === 'Crowd Control' ? p.ccSpells : p.utilitySpells
      }))
      .filter(p => p.score > 0)
      .sort((a, b) => b.score - a.score);
    if (ranked.length > 0) {
      lines.push(`- **${role}:** ${ranked.slice(0, 5).map(r => `${r.name} (${r.score})`).join(', ')}`);
    }
  }

  return lines.join('\n');
}

// ============ SPELL COST EFFICIENCY ANALYSIS ============

export async function getSpellCostEfficiencyAnalysis(className: string): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const cn = className.toUpperCase().trim();
  let entry = Object.entries(CLASS_SHORT).find(([, short]) => short === cn);
  if (!entry) {
    entry = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase().trim());
  }
  if (!entry) return `Unknown class: "${className}". Valid short codes: ${Object.values(CLASS_SHORT).join(', ')}. Full names: ${Object.values(CLASS_IDS).join(', ')}`;
  const classId = parseInt(entry[0]);
  const classFullName = CLASS_IDS[classId];

  const lines = [`# ${classFullName} Spell Cost Efficiency Analysis`, ''];
  lines.push(`*Mana/endurance costs relative to resource pools — where spells become efficient or prohibitive.*`, '');

  // Get base stats by level
  const statsAtLevel = new Map<number, BaseStatEntry>();
  if (baseStats) {
    for (const s of baseStats) {
      if (s.classId === classId) statsAtLevel.set(s.level, s);
    }
  }

  // Collect spells by level with mana costs
  const brackets = [
    [1, 10], [11, 20], [21, 30], [31, 40], [41, 50],
    [51, 60], [61, 70], [71, 80], [81, 90], [91, 100],
    [101, 110], [111, 120], [121, 125]
  ];

  interface BracketStats {
    range: string;
    spellCount: number;
    avgManaCost: number;
    maxManaCost: number;
    avgEndCost: number;
    maxEndCost: number;
    manaPool: number;
    endPool: number;
    castsPerPool: number;
    mostExpensiveSpell: string;
    mostExpensiveCost: number;
  }

  const bracketStats: BracketStats[] = [];

  for (const [lo, hi] of brackets) {
    let spellCount = 0;
    let totalManaCost = 0;
    let maxManaCost = 0;
    let totalEndCost = 0;
    let maxEndCost = 0;
    let manaSpellCount = 0;
    let endSpellCount = 0;
    let mostExpensiveSpell = '';
    let mostExpensiveCost = 0;

    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
      if (level < lo || level > hi) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      spellCount++;
      const manaCost = parseInt(spell.fields[SF.MANA]) || 0;
      const endCost = parseInt(spell.fields[SF.ENDURANCE]) || 0;

      if (manaCost > 0) {
        totalManaCost += manaCost;
        manaSpellCount++;
        if (manaCost > maxManaCost) {
          maxManaCost = manaCost;
          mostExpensiveSpell = spell.name;
          mostExpensiveCost = manaCost;
        }
      }
      if (endCost > 0) {
        totalEndCost += endCost;
        endSpellCount++;
        if (endCost > mostExpensiveCost) {
          mostExpensiveCost = endCost;
          mostExpensiveSpell = spell.name + ' (end)';
        }
        if (endCost > maxEndCost) maxEndCost = endCost;
      }
    }

    if (spellCount === 0) continue;

    const avgManaCost = manaSpellCount > 0 ? totalManaCost / manaSpellCount : 0;
    const avgEndCost = endSpellCount > 0 ? totalEndCost / endSpellCount : 0;
    const endLevelStats = statsAtLevel.get(hi);
    const manaPool = endLevelStats?.mana || 0;
    const endPool = endLevelStats?.endurance || 0;
    const castsPerPool = avgManaCost > 0 && manaPool > 0 ? Math.floor(manaPool / avgManaCost) : 0;

    bracketStats.push({
      range: `${lo}-${hi}`,
      spellCount, avgManaCost: Math.round(avgManaCost), maxManaCost,
      avgEndCost: Math.round(avgEndCost), maxEndCost,
      manaPool, endPool, castsPerPool,
      mostExpensiveSpell, mostExpensiveCost
    });
  }

  // Overview table
  lines.push('## Cost vs Resource Pool by Level Bracket', '');
  lines.push('| Bracket | Spells | Avg Mana | Max Mana | Mana Pool | Casts/Pool | Most Expensive |');
  lines.push('|---------|-------:|---------:|---------:|----------:|-----------:|----------------|');
  for (const bs of bracketStats) {
    lines.push(`| ${bs.range} | ${bs.spellCount} | ${bs.avgManaCost} | ${bs.maxManaCost} | ${bs.manaPool.toLocaleString()} | ${bs.castsPerPool} | ${bs.mostExpensiveSpell} (${bs.mostExpensiveCost}) |`);
  }

  // Endurance table (if applicable)
  const hasEndurance = bracketStats.some(bs => bs.avgEndCost > 0);
  if (hasEndurance) {
    lines.push('', '## Endurance Cost Analysis', '');
    lines.push('| Bracket | Avg End | Max End | End Pool | Casts/Pool |');
    lines.push('|---------|--------:|--------:|---------:|-----------:|');
    for (const bs of bracketStats) {
      if (bs.avgEndCost > 0) {
        const endCasts = bs.endPool > 0 && bs.avgEndCost > 0 ? Math.floor(bs.endPool / bs.avgEndCost) : 0;
        lines.push(`| ${bs.range} | ${bs.avgEndCost} | ${bs.maxEndCost} | ${bs.endPool.toLocaleString()} | ${endCasts} |`);
      }
    }
  }

  // Efficiency trend
  lines.push('', '## Efficiency Trend', '');
  lines.push('*Casts per full mana pool — higher = more sustainable.*', '');
  for (const bs of bracketStats) {
    if (bs.castsPerPool > 0) {
      const bar = '#'.repeat(Math.min(bs.castsPerPool, 50));
      lines.push(`- **${bs.range}:** ${bs.castsPerPool} casts ${bar}`);
    }
  }

  return lines.join('\n');
}

// ============ DEITY FACTION IMPACT ANALYSIS ============

export async function getDeityFactionImpactAnalysis(): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Deity Faction Impact Analysis', ''];
  lines.push('*How each deity choice affects faction standing across all factions with starting modifiers.*', '');

  // Get unique deity names and their modifier IDs
  const deityEntries: { name: string; modId: number }[] = [];
  const seenModIds = new Set<number>();
  for (const [name, modId] of Object.entries(DEITY_TO_FACTION_MODIFIER)) {
    if (seenModIds.has(modId)) continue;
    seenModIds.add(modId);
    // Use the shortest name for each mod ID
    const existingIdx = deityEntries.findIndex(d => d.modId === modId);
    if (existingIdx >= 0) continue;
    // Capitalize name
    const capName = name.split(/[\s-]+/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    deityEntries.push({ name: capName, modId });
  }

  // For each deity, count positive/negative/neutral impacts
  interface DeityImpact {
    name: string;
    modId: number;
    positive: number;
    negative: number;
    neutral: number;
    totalAffected: number;
    totalPositiveValue: number;
    totalNegativeValue: number;
    bestFaction: string;
    bestValue: number;
    worstFaction: string;
    worstValue: number;
  }

  const impacts: DeityImpact[] = [];

  for (const deity of deityEntries) {
    let positive = 0, negative = 0, neutral = 0;
    let totalPositiveValue = 0, totalNegativeValue = 0;
    let bestFaction = '', bestValue = -Infinity;
    let worstFaction = '', worstValue = Infinity;

    for (const faction of factions.values()) {
      if (!faction.startingValues) continue;
      const sv = faction.startingValues.find(s => s.modifierId === deity.modId);
      if (!sv) continue;

      if (sv.value > 0) {
        positive++;
        totalPositiveValue += sv.value;
        if (sv.value > bestValue) { bestValue = sv.value; bestFaction = faction.name; }
      } else if (sv.value < 0) {
        negative++;
        totalNegativeValue += sv.value;
        if (sv.value < worstValue) { worstValue = sv.value; worstFaction = faction.name; }
      } else {
        neutral++;
      }
    }

    impacts.push({
      name: deity.name, modId: deity.modId,
      positive, negative, neutral,
      totalAffected: positive + negative + neutral,
      totalPositiveValue, totalNegativeValue,
      bestFaction, bestValue: bestValue === -Infinity ? 0 : bestValue,
      worstFaction, worstValue: worstValue === Infinity ? 0 : worstValue
    });
  }

  // Sort by net impact (positive - negative counts)
  impacts.sort((a, b) => (b.positive - b.negative) - (a.positive - a.negative));

  lines.push('## Deity Faction Impact Summary', '');
  lines.push('| Deity | Positive | Negative | Net | Total Affected | Avg Pos | Avg Neg |');
  lines.push('|-------|--------:|---------:|----:|--------------:|--------:|--------:|');
  for (const d of impacts) {
    const avgPos = d.positive > 0 ? Math.round(d.totalPositiveValue / d.positive) : 0;
    const avgNeg = d.negative > 0 ? Math.round(d.totalNegativeValue / d.negative) : 0;
    lines.push(`| ${d.name} | ${d.positive} | ${d.negative} | ${d.positive - d.negative} | ${d.totalAffected} | +${avgPos} | ${avgNeg} |`);
  }

  // Best/worst faction per deity
  lines.push('', '## Strongest Faction Ties', '');
  lines.push('| Deity | Best Faction | Value | Worst Faction | Value |');
  lines.push('|-------|-------------|------:|--------------|------:|');
  for (const d of impacts) {
    if (d.totalAffected > 0) {
      lines.push(`| ${d.name} | ${d.bestFaction || '-'} | ${d.bestValue > 0 ? '+' : ''}${d.bestValue} | ${d.worstFaction || '-'} | ${d.worstValue} |`);
    }
  }

  // Deity accessibility ranking
  lines.push('', '## Deity Accessibility Ranking', '');
  lines.push('*Ranked by fewest hostile factions — lower negative count = easier start.*', '');
  const byAccessibility = [...impacts].sort((a, b) => a.negative - b.negative);
  for (const d of byAccessibility) {
    const bar = '#'.repeat(Math.min(d.negative, 40));
    lines.push(`- **${d.name}:** ${d.negative} hostile factions ${bar}`);
  }

  return lines.join('\n');
}

// ============ SPELL TARGET TYPE MATRIX ============

export async function getSpellTargetTypeMatrix(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Target Type Matrix', ''];
  lines.push('*Class specialization patterns based on spell target type distribution.*', '');

  // For each class, count spells by target type, split by beneficial/detrimental
  const classTargets: Record<number, Record<number, { ben: number; det: number }>> = {};

  for (let cid = 1; cid <= 16; cid++) {
    classTargets[cid] = {};
    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
      if (!classTargets[cid][targetType]) classTargets[cid][targetType] = { ben: 0, det: 0 };
      if (spell.fields[SF.BENEFICIAL] === '1') {
        classTargets[cid][targetType].ben++;
      } else {
        classTargets[cid][targetType].det++;
      }
    }
  }

  // Find all active target types
  const activeTargets = new Set<number>();
  for (const ct of Object.values(classTargets)) {
    for (const tt of Object.keys(ct)) activeTargets.add(parseInt(tt));
  }
  const sortedTargets = [...activeTargets].sort((a, b) => a - b);

  // Main matrix (total per target type per class)
  lines.push('## Total Spells by Target Type per Class', '');
  const header = ['Class', ...sortedTargets.map(t => TARGET_TYPES[t] || `T${t}`)];
  lines.push('| ' + header.join(' | ') + ' |');
  lines.push('|' + header.map(() => '---').join('|') + '|');

  for (let cid = 1; cid <= 16; cid++) {
    const cells = [CLASS_SHORT[cid]];
    for (const tt of sortedTargets) {
      const data = classTargets[cid][tt];
      cells.push(data ? (data.ben + data.det).toString() : '0');
    }
    lines.push('| ' + cells.join(' | ') + ' |');
  }

  // Specialization analysis: which target types each class uses disproportionately
  lines.push('', '## Class Target Specializations', '');
  lines.push('*Target types where a class uses significantly more spells than average.*', '');

  // Calculate averages per target type
  const targetAverages: Record<number, number> = {};
  for (const tt of sortedTargets) {
    let sum = 0;
    for (let cid = 1; cid <= 16; cid++) {
      const data = classTargets[cid][tt];
      sum += data ? data.ben + data.det : 0;
    }
    targetAverages[tt] = sum / 16;
  }

  for (let cid = 1; cid <= 16; cid++) {
    const specializations: { target: string; count: number; avg: number }[] = [];
    for (const tt of sortedTargets) {
      const data = classTargets[cid][tt];
      const count = data ? data.ben + data.det : 0;
      const avg = targetAverages[tt];
      if (count > avg * 1.5 && count > 10) { // 50% above average and meaningful count
        specializations.push({ target: TARGET_TYPES[tt] || `T${tt}`, count, avg: Math.round(avg) });
      }
    }
    if (specializations.length > 0) {
      const specs = specializations.map(s => `${s.target} (${s.count} vs avg ${s.avg})`).join(', ');
      lines.push(`- **${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}):** ${specs}`);
    }
  }

  // Self vs Group vs Single breakdown
  lines.push('', '## Self vs Group vs Single vs AE', '');
  lines.push('| Class | Self | Single | Group | PB AE | Targeted AE | Other |');
  lines.push('|-------|-----:|-------:|------:|------:|------------:|------:|');
  for (let cid = 1; cid <= 16; cid++) {
    const self = classTargets[cid][6] || { ben: 0, det: 0 };
    const single = classTargets[cid][5] || { ben: 0, det: 0 };
    const group1 = classTargets[cid][3] || { ben: 0, det: 0 };
    const group2 = classTargets[cid][41] || { ben: 0, det: 0 };
    const pbae = classTargets[cid][4] || { ben: 0, det: 0 };
    const tae = classTargets[cid][8] || { ben: 0, det: 0 };

    const selfTotal = self.ben + self.det;
    const singleTotal = single.ben + single.det;
    const groupTotal = (group1.ben + group1.det) + (group2.ben + group2.det);
    const pbaeTotal = pbae.ben + pbae.det;
    const taeTotal = tae.ben + tae.det;

    let totalAll = 0;
    for (const data of Object.values(classTargets[cid])) totalAll += data.ben + data.det;
    const other = totalAll - selfTotal - singleTotal - groupTotal - pbaeTotal - taeTotal;

    lines.push(`| ${CLASS_SHORT[cid]} | ${selfTotal} | ${singleTotal} | ${groupTotal} | ${pbaeTotal} | ${taeTotal} | ${other} |`);
  }

  return lines.join('\n');
}

// ============ LEVEL CONTENT GUIDE ============

export async function getLevelContentGuide(level: number): Promise<string> {
  await loadZones();
  await loadSpells();
  await loadAchievements();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  if (level < 1 || level > 125) return 'Level must be between 1 and 125.';

  const lines = [`# Content Guide for Level ${level}`, ''];
  lines.push(`*All available content at level ${level} — zones, spells, and achievements.*`, '');

  // Zones for this level
  const matchingZones = [...zones.values()]
    .filter(z => z.levelMin > 0 && level >= z.levelMin && level <= z.levelMax)
    .sort((a, b) => a.name.localeCompare(b.name));

  lines.push(`## Zones (Level ${level})`, '');
  if (matchingZones.length > 0) {
    lines.push(`Found ${matchingZones.length} zones for level ${level}.`, '');
    lines.push('| Zone | Level Range |');
    lines.push('|------|------------|');
    for (const z of matchingZones) {
      lines.push(`| ${z.name} | ${z.levelMin}-${z.levelMax} |`);
    }
  } else {
    lines.push('No zones found for this level range.');
  }

  // Spells gained at this exact level
  if (spells && spells.size > 0) {
    lines.push('', `## Spells Available at Level ${level}`, '');
    const classSpells: Record<string, string[]> = {};

    for (const spell of spells.values()) {
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      for (let cid = 1; cid <= 16; cid++) {
        const spellLevel = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
        if (spellLevel === level) {
          const cls = CLASS_SHORT[cid];
          if (!classSpells[cls]) classSpells[cls] = [];
          if (classSpells[cls].length < 15) classSpells[cls].push(spell.name);
        }
      }
    }

    const classCount = Object.keys(classSpells).length;
    if (classCount > 0) {
      lines.push(`${classCount} classes gain new spells at level ${level}.`, '');
      for (const [cls, spellList] of Object.entries(classSpells).sort((a, b) => b[1].length - a[1].length)) {
        const totalForClass = spellList.length;
        const shown = spellList.slice(0, 10);
        const suffix = totalForClass > 10 ? ` (+${totalForClass - 10} more)` : '';
        lines.push(`- **${cls}** (${totalForClass}): ${shown.join(', ')}${suffix}`);
      }
    } else {
      lines.push('No new spells are gained at this exact level.');
    }
  }

  // Nearby level content summary
  const range = 5;
  const lo = Math.max(1, level - range);
  const hi = Math.min(125, level + range);

  if (spells) {
    lines.push('', `## Spell Activity Near Level ${level} (${lo}-${hi})`, '');
    const levelCounts = new Map<number, number>();
    for (let l = lo; l <= hi; l++) levelCounts.set(l, 0);

    for (const spell of spells.values()) {
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
      for (let cid = 1; cid <= 16; cid++) {
        const sl = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
        if (sl >= lo && sl <= hi) {
          levelCounts.set(sl, (levelCounts.get(sl) || 0) + 1);
        }
      }
    }

    for (let l = lo; l <= hi; l++) {
      const count = levelCounts.get(l) || 0;
      const marker = l === level ? ' <<<' : '';
      const bar = '#'.repeat(Math.min(Math.round(count / 5), 40));
      lines.push(`- **Level ${l}:** ${count} spells ${bar}${marker}`);
    }
  }

  return lines.join('\n');
}

// ============ SPELL SCALING ANALYSIS ============

export async function getSpellScalingAnalysis(spellName: string): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Find all spells matching the base name pattern (strip rank suffixes)
  const baseName = spellName.replace(/\s+(Rk\.\s*(II|III|IV|V|VI|VII|VIII|IX|X))\s*$/i, '').trim();
  const matches: { id: number; name: string; level: number; classId: number; mana: number; endurance: number; castTime: number; recast: number; duration: string; effects: { spaId: number; name: string; base1: number }[]; beneficial: boolean }[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const spellNameLower = spell.name.toLowerCase();
    const baseNameLower = baseName.toLowerCase();
    if (!spellNameLower.startsWith(baseNameLower)) continue;

    // The rest should be empty or a rank suffix
    const suffix = spell.name.substring(baseName.length).trim();
    if (suffix && !/^(Rk\.\s*(II|III|IV|V|VI|VII|VIII|IX|X)|I{1,3}|IV|V|VI|VII|VIII|IX|X|\d+)$/i.test(suffix)) continue;

    // Find the lowest class level
    let minLevel = 255;
    let minClassId = 0;
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < minLevel) { minLevel = level; minClassId = i; }
    }

    const mana = parseInt(spell.fields[SF.MANA]) || 0;
    const endurance = parseInt(spell.fields[SF.ENDURANCE]) || 0;
    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    const recast = parseInt(spell.fields[SF.RECAST_TIME]) || 0;
    const durFormula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const durValue = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    const duration = `F${durFormula}:${durValue}`;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    // Parse effects
    const effects: { spaId: number; name: string; base1: number }[] = [];
    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
    }
    if (effectField) {
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          const base1 = parseInt(parts[2]) || 0;
          if (!isNaN(spaId) && spaId > 0) {
            effects.push({ spaId, name: SPA_NAMES[spaId] || `SPA ${spaId}`, base1 });
          }
        }
      }
    }

    matches.push({
      id: spell.id, name: spell.name, level: minLevel < 255 ? minLevel : 0,
      classId: minClassId, mana, endurance, castTime, recast, duration,
      effects, beneficial
    });
  }

  if (matches.length === 0) return `No spells found matching "${spellName}".`;

  matches.sort((a, b) => a.level - b.level || a.name.localeCompare(b.name));

  const lines = [`# Spell Scaling: ${baseName}`, ''];
  lines.push(`*${matches.length} versions found — how the spell scales across levels.*`, '');

  // Overview table
  lines.push('## Version Overview', '');
  lines.push('| Spell Name | Level | Mana | Cast | Recast | Duration |');
  lines.push('|-----------|------:|-----:|-----:|-------:|----------|');
  for (const m of matches) {
    const castStr = (m.castTime / 1000).toFixed(1) + 's';
    const recastStr = m.recast > 0 ? (m.recast / 1000).toFixed(0) + 's' : '-';
    const costStr = m.mana > 0 ? m.mana.toString() : m.endurance > 0 ? `${m.endurance}e` : '0';
    lines.push(`| ${m.name} | ${m.level || '-'} | ${costStr} | ${castStr} | ${recastStr} | ${m.duration} |`);
  }

  // Effect scaling
  if (matches.length > 1 && matches[0].effects.length > 0) {
    lines.push('', '## Effect Value Scaling', '');

    const allSpas = new Set<number>();
    for (const m of matches) {
      for (const e of m.effects) allSpas.add(e.spaId);
    }

    for (const spaId of allSpas) {
      const spaName = SPA_NAMES[spaId] || `SPA ${spaId}`;
      const values = matches.map(m => {
        const eff = m.effects.find(e => e.spaId === spaId);
        return { level: m.level, name: m.name, base1: eff ? eff.base1 : null };
      }).filter(v => v.base1 !== null);

      if (values.length >= 2) {
        const first = values[0].base1!;
        const last = values[values.length - 1].base1!;
        const growth = first !== 0 ? (((last - first) / Math.abs(first)) * 100).toFixed(0) : 'N/A';
        lines.push(`### ${spaName} (SPA ${spaId}) — Growth: ${growth}%`);
        for (const v of values) {
          lines.push(`- Level ${v.level}: ${v.base1}`);
        }
        lines.push('');
      }
    }
  }

  // Mana cost growth
  const manaValues = matches.filter(m => m.mana > 0);
  if (manaValues.length >= 2) {
    lines.push('## Mana Cost Growth', '');
    for (const m of manaValues) {
      const bar = '#'.repeat(Math.min(Math.round(m.mana / 100), 40));
      lines.push(`- **${m.name}** (Lvl ${m.level}): ${m.mana} ${bar}`);
    }
  }

  return lines.join('\n');
}

// ============ RACE-DEITY OPTIMIZER ============

export async function getRaceDeityOptimizer(): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Race-Deity Faction Optimizer', ''];
  lines.push('*For each playable race, ranks deities by net faction benefit.*', '');

  // Get unique deities
  const deities: { name: string; modId: number }[] = [];
  const seenIds = new Set<number>();
  for (const [name, modId] of Object.entries(DEITY_TO_FACTION_MODIFIER)) {
    if (seenIds.has(modId)) continue;
    seenIds.add(modId);
    const capName = name.split(/[\s-]+/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    deities.push({ name: capName, modId });
  }

  // Map race modifier IDs to race names
  const raceModMap: { modId: number; name: string }[] = [
    { modId: 51, name: 'Human' }, { modId: 52, name: 'Barbarian' },
    { modId: 53, name: 'Erudite' }, { modId: 54, name: 'Wood Elf' },
    { modId: 55, name: 'High Elf' }, { modId: 56, name: 'Dark Elf' },
    { modId: 57, name: 'Half Elf' }, { modId: 58, name: 'Dwarf' },
    { modId: 59, name: 'Troll' }, { modId: 60, name: 'Ogre' },
    { modId: 61, name: 'Halfling' }, { modId: 62, name: 'Gnome' },
    { modId: 178, name: 'Iksar' }, { modId: 180, name: 'Vah Shir' },
    { modId: 661, name: 'Froglok' }, { modId: 1106, name: 'Drakkin' }
  ];

  // For each race-deity combo, calculate net faction impact
  lines.push('## Best Deity by Race', '');
  lines.push('| Race | Best Deity | Net | 2nd Best | Net | Worst Deity | Net |');
  lines.push('|------|-----------|----:|----------|----:|------------|----:|');

  for (const race of raceModMap) {
    const deityScores: { name: string; net: number }[] = [];

    for (const deity of deities) {
      let netValue = 0;
      for (const faction of factions.values()) {
        if (!faction.startingValues) continue;
        for (const sv of faction.startingValues) {
          if (sv.modifierId === race.modId || sv.modifierId === deity.modId) {
            netValue += sv.value;
          }
        }
      }
      deityScores.push({ name: deity.name, net: netValue });
    }

    deityScores.sort((a, b) => b.net - a.net);
    const best = deityScores[0];
    const second = deityScores[1];
    const worst = deityScores[deityScores.length - 1];

    lines.push(`| ${race.name} | ${best.name} | ${best.net > 0 ? '+' : ''}${best.net.toLocaleString()} | ${second.name} | ${second.net > 0 ? '+' : ''}${second.net.toLocaleString()} | ${worst.name} | ${worst.net.toLocaleString()} |`);
  }

  // Overall deity rankings
  lines.push('', '## Overall Deity Rankings (Avg Net Across All Races)', '');
  const deityAvgs: { name: string; avgNet: number }[] = [];
  for (const deity of deities) {
    let totalNet = 0;
    for (const race of raceModMap) {
      let netValue = 0;
      for (const faction of factions.values()) {
        if (!faction.startingValues) continue;
        for (const sv of faction.startingValues) {
          if (sv.modifierId === race.modId || sv.modifierId === deity.modId) {
            netValue += sv.value;
          }
        }
      }
      totalNet += netValue;
    }
    deityAvgs.push({ name: deity.name, avgNet: Math.round(totalNet / raceModMap.length) });
  }

  deityAvgs.sort((a, b) => b.avgNet - a.avgNet);
  lines.push('| Rank | Deity | Avg Net Faction |');
  lines.push('|-----:|-------|----------------:|');
  for (let i = 0; i < deityAvgs.length; i++) {
    lines.push(`| ${i + 1} | ${deityAvgs[i].name} | ${deityAvgs[i].avgNet > 0 ? '+' : ''}${deityAvgs[i].avgNet.toLocaleString()} |`);
  }

  return lines.join('\n');
}

// ============ CLASS COMPARISON RADAR ============

export async function getClassComparisonRadar(): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Comparison Radar', ''];
  lines.push('*All 16 classes compared across 8 dimensions — normalized scores (0-100).*', '');

  const HEAL_SPAS = new Set([0, 147]);
  const TANK_SPAS = new Set([1, 55, 69, 162, 172]);
  const NUKE_SPAS = new Set([0, 79, 85, 119, 374, 413]);
  const CC_SPAS = new Set([21, 22, 23, 31, 74]);
  const UTIL_SPAS = new Set([3, 26, 57, 59, 106, 123]);
  const PET_SPAS = new Set([33, 131, 167, 168]);
  const MOBILITY_SPAS = new Set([3, 26, 57]);

  interface ClassScores {
    classId: number;
    name: string;
    short: string;
    healing: number;
    tanking: number;
    nuking: number;
    crowdControl: number;
    utility: number;
    buffing: number;
    pets: number;
    mobility: number;
  }

  const dimensions = ['healing', 'tanking', 'nuking', 'crowdControl', 'utility', 'buffing', 'pets', 'mobility'] as const;
  const rawScores: ClassScores[] = [];

  for (let cid = 1; cid <= 16; cid++) {
    let healing = 0, tanking = 0, nuking = 0, crowdControl = 0;
    let utility = 0, buffing = 0, pets = 0, mobility = 0;

    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      const isBeneficial = spell.fields[SF.BENEFICIAL] === '1';
      if (isBeneficial) buffing++;

      let effectField = '';
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
      }
      if (!effectField) continue;

      const spas = new Set<number>();
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          if (!isNaN(spaId) && spaId > 0) spas.add(spaId);
        }
      }

      for (const spa of spas) {
        if (HEAL_SPAS.has(spa) && isBeneficial) healing++;
        if (TANK_SPAS.has(spa)) tanking++;
        if (NUKE_SPAS.has(spa) && !isBeneficial) nuking++;
        if (CC_SPAS.has(spa)) crowdControl++;
        if (UTIL_SPAS.has(spa)) utility++;
        if (PET_SPAS.has(spa)) pets++;
        if (MOBILITY_SPAS.has(spa)) mobility++;
      }
    }

    rawScores.push({
      classId: cid, name: CLASS_IDS[cid], short: CLASS_SHORT[cid],
      healing, tanking, nuking, crowdControl, utility, buffing, pets, mobility
    });
  }

  // Normalize to 0-100
  const maxValues: Record<string, number> = {};
  for (const dim of dimensions) {
    maxValues[dim] = Math.max(...rawScores.map(s => s[dim]));
  }

  lines.push('## Normalized Scores (0-100)', '');
  lines.push('| Class | Heal | Tank | Nuke | CC | Utility | Buff | Pets | Mobility | Total |');
  lines.push('|-------|-----:|-----:|-----:|---:|--------:|-----:|-----:|---------:|------:|');

  for (const s of rawScores) {
    const norm = dimensions.map(d => maxValues[d] > 0 ? Math.round((s[d] / maxValues[d]) * 100) : 0);
    const total = norm.reduce((sum, v) => sum + v, 0);
    lines.push(`| ${s.name} (${s.short}) | ${norm.join(' | ')} | ${total} |`);
  }

  // Top class per dimension
  lines.push('', '## Top Class Per Dimension', '');
  for (const dim of dimensions) {
    const sorted = [...rawScores].sort((a, b) => b[dim] - a[dim]);
    const top3 = sorted.slice(0, 3).map(s => `${s.short} (${s[dim]})`).join(', ');
    const dimLabel = dim.charAt(0).toUpperCase() + dim.slice(1).replace(/([A-Z])/g, ' $1');
    lines.push(`- **${dimLabel}:** ${top3}`);
  }

  // Archetype summary
  lines.push('', '## Archetype Summary', '');
  for (const s of rawScores) {
    const norm: Record<string, number> = {};
    for (const d of dimensions) {
      norm[d] = maxValues[d] > 0 ? Math.round((s[d] / maxValues[d]) * 100) : 0;
    }
    const topDims = dimensions
      .map(d => ({ dim: d, score: norm[d] }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 3)
      .filter(d => d.score > 20)
      .map(d => d.dim.replace(/([A-Z])/g, ' $1').toLowerCase());
    lines.push(`- **${s.name} (${s.short}):** ${topDims.join(', ')}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: EXPANSION IMPACT SCORE ============

export async function getExpansionImpactScore(): Promise<string> {
  await loadExpansions();
  await loadFactions();
  await loadAchievements();
  await loadAchievementCategories();
  await loadGameEvents();
  await loadZones();
  if (!expansionNames || expansionNames.size === 0) return 'Expansion data not available.';

  const lines = ['# Expansion Impact Score', ''];
  lines.push('*Each expansion scored by content volume across factions, achievements, and events.*', '');

  interface ExpScore {
    id: number;
    name: string;
    factionCount: number;
    achievementCount: number;
    achievementPoints: number;
    eventMentions: number;
    totalScore: number;
  }

  const scores: ExpScore[] = [];

  for (const [expId, expName] of expansionNames) {
    // Count factions matching expansion category
    let factionCount = 0;
    if (factions) {
      const expLower = expName.toLowerCase();
      for (const f of factions.values()) {
        if (f.category && f.category.toLowerCase() === expLower) factionCount++;
      }
    }

    // Count achievements in categories matching expansion name
    let achievementCount = 0;
    let achievementPoints = 0;
    if (achievementCategories && achievements && categoryToAchievements) {
      for (const [catId, cat] of achievementCategories) {
        if (cat.name.toLowerCase().includes(expName.toLowerCase()) ||
            expName.toLowerCase().includes(cat.name.toLowerCase())) {
          const achIds = categoryToAchievements.get(catId) || [];
          achievementCount += achIds.length;
          for (const aId of achIds) {
            const ach = achievements.get(aId);
            if (ach) achievementPoints += ach.points;
          }
        }
      }
    }

    // Count event mentions
    let eventMentions = 0;
    if (gameEvents) {
      const expLower = expName.toLowerCase();
      for (const evt of gameEvents.values()) {
        const text = (evt.banner + ' ' + evt.description).toLowerCase();
        if (text.includes(expLower)) eventMentions++;
      }
    }

    // Composite score (weighted)
    const totalScore = factionCount * 3 + achievementCount * 1 + achievementPoints + eventMentions * 5;

    scores.push({ id: expId, name: expName, factionCount, achievementCount, achievementPoints, eventMentions, totalScore });
  }

  // Sort by total score descending
  scores.sort((a, b) => b.totalScore - a.totalScore);

  lines.push('## Impact Rankings', '');
  lines.push('| Rank | Expansion | Factions | Achievements | Ach Points | Events | Score |');
  lines.push('|-----:|-----------|--------:|-----------:|-----------:|------:|------:|');
  let rank = 1;
  for (const s of scores) {
    if (s.totalScore > 0) {
      lines.push(`| ${rank++} | ${s.name} | ${s.factionCount} | ${s.achievementCount} | ${s.achievementPoints} | ${s.eventMentions} | ${s.totalScore} |`);
    }
  }

  // Expansions with zero score
  const zeroScore = scores.filter(s => s.totalScore === 0);
  if (zeroScore.length > 0) {
    lines.push('', `*${zeroScore.length} expansions have no linked content in local data:*`);
    lines.push(zeroScore.map(s => `${s.id}. ${s.name}`).join(', '));
  }

  // Aggregate stats
  const totalFactions = scores.reduce((s, e) => s + e.factionCount, 0);
  const totalAch = scores.reduce((s, e) => s + e.achievementCount, 0);
  const totalPts = scores.reduce((s, e) => s + e.achievementPoints, 0);
  const totalEvts = scores.reduce((s, e) => s + e.eventMentions, 0);

  lines.push('', '## Aggregate Totals', '');
  lines.push(`- **Factions linked to expansions:** ${totalFactions}`);
  lines.push(`- **Achievements linked to expansions:** ${totalAch}`);
  lines.push(`- **Total achievement points:** ${totalPts}`);
  lines.push(`- **Event mentions:** ${totalEvts}`);

  // Content density per expansion
  const withContent = scores.filter(s => s.totalScore > 0);
  if (withContent.length > 0) {
    const avgScore = Math.round(withContent.reduce((s, e) => s + e.totalScore, 0) / withContent.length);
    lines.push(`- **Average impact score (expansions with content):** ${avgScore}`);
    lines.push(`- **Above-average expansions:** ${withContent.filter(s => s.totalScore > avgScore).length}`);
  }

  // Top content categories
  lines.push('', '## Content Category Leaders', '');
  const byFactions = [...scores].sort((a, b) => b.factionCount - a.factionCount).slice(0, 3);
  const byAch = [...scores].sort((a, b) => b.achievementCount - a.achievementCount).slice(0, 3);
  const byPts = [...scores].sort((a, b) => b.achievementPoints - a.achievementPoints).slice(0, 3);
  lines.push(`- **Most factions:** ${byFactions.map(s => `${s.name} (${s.factionCount})`).join(', ')}`);
  lines.push(`- **Most achievements:** ${byAch.map(s => `${s.name} (${s.achievementCount})`).join(', ')}`);
  lines.push(`- **Most achievement points:** ${byPts.map(s => `${s.name} (${s.achievementPoints})`).join(', ')}`);

  return lines.join('\n');
}

// ============ PUBLIC API: GROUP COMPOSITION ADVISOR ============

export async function getGroupCompositionAdvisor(): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Group Composition Advisor', ''];
  lines.push('*Optimal 6-person group compositions based on class role synergy and spell coverage.*', '');

  // Build role scores per class (same logic as class role analysis)
  const HEAL_SPAS = new Set([0, 147]);
  const TANK_SPAS = new Set([1, 55, 69, 162, 172]);
  const DPS_SPAS = new Set([0, 79, 85, 119, 330, 374, 413]);
  const CC_SPAS = new Set([21, 22, 23, 31, 74]);
  const BUFF_SPAS = new Set([2, 3, 4, 5, 11, 15, 21, 35, 36, 55, 69, 100, 127, 170, 192, 264, 294]);
  const UTILITY_SPAS = new Set([3, 26, 57, 59, 106, 123]);

  interface ClassProfile {
    classId: number;
    name: string;
    short: string;
    heal: number;
    tank: number;
    dps: number;
    cc: number;
    buff: number;
    utility: number;
    totalSpells: number;
    hp: number;
    mana: number;
  }

  const profiles: ClassProfile[] = [];

  for (let cid = 1; cid <= 16; cid++) {
    let heal = 0, tank = 0, dps = 0, cc = 0, buff = 0, utility = 0;
    let totalSpells = 0;

    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      totalSpells++;

      let effectField = '';
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
      }
      if (!effectField) continue;

      const isBeneficial = spell.fields[SF.BENEFICIAL] === '1';
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          if (isNaN(spaId) || spaId <= 0) continue;
          if (HEAL_SPAS.has(spaId) && isBeneficial) heal++;
          if (TANK_SPAS.has(spaId)) tank++;
          if (DPS_SPAS.has(spaId) && !isBeneficial) dps++;
          if (CC_SPAS.has(spaId)) cc++;
          if (BUFF_SPAS.has(spaId) && isBeneficial) buff++;
          if (UTILITY_SPAS.has(spaId)) utility++;
        }
      }
    }

    let hp = 0, mana = 0;
    if (baseStats) {
      const stat = baseStats.find(s => s.classId === cid && s.level === 100);
      if (stat) { hp = stat.hp; mana = stat.mana; }
    }

    profiles.push({
      classId: cid, name: CLASS_IDS[cid], short: CLASS_SHORT[cid],
      heal, tank, dps, cc, buff, utility, totalSpells, hp, mana
    });
  }

  // Normalize scores
  const dims: (keyof ClassProfile)[] = ['heal', 'tank', 'dps', 'cc', 'buff', 'utility'];
  const maxVals: Record<string, number> = {};
  for (const d of dims) {
    maxVals[d] = Math.max(...profiles.map(p => p[d] as number));
  }
  const normProfiles = profiles.map(p => {
    const norm: Record<string, number> = {};
    for (const d of dims) {
      norm[d] = maxVals[d] > 0 ? Math.round(((p[d] as number) / maxVals[d]) * 100) : 0;
    }
    return { ...p, norm };
  });

  // Classify each class
  for (const p of normProfiles) {
    const n = p.norm;
    let role = 'DPS';
    if (n.heal > 50 && n.heal >= n.dps) role = 'Healer';
    else if (n.tank > 50 && n.tank >= n.dps) role = 'Tank';
    else if (n.cc > 40 && n.cc >= n.dps) role = 'CC/Support';
    (p as any).role = role;
  }

  // Define group templates
  const templates = [
    { name: 'Classic Holy Trinity', desc: 'Tank + Healer + CC + 3 DPS', slots: ['Tank', 'Healer', 'CC/Support', 'DPS', 'DPS', 'DPS'] },
    { name: 'Max DPS Rush', desc: 'Tank + Healer + 4 DPS', slots: ['Tank', 'Healer', 'DPS', 'DPS', 'DPS', 'DPS'] },
    { name: 'Survival Focus', desc: 'Tank + 2 Healers + CC + 2 DPS', slots: ['Tank', 'Healer', 'Healer', 'CC/Support', 'DPS', 'DPS'] },
    { name: 'Balanced', desc: 'Tank + Healer + CC + Buff + 2 DPS', slots: ['Tank', 'Healer', 'CC/Support', 'DPS', 'DPS', 'DPS'] },
  ];

  // Find best class for each role
  const bestByRole = (role: string, exclude: Set<number> = new Set()): typeof normProfiles[0] | null => {
    const candidates = normProfiles
      .filter(p => !exclude.has(p.classId))
      .sort((a, b) => {
        const scoreA = a.norm[role.toLowerCase()] || (a as any).norm?.dps || 0;
        const scoreB = b.norm[role.toLowerCase()] || (b as any).norm?.dps || 0;
        return scoreB - scoreA;
      });
    return candidates[0] || null;
  };

  const roleToKey: Record<string, string> = {
    'Tank': 'tank', 'Healer': 'heal', 'CC/Support': 'cc', 'DPS': 'dps'
  };

  for (const template of templates) {
    lines.push(`## ${template.name}`, '');
    lines.push(`*${template.desc}*`, '');

    const used = new Set<number>();
    const picks: { role: string; p: typeof normProfiles[0] }[] = [];

    for (const slot of template.slots) {
      const key = roleToKey[slot] || 'dps';
      const candidates = normProfiles
        .filter(p => !used.has(p.classId))
        .sort((a, b) => (b.norm[key] || 0) - (a.norm[key] || 0));
      if (candidates.length > 0) {
        picks.push({ role: slot, p: candidates[0] });
        used.add(candidates[0].classId);
      }
    }

    lines.push('| Slot | Role | Class | Score | Spells |');
    lines.push('|-----:|------|-------|------:|-------:|');
    for (let i = 0; i < picks.length; i++) {
      const { role, p } = picks[i];
      const key = roleToKey[role] || 'dps';
      lines.push(`| ${i + 1} | ${role} | ${p.name} (${p.short}) | ${p.norm[key]} | ${p.totalSpells} |`);
    }
    lines.push('');
  }

  // Class role summary table
  lines.push('## Class Role Scores (Normalized 0-100)', '');
  lines.push('| Class | Heal | Tank | DPS | CC | Buff | Utility | Primary |');
  lines.push('|-------|-----:|-----:|----:|---:|-----:|--------:|---------|');
  for (const p of normProfiles) {
    const n = p.norm;
    lines.push(`| ${p.short} | ${n.heal} | ${n.tank} | ${n.dps} | ${n.cc} | ${n.buff} | ${n.utility} | ${(p as any).role} |`);
  }

  // Synergy notes
  lines.push('', '## Class Synergy Notes', '');
  lines.push('- **Enchanter + Melee DPS:** Enchanter haste/slow complements Rogue, Berserker, Monk burst DPS');
  lines.push('- **Shaman + Melee group:** Slows, buffs, DoTs complement melee-heavy groups');
  lines.push('- **Bard + Any group:** ADPS (bard song stacking), pulling, CC — universal enhancer');
  lines.push('- **Druid + Wizard:** Both teleport, druid heals allow wizard to focus on DPS');
  lines.push('- **Cleric + Warrior:** Strongest single-target heal + highest tank mitigation');
  lines.push('- **Necromancer + Shadowknight:** Both use lifetap/dark magic, shared faction concerns');

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS ENDGAME PROFILE ============

export async function getClassEndgameProfile(className: string): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  await loadSkillCaps();
  await loadACMitigation();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class
  const cn = className.toUpperCase().trim();
  let classId = 0;
  const shortEntry = Object.entries(CLASS_SHORT).find(([, short]) => short === cn);
  if (shortEntry) {
    classId = parseInt(shortEntry[0]);
  } else {
    const fullEntry = Object.entries(CLASS_IDS).find(([, name]) =>
      name.toLowerCase() === className.toLowerCase().trim()
    );
    if (fullEntry) classId = parseInt(fullEntry[0]);
  }

  if (!classId || !CLASS_IDS[classId]) {
    return `Unknown class: "${className}". Use short codes (WAR, CLR, PAL, RNG, SHD, DRU, MNK, BRD, ROG, SHM, NEC, WIZ, MAG, ENC, BST, BER) or full names.`;
  }

  const fullName = CLASS_IDS[classId];
  const short = CLASS_SHORT[classId];
  const MAX_LEVEL = 125;

  const lines = [`# ${fullName} (${short}) — Endgame Profile (Level ${MAX_LEVEL})`, ''];

  // Base stats at max level
  lines.push('## Base Stats at Level 125', '');
  if (baseStats) {
    const stat = baseStats.find(s => s.classId === classId && s.level === MAX_LEVEL);
    if (stat) {
      lines.push(`| Stat | Value |`);
      lines.push(`|------|------:|`);
      lines.push(`| HP | ${stat.hp.toLocaleString()} |`);
      lines.push(`| Mana | ${stat.mana.toLocaleString()} |`);
      lines.push(`| Endurance | ${stat.endurance.toLocaleString()} |`);
      lines.push(`| HP Regen | ${stat.hpRegen} |`);
      lines.push(`| Mana Regen | ${stat.manaRegen} |`);
      lines.push(`| End Regen | ${stat.enduranceRegen} |`);
    } else {
      lines.push('*No base stat data at level 125.*');
    }
  }

  // AC mitigation
  if (acMitigation) {
    const ac = acMitigation.find(a => a.classId === classId && a.level === MAX_LEVEL);
    if (ac) {
      lines.push('', `**AC Soft Cap:** ${ac.acCap} | **Multiplier:** ${ac.softCapMultiplier}`);
    }
  }

  // Skill caps at max level
  lines.push('', '## Skill Caps at Level 125', '');
  if (skillCaps) {
    const caps = skillCaps.filter(s => s.classId === classId && s.level === MAX_LEVEL && s.cap > 0);
    if (caps.length > 0) {
      caps.sort((a, b) => b.cap - a.cap);
      lines.push('| Skill | Cap |');
      lines.push('|-------|----:|');
      for (const c of caps) {
        const name = SKILL_NAMES[c.skillId] || `Skill ${c.skillId}`;
        lines.push(`| ${name} | ${c.cap} |`);
      }
      lines.push(``, `*${caps.length} skills available*`);
    } else {
      lines.push('*No skill data at level 125.*');
    }
  }

  // Spell analysis
  lines.push('', '## Spell Book Summary', '');
  let totalSpells = 0, beneficial = 0, detrimental = 0;
  const categoryMap = new Map<string, { count: number; ben: number; det: number }>();
  const levelBuckets = new Map<string, number>();
  const effectSet = new Set<number>();
  let maxSpellLevel = 0;

  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (level < 1 || level > 254) continue;
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    totalSpells++;
    if (level <= 125 && level > maxSpellLevel) maxSpellLevel = level;
    const isBen = spell.fields[SF.BENEFICIAL] === '1';
    if (isBen) beneficial++; else detrimental++;

    // Category
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Category ${catId}`);
    const entry = categoryMap.get(catName) || { count: 0, ben: 0, det: 0 };
    entry.count++;
    if (isBen) entry.ben++; else entry.det++;
    categoryMap.set(catName, entry);

    // Level bucket
    const bracket = level <= 60 ? '1-60' : level <= 70 ? '61-70' : level <= 80 ? '71-80' :
      level <= 90 ? '81-90' : level <= 100 ? '91-100' : level <= 110 ? '101-110' : '111-125';
    levelBuckets.set(bracket, (levelBuckets.get(bracket) || 0) + 1);

    // Track unique SPAs
    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
    }
    if (effectField) {
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          if (!isNaN(spaId) && spaId > 0) effectSet.add(spaId);
        }
      }
    }
  }

  lines.push(`- **Total spells:** ${totalSpells}`);
  lines.push(`- **Beneficial:** ${beneficial} (${totalSpells > 0 ? Math.round(beneficial / totalSpells * 100) : 0}%)`);
  lines.push(`- **Detrimental:** ${detrimental} (${totalSpells > 0 ? Math.round(detrimental / totalSpells * 100) : 0}%)`);
  lines.push(`- **Unique spell effects (SPAs):** ${effectSet.size}`);
  lines.push(`- **Max spell level:** ${maxSpellLevel}`);

  // Level distribution
  lines.push('', '### Spells by Level Bracket', '');
  const brackets = ['1-60', '61-70', '71-80', '81-90', '91-100', '101-110', '111-125'];
  for (const b of brackets) {
    const count = levelBuckets.get(b) || 0;
    const bar = '#'.repeat(Math.min(Math.round(count / 5), 40));
    lines.push(`- **${b}:** ${count} ${bar}`);
  }

  // Top categories
  lines.push('', '### Top Spell Categories', '');
  const sortedCats = [...categoryMap.entries()].sort((a, b) => b[1].count - a[1].count).slice(0, 15);
  lines.push('| Category | Count | Beneficial | Detrimental |');
  lines.push('|----------|------:|-----------:|------------:|');
  for (const [cat, data] of sortedCats) {
    lines.push(`| ${cat} | ${data.count} | ${data.ben} | ${data.det} |`);
  }

  // Role score (quick version)
  lines.push('', '## Role Assessment', '');
  const HEAL_SPAS = new Set([0, 147]);
  const TANK_SPAS = new Set([1, 55, 69, 162, 172]);
  const DPS_SPAS = new Set([0, 79, 85, 119, 330, 374, 413]);
  const CC_SPAS = new Set([21, 22, 23, 31, 74]);
  const UTILITY_SPAS_LOCAL = new Set([3, 26, 57, 59, 106, 123]);

  let healScore = 0, tankScore = 0, dpsScore = 0, ccScore = 0, utilityScore = 0;
  for (const spell of spells.values()) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (level < 1 || level > 254) continue;
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
    }
    if (!effectField) continue;

    const isBen = spell.fields[SF.BENEFICIAL] === '1';
    for (const slot of effectField.split('$')) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spaId = parseInt(parts[1]);
        if (isNaN(spaId) || spaId <= 0) continue;
        if (HEAL_SPAS.has(spaId) && isBen) healScore++;
        if (TANK_SPAS.has(spaId)) tankScore++;
        if (DPS_SPAS.has(spaId) && !isBen) dpsScore++;
        if (CC_SPAS.has(spaId)) ccScore++;
        if (UTILITY_SPAS_LOCAL.has(spaId)) utilityScore++;
      }
    }
  }

  const maxRole = Math.max(healScore, tankScore, dpsScore, ccScore, utilityScore, 1);
  const roles = [
    { name: 'Healing', score: healScore },
    { name: 'Tanking', score: tankScore },
    { name: 'DPS', score: dpsScore },
    { name: 'Crowd Control', score: ccScore },
    { name: 'Utility', score: utilityScore },
  ];
  roles.sort((a, b) => b.score - a.score);

  for (const r of roles) {
    const pct = Math.round((r.score / maxRole) * 100);
    const bar = '█'.repeat(Math.round(pct / 5));
    lines.push(`- **${r.name}:** ${bar} ${pct}% (${r.score} effects)`);
  }

  const primaryRole = roles[0].name;
  const secondaryRole = roles[1].score > 0 ? roles[1].name : 'None';
  lines.push('', `**Primary role:** ${primaryRole} | **Secondary:** ${secondaryRole}`);

  // Endgame resource type
  lines.push('', '## Resource Profile', '');
  if (baseStats) {
    const stat = baseStats.find(s => s.classId === classId && s.level === MAX_LEVEL);
    if (stat) {
      const hasMana = stat.mana > 0;
      const hasEnd = stat.endurance > 0;
      if (hasMana && hasEnd) lines.push(`*Hybrid resource class — uses both mana (${stat.mana.toLocaleString()}) and endurance (${stat.endurance.toLocaleString()}).*`);
      else if (hasMana) lines.push(`*Pure caster — mana-dependent (${stat.mana.toLocaleString()} mana pool).*`);
      else if (hasEnd) lines.push(`*Pure melee — endurance-dependent (${stat.endurance.toLocaleString()} endurance pool).*`);
      else lines.push('*Minimal resource dependency.*');
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL EFFECT RARITY INDEX ============

export async function getSpellEffectRarityIndex(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Effect Rarity Index', ''];
  lines.push('*Which spell effects are rare vs common per class — identifies what makes each class irreplaceable.*', '');

  // Count SPA occurrences per class
  const classSPAs: Map<number, Map<number, number>> = new Map(); // classId -> spaId -> count
  const globalSPAs: Map<number, Set<number>> = new Map(); // spaId -> set of classIds that have it

  for (let cid = 1; cid <= 16; cid++) {
    classSPAs.set(cid, new Map());
  }

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    let effectField = '';
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
    }
    if (!effectField) continue;

    const spas = new Set<number>();
    for (const slot of effectField.split('$')) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spaId = parseInt(parts[1]);
        if (!isNaN(spaId) && spaId > 0) spas.add(spaId);
      }
    }

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;

      const classMap = classSPAs.get(cid)!;
      for (const spa of spas) {
        classMap.set(spa, (classMap.get(spa) || 0) + 1);
        if (!globalSPAs.has(spa)) globalSPAs.set(spa, new Set());
        globalSPAs.get(spa)!.add(cid);
      }
    }
  }

  // Find exclusive and rare effects per class
  lines.push('## Class-Exclusive Spell Effects', '');
  lines.push('*Effects available to only 1 class — these define the class\'s unique contribution.*', '');

  const exclusiveByClass = new Map<number, { spa: number; name: string; count: number }[]>();

  for (const [spaId, classes] of globalSPAs) {
    if (classes.size === 1) {
      const cid = [...classes][0];
      const count = classSPAs.get(cid)!.get(spaId) || 0;
      if (!exclusiveByClass.has(cid)) exclusiveByClass.set(cid, []);
      exclusiveByClass.get(cid)!.push({ spa: spaId, name: SPA_NAMES[spaId] || `SPA ${spaId}`, count });
    }
  }

  for (let cid = 1; cid <= 16; cid++) {
    const exclusives = exclusiveByClass.get(cid) || [];
    if (exclusives.length > 0) {
      exclusives.sort((a, b) => b.count - a.count);
      const topEffects = exclusives.slice(0, 5).map(e => `${e.name} (${e.count})`).join(', ');
      lines.push(`- **${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}):** ${exclusives.length} exclusive effects — ${topEffects}`);
    } else {
      lines.push(`- **${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}):** No exclusive effects`);
    }
  }

  // Rare effects (2-3 classes)
  lines.push('', '## Rare Effects (2-3 Classes Only)', '');
  lines.push('| Effect | Classes | Spells |');
  lines.push('|--------|---------|-------:|');

  const rareEffects: { spa: number; name: string; classes: string[]; total: number }[] = [];
  for (const [spaId, classes] of globalSPAs) {
    if (classes.size >= 2 && classes.size <= 3) {
      let total = 0;
      const classNames: string[] = [];
      for (const cid of classes) {
        classNames.push(CLASS_SHORT[cid]);
        total += classSPAs.get(cid)!.get(spaId) || 0;
      }
      rareEffects.push({ spa: spaId, name: SPA_NAMES[spaId] || `SPA ${spaId}`, classes: classNames, total });
    }
  }
  rareEffects.sort((a, b) => a.classes.length - b.classes.length || b.total - a.total);
  for (const e of rareEffects.slice(0, 30)) {
    lines.push(`| ${e.name} | ${e.classes.join(', ')} | ${e.total} |`);
  }

  // Universal effects (available to all 16 classes)
  const universalSPAs = [...globalSPAs.entries()].filter(([, c]) => c.size === 16);
  lines.push('', `## Universal Effects (All 16 Classes): ${universalSPAs.length}`, '');
  const universalNames = universalSPAs
    .map(([spaId]) => SPA_NAMES[spaId] || `SPA ${spaId}`)
    .sort()
    .slice(0, 20);
  lines.push(universalNames.join(', ') + (universalSPAs.length > 20 ? `, ... (+${universalSPAs.length - 20} more)` : ''));

  // Effect diversity ranking
  lines.push('', '## Effect Diversity Ranking', '');
  lines.push('| Class | Unique SPAs | Exclusive | Rare (≤3) |');
  lines.push('|-------|----------:|----------:|----------:|');
  const diversityData: { cid: number; total: number; exclusive: number; rare: number }[] = [];
  for (let cid = 1; cid <= 16; cid++) {
    const total = classSPAs.get(cid)!.size;
    const exclusive = (exclusiveByClass.get(cid) || []).length;
    const rare = [...globalSPAs.entries()].filter(([spaId, classes]) => classes.has(cid) && classes.size <= 3).length;
    diversityData.push({ cid, total, exclusive, rare });
  }
  diversityData.sort((a, b) => b.total - a.total);
  for (const d of diversityData) {
    lines.push(`| ${CLASS_IDS[d.cid]} (${CLASS_SHORT[d.cid]}) | ${d.total} | ${d.exclusive} | ${d.rare} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: MERCENARY CLASS SYNERGY ============

export async function getMercenaryClassSynergy(): Promise<string> {
  await loadSpells();
  await loadBaseStats();
  await loadMercenaries();
  if (!spells || spells.size === 0) return 'Spell data not available.';
  if (!mercenaries || mercenaries.size === 0) return 'Mercenary data not available.';

  const lines = ['# Mercenary-Class Synergy Guide', ''];
  lines.push('*Which mercenary type best complements each class based on role gaps.*', '');

  // Build role scores per class
  const HEAL_SPAS = new Set([0, 147]);
  const TANK_SPAS = new Set([1, 55, 69, 162, 172]);
  const DPS_SPAS_LOCAL = new Set([0, 79, 85, 119, 330, 374, 413]);
  const CC_SPAS = new Set([21, 22, 23, 31, 74]);

  interface ClassRole {
    classId: number;
    name: string;
    short: string;
    heal: number;
    tank: number;
    dps: number;
    cc: number;
    hp: number;
    mana: number;
  }

  const roles: ClassRole[] = [];

  for (let cid = 1; cid <= 16; cid++) {
    let heal = 0, tank = 0, dps = 0, cc = 0;

    for (const spell of spells.values()) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

      let effectField = '';
      for (let i = spell.fields.length - 1; i >= 0; i--) {
        if (spell.fields[i].includes('|')) { effectField = spell.fields[i]; break; }
      }
      if (!effectField) continue;

      const isBen = spell.fields[SF.BENEFICIAL] === '1';
      for (const slot of effectField.split('$')) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spaId = parseInt(parts[1]);
          if (isNaN(spaId) || spaId <= 0) continue;
          if (HEAL_SPAS.has(spaId) && isBen) heal++;
          if (TANK_SPAS.has(spaId)) tank++;
          if (DPS_SPAS_LOCAL.has(spaId) && !isBen) dps++;
          if (CC_SPAS.has(spaId)) cc++;
        }
      }
    }

    let hp = 0, mana = 0;
    if (baseStats) {
      const stat = baseStats.find(s => s.classId === cid && s.level === 100);
      if (stat) { hp = stat.hp; mana = stat.mana; }
    }

    roles.push({ classId: cid, name: CLASS_IDS[cid], short: CLASS_SHORT[cid], heal, tank, dps, cc, hp, mana });
  }

  // Normalize
  const maxHeal = Math.max(...roles.map(r => r.heal), 1);
  const maxTank = Math.max(...roles.map(r => r.tank), 1);
  const maxDps = Math.max(...roles.map(r => r.dps), 1);

  // Mercenary types available
  const mercTypes = new Map<string, number>();
  for (const m of mercenaries.values()) {
    mercTypes.set(m.type, (mercTypes.get(m.type) || 0) + 1);
  }

  lines.push('## Available Mercenary Types', '');
  lines.push('| Type | Templates |');
  lines.push('|------|----------:|');
  for (const [type, count] of [...mercTypes.entries()].sort((a, b) => b[1] - a[1])) {
    lines.push(`| ${type} | ${count} |`);
  }

  // Recommend merc type per class
  lines.push('', '## Recommended Mercenary by Class', '');
  lines.push('*Recommendation based on filling the class\'s weakest role.*', '');
  lines.push('| Class | Heal % | Tank % | DPS % | Weakness | Recommended Merc | Reasoning |');
  lines.push('|-------|-------:|-------:|------:|----------|-----------------|-----------|');

  for (const r of roles) {
    const healPct = Math.round((r.heal / maxHeal) * 100);
    const tankPct = Math.round((r.tank / maxTank) * 100);
    const dpsPct = Math.round((r.dps / maxDps) * 100);

    // Find weakest role
    let weakness = 'DPS';
    let recommended = 'Melee DPS';
    let reasoning = 'Augment damage output';

    const scores = [
      { role: 'Heal', pct: healPct },
      { role: 'Tank', pct: tankPct },
      { role: 'DPS', pct: dpsPct },
    ];
    scores.sort((a, b) => a.pct - b.pct);
    weakness = scores[0].role;

    if (weakness === 'Heal') {
      recommended = 'Healer';
      reasoning = 'Low healing capability — healer merc provides sustain';
    } else if (weakness === 'Tank') {
      recommended = 'Tank';
      reasoning = 'Low survivability — tank merc absorbs damage';
    } else {
      // If already balanced, recommend based on class type
      if (r.mana > 0 && r.hp < roles.reduce((s, x) => s + x.hp, 0) / roles.length) {
        recommended = 'Tank';
        reasoning = 'Caster class with low HP — tank merc provides protection';
      } else {
        recommended = 'Healer';
        reasoning = 'Strong DPS already — healer merc enables sustained combat';
      }
    }

    lines.push(`| ${r.name} (${r.short}) | ${healPct} | ${tankPct} | ${dpsPct} | ${weakness} | ${recommended} | ${reasoning} |`);
  }

  // Mercenary tiers
  lines.push('', '## Mercenary Tier Summary', '');
  const tierCounts = new Map<string, Map<string, number>>();
  for (const m of mercenaries.values()) {
    if (!tierCounts.has(m.type)) tierCounts.set(m.type, new Map());
    const tc = tierCounts.get(m.type)!;
    tc.set(m.tier, (tc.get(m.tier) || 0) + 1);
  }
  for (const [type, tiers] of [...tierCounts.entries()].sort()) {
    const tierList = [...tiers.entries()].sort((a, b) => b[1] - a[1]).map(([t, c]) => `${t}: ${c}`).join(', ');
    lines.push(`- **${type}:** ${tierList}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: OVERSEER QUEST EFFICIENCY ANALYSIS ============

export async function getOverseerQuestEfficiencyAnalysis(): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerMinions();
  await loadOverseerEnhancements();
  if (!overseerQuests || overseerQuests.size === 0) return 'Overseer quest data not available.';

  const lines = ['# Overseer Quest Efficiency Analysis', ''];
  lines.push('*Quest efficiency measured by difficulty-to-slot ratio and duration optimization.*', '');

  // Gather quest data
  interface QuestData {
    id: number;
    name: string;
    category: string;
    difficulty: number;
    duration: number;
    requiredSlots: number;
    optionalSlots: number;
    totalSlots: number;
    efficiencyScore: number; // difficulty per required slot
    uniqueJobs: number;
    bonusTraits: number;
  }

  const questData: QuestData[] = [];

  for (const quest of overseerQuests.values()) {
    const category = overseerCategories?.get(quest.categoryId) || `Category ${quest.categoryId}`;
    const totalSlots = quest.requiredSlots + quest.optionalSlots;
    const uniqueJobs = new Set(quest.slotDetails.map(s => s.jobTypeId)).size;
    const bonusTraits = quest.slotDetails.reduce((s, d) => s + d.bonusTraitIds.length, 0);
    const efficiencyScore = quest.requiredSlots > 0 ? quest.difficulty / quest.requiredSlots : 0;

    questData.push({
      id: quest.id,
      name: quest.name,
      category,
      difficulty: quest.difficulty,
      duration: quest.duration,
      requiredSlots: quest.requiredSlots,
      optionalSlots: quest.optionalSlots,
      totalSlots,
      efficiencyScore,
      uniqueJobs,
      bonusTraits
    });
  }

  // Category summary
  const categoryStats = new Map<string, { count: number; avgDiff: number; avgSlots: number; avgDuration: number; totalDiff: number; totalSlots: number; totalDuration: number }>();
  for (const q of questData) {
    const cat = categoryStats.get(q.category) || { count: 0, avgDiff: 0, avgSlots: 0, avgDuration: 0, totalDiff: 0, totalSlots: 0, totalDuration: 0 };
    cat.count++;
    cat.totalDiff += q.difficulty;
    cat.totalSlots += q.requiredSlots;
    cat.totalDuration += q.duration;
    categoryStats.set(q.category, cat);
  }

  lines.push('## Category Efficiency Overview', '');
  lines.push('| Category | Quests | Avg Difficulty | Avg Required Slots | Avg Duration (hrs) | Diff/Slot |');
  lines.push('|----------|-------:|---------------:|-------------------:|-------------------:|----------:|');
  for (const [cat, stats] of [...categoryStats.entries()].sort((a, b) => b[1].count - a[1].count)) {
    const avgDiff = (stats.totalDiff / stats.count).toFixed(1);
    const avgSlots = (stats.totalSlots / stats.count).toFixed(1);
    const avgDuration = (stats.totalDuration / stats.count / 3600).toFixed(1);
    const diffPerSlot = stats.totalSlots > 0 ? (stats.totalDiff / stats.totalSlots).toFixed(2) : '0';
    lines.push(`| ${cat} | ${stats.count} | ${avgDiff} | ${avgSlots} | ${avgDuration} | ${diffPerSlot} |`);
  }

  // Most efficient quests (highest difficulty per slot)
  const sorted = [...questData].sort((a, b) => b.efficiencyScore - a.efficiencyScore);
  lines.push('', '## Top 15 Most Efficient Quests (Highest Difficulty/Slot)', '');
  lines.push('| Quest | Category | Diff | Req Slots | Eff Score | Duration |');
  lines.push('|-------|----------|-----:|----------:|----------:|----------:|');
  for (const q of sorted.slice(0, 15)) {
    const durationHrs = (q.duration / 3600).toFixed(1);
    lines.push(`| ${q.name} | ${q.category} | ${q.difficulty} | ${q.requiredSlots} | ${q.efficiencyScore.toFixed(2)} | ${durationHrs}h |`);
  }

  // Least demanding quests (fewest required slots)
  const bySlots = [...questData].sort((a, b) => a.requiredSlots - b.requiredSlots || b.difficulty - a.difficulty);
  lines.push('', '## Least Demanding Quests (Fewest Required Slots)', '');
  lines.push('| Quest | Category | Diff | Req Slots | Optional | Duration |');
  lines.push('|-------|----------|-----:|----------:|---------:|----------:|');
  for (const q of bySlots.slice(0, 15)) {
    const durationHrs = (q.duration / 3600).toFixed(1);
    lines.push(`| ${q.name} | ${q.category} | ${q.difficulty} | ${q.requiredSlots} | ${q.optionalSlots} | ${durationHrs}h |`);
  }

  // Difficulty distribution
  lines.push('', '## Difficulty Distribution', '');
  const diffBuckets = new Map<number, number>();
  for (const q of questData) {
    diffBuckets.set(q.difficulty, (diffBuckets.get(q.difficulty) || 0) + 1);
  }
  for (const [diff, count] of [...diffBuckets.entries()].sort((a, b) => a[0] - b[0])) {
    const bar = '#'.repeat(Math.min(Math.round(count / 2), 40));
    lines.push(`- **Difficulty ${diff}:** ${count} quests ${bar}`);
  }

  // Job diversity
  lines.push('', '## Job Diversity per Quest', '');
  const jobBuckets = new Map<number, number>();
  for (const q of questData) {
    jobBuckets.set(q.uniqueJobs, (jobBuckets.get(q.uniqueJobs) || 0) + 1);
  }
  for (const [jobs, count] of [...jobBuckets.entries()].sort((a, b) => a[0] - b[0])) {
    lines.push(`- **${jobs} unique job type${jobs > 1 ? 's' : ''}:** ${count} quests`);
  }

  // Bonus trait stats
  const totalBonus = questData.reduce((s, q) => s + q.bonusTraits, 0);
  const questsWithBonus = questData.filter(q => q.bonusTraits > 0).length;
  lines.push('', '## Bonus Trait Statistics', '');
  lines.push(`- **Quests with bonus traits:** ${questsWithBonus} of ${questData.length} (${Math.round(questsWithBonus / questData.length * 100)}%)`);
  lines.push(`- **Total bonus trait slots:** ${totalBonus}`);
  if (questsWithBonus > 0) {
    lines.push(`- **Average bonus traits per quest (with bonuses):** ${(totalBonus / questsWithBonus).toFixed(1)}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: TRIBUTE ROLE ANALYSIS ============

export async function getTributeRoleAnalysis(): Promise<string> {
  await loadTributes();
  if (!tributes || tributes.size === 0) return 'Tribute data not available.';

  const lines = ['# Tribute Role Analysis', ''];
  lines.push('*Tributes classified by benefitting role based on keyword analysis.*', '');

  // Keyword → role mapping
  const roleKeywords: Record<string, string[]> = {
    'Tank': ['hit point', 'hp', 'armor', 'ac', 'avoidance', 'mitigation', 'shield', 'block', 'parry', 'riposte', 'defense', 'absorb', 'damage shield', 'aggro', 'hate'],
    'Healer': ['heal', 'mana', 'cure', 'resurrection', 'mana regen', 'beneficial', 'group heal'],
    'Melee DPS': ['attack', 'backstab', 'double attack', 'triple attack', 'flurry', 'melee', 'strikethrough', 'accuracy', 'damage bonus', 'combat effects', 'proc'],
    'Caster DPS': ['spell damage', 'nuke', 'critical', 'focus', 'spell haste', 'cast time', 'mana cost'],
    'Utility': ['resist', 'movement', 'run speed', 'haste', 'regeneration', 'regen', 'endurance', 'experience', 'exp'],
  };

  // Classify each tribute
  interface TributeRole {
    id: number;
    name: string;
    desc: string;
    isGuild: boolean;
    roles: string[];
    keywords: string[];
  }

  const classified: TributeRole[] = [];
  const roleCounts: Record<string, number> = {};
  const guildRoleCounts: Record<string, number> = {};

  for (const t of tributes.values()) {
    const text = (t.name + ' ' + t.description).toLowerCase();
    const roles: string[] = [];
    const keywords: string[] = [];

    for (const [role, kws] of Object.entries(roleKeywords)) {
      for (const kw of kws) {
        if (text.includes(kw)) {
          if (!roles.includes(role)) roles.push(role);
          keywords.push(kw);
        }
      }
    }

    if (roles.length === 0) roles.push('General');
    classified.push({ id: t.id, name: t.name, desc: t.description, isGuild: t.isGuild, roles, keywords });

    for (const r of roles) {
      roleCounts[r] = (roleCounts[r] || 0) + 1;
      if (t.isGuild) guildRoleCounts[r] = (guildRoleCounts[r] || 0) + 1;
    }
  }

  // Role distribution
  lines.push('## Tribute Role Distribution', '');
  lines.push('| Role | Personal | Guild | Total |');
  lines.push('|------|--------:|------:|------:|');
  const allRoles = [...new Set([...Object.keys(roleCounts)])].sort((a, b) => (roleCounts[b] || 0) - (roleCounts[a] || 0));
  for (const role of allRoles) {
    const total = roleCounts[role] || 0;
    const guild = guildRoleCounts[role] || 0;
    const personal = total - guild;
    lines.push(`| ${role} | ${personal} | ${guild} | ${total} |`);
  }

  // Top tributes per role
  for (const role of allRoles) {
    if (role === 'General') continue;
    const roleTributes = classified.filter(t => t.roles.includes(role)).slice(0, 10);
    lines.push('', `## Top ${role} Tributes`, '');
    lines.push('| Tribute | Type | Keywords |');
    lines.push('|---------|------|----------|');
    for (const t of roleTributes) {
      const type = t.isGuild ? 'Guild' : 'Personal';
      lines.push(`| ${t.name} | ${type} | ${[...new Set(t.keywords)].join(', ')} |`);
    }
  }

  // Unclassified tributes
  const general = classified.filter(t => t.roles.includes('General') && t.roles.length === 1);
  if (general.length > 0) {
    lines.push('', `## Unclassified Tributes (${general.length})`, '');
    for (const t of general.slice(0, 15)) {
      lines.push(`- **${t.name}** ${t.isGuild ? '(Guild)' : '(Personal)'}: ${t.desc.slice(0, 80)}${t.desc.length > 80 ? '...' : ''}`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: ITEM EFFECT SPELL CORRELATION ============

export async function getItemEffectSpellCorrelation(): Promise<string> {
  await loadItemEffects();
  await loadSpells();
  if (!itemEffectDescs || itemEffectDescs.size === 0) return 'Item effect data not available.';
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Item Effect-Spell Correlation', ''];
  lines.push('*Cross-reference item click/proc effects with spell names and effect keywords.*', '');

  // Build a set of spell names for matching
  const spellNameSet = new Map<string, number>(); // lowercase name -> spell count
  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const lower = spell.name.toLowerCase();
    spellNameSet.set(lower, (spellNameSet.get(lower) || 0) + 1);
  }

  // Find item effects that reference spell names
  const matchedEffects: { id: number; desc: string; matchedSpells: string[] }[] = [];
  const keywordCounts = new Map<string, number>();

  // Common effect keywords
  const effectKeywords = ['damage', 'heal', 'regen', 'haste', 'slow', 'stun', 'root', 'snare', 'charm', 'mez',
    'nuke', 'dot', 'buff', 'debuff', 'resist', 'fire', 'cold', 'magic', 'poison', 'disease',
    'mana', 'endurance', 'attack', 'strength', 'agility', 'stamina', 'charisma', 'wisdom', 'intelligence',
    'proc', 'click', 'worn', 'focus', 'lifetap', 'shield', 'thorns', 'illusion'];

  for (const [id, desc] of itemEffectDescs) {
    const lowerDesc = desc.toLowerCase();

    // Count keywords
    for (const kw of effectKeywords) {
      if (lowerDesc.includes(kw)) {
        keywordCounts.set(kw, (keywordCounts.get(kw) || 0) + 1);
      }
    }

    // Check for spell name matches (3+ word names to avoid false positives)
    const matched: string[] = [];
    for (const [spellName] of spellNameSet) {
      if (spellName.length >= 8 && lowerDesc.includes(spellName)) {
        matched.push(spellName);
      }
    }
    if (matched.length > 0) {
      matchedEffects.push({ id, desc, matchedSpells: matched });
    }
  }

  // Keyword frequency
  lines.push('## Effect Keyword Frequency', '');
  lines.push('| Keyword | Item Effects | % of Total |');
  lines.push('|---------|------------:|----------:|');
  const sortedKeywords = [...keywordCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [kw, count] of sortedKeywords) {
    const pct = Math.round(count / itemEffectDescs.size * 100);
    lines.push(`| ${kw} | ${count} | ${pct}% |`);
  }

  // Item effects with spell name matches
  lines.push('', `## Item Effects Referencing Spell Names (${matchedEffects.length})`, '');
  if (matchedEffects.length > 0) {
    lines.push('| Item Effect ID | Matched Spells | Description (preview) |');
    lines.push('|---------------:|---------------|----------------------|');
    for (const m of matchedEffects.slice(0, 30)) {
      const preview = m.desc.slice(0, 60) + (m.desc.length > 60 ? '...' : '');
      lines.push(`| ${m.id} | ${m.matchedSpells.slice(0, 3).join(', ')} | ${preview} |`);
    }
  } else {
    lines.push('*No exact spell name matches found in item effect descriptions.*');
  }

  // Category analysis based on keywords
  lines.push('', '## Effect Category Classification', '');
  const categories: Record<string, number> = {
    'Offensive': 0, 'Defensive': 0, 'Healing': 0, 'Stat Enhancement': 0,
    'Utility': 0, 'Resist': 0, 'Crowd Control': 0
  };
  const offenseKws = ['damage', 'nuke', 'dot', 'proc', 'attack', 'lifetap', 'thorns'];
  const defenseKws = ['shield', 'armor', 'absorb', 'rune', 'avoidance'];
  const healKws = ['heal', 'regen', 'mana regen', 'endurance'];
  const statKws = ['strength', 'agility', 'stamina', 'charisma', 'wisdom', 'intelligence', 'haste'];
  const utilKws = ['illusion', 'click', 'worn', 'focus', 'levitate', 'see invis'];
  const resistKws = ['resist', 'fire', 'cold', 'magic', 'poison', 'disease'];
  const ccKws = ['stun', 'root', 'snare', 'charm', 'mez', 'slow'];

  for (const [, desc] of itemEffectDescs) {
    const lower = desc.toLowerCase();
    if (offenseKws.some(k => lower.includes(k))) categories['Offensive']++;
    if (defenseKws.some(k => lower.includes(k))) categories['Defensive']++;
    if (healKws.some(k => lower.includes(k))) categories['Healing']++;
    if (statKws.some(k => lower.includes(k))) categories['Stat Enhancement']++;
    if (utilKws.some(k => lower.includes(k))) categories['Utility']++;
    if (resistKws.some(k => lower.includes(k))) categories['Resist']++;
    if (ccKws.some(k => lower.includes(k))) categories['Crowd Control']++;
  }

  const sortedCats = Object.entries(categories).sort((a, b) => b[1] - a[1]);
  for (const [cat, count] of sortedCats) {
    const pct = Math.round(count / itemEffectDescs.size * 100);
    const bar = '#'.repeat(Math.min(pct, 40));
    lines.push(`- **${cat}:** ${count} (${pct}%) ${bar}`);
  }

  lines.push('', `*${itemEffectDescs.size} total item effects analyzed, ${spells.size} spells cross-referenced.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: CREATURE TYPE FACTION CORRELATION ============

export async function getCreatureTypeFactionCorrelation(): Promise<string> {
  await loadCreatureTypes();
  await loadFactions();
  if (!creatureTypes || creatureTypes.size === 0) return 'Creature type data not available.';
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Creature Type-Faction Correlation', ''];
  lines.push('*Cross-reference 973 creature types with 1600+ factions to find lore connections.*', '');

  // For each creature type, find factions whose name contains the creature name
  interface Correlation {
    creatureId: number;
    creatureName: string;
    matchedFactions: { id: number; name: string; category: string }[];
  }

  const correlations: Correlation[] = [];
  let totalMatches = 0;

  // Build word-based lookup from creature type names
  const creatureWords = new Map<string, string[]>(); // word -> creature names that contain it
  for (const [, name] of creatureTypes) {
    const words = name.toLowerCase().split(/\s+/).filter(w => w.length >= 4); // skip short words
    for (const w of words) {
      if (!creatureWords.has(w)) creatureWords.set(w, []);
      creatureWords.get(w)!.push(name);
    }
  }

  for (const [cId, cName] of creatureTypes) {
    const cLower = cName.toLowerCase();
    // Skip very short or generic names
    if (cLower.length < 4) continue;

    const matched: { id: number; name: string; category: string }[] = [];
    for (const [fId, faction] of factions) {
      const fLower = faction.name.toLowerCase();
      // Check if creature name appears in faction name or vice versa
      if (cLower.length >= 4 && (fLower.includes(cLower) || cLower.includes(fLower.split(' ')[0]))) {
        matched.push({ id: fId, name: faction.name, category: faction.category || '' });
      }
    }

    if (matched.length > 0) {
      correlations.push({ creatureId: cId, creatureName: cName, matchedFactions: matched });
      totalMatches += matched.length;
    }
  }

  // Sort by number of matches
  correlations.sort((a, b) => b.matchedFactions.length - a.matchedFactions.length);

  lines.push(`## Summary`, '');
  lines.push(`- **Creature types with faction matches:** ${correlations.length} of ${creatureTypes.size} (${Math.round(correlations.length / creatureTypes.size * 100)}%)`);
  lines.push(`- **Total creature-faction links:** ${totalMatches}`);
  lines.push(`- **Average factions per matched creature:** ${correlations.length > 0 ? (totalMatches / correlations.length).toFixed(1) : '0'}`);

  // Top correlated creatures
  lines.push('', '## Most Connected Creature Types', '');
  lines.push('| Creature | Factions | Top Faction Names |');
  lines.push('|----------|--------:|-------------------|');
  for (const c of correlations.slice(0, 25)) {
    const topNames = c.matchedFactions.slice(0, 3).map(f => f.name).join('; ');
    lines.push(`| ${c.creatureName} | ${c.matchedFactions.length} | ${topNames} |`);
  }

  // Expansion distribution of matched factions
  const expDist = new Map<string, number>();
  for (const c of correlations) {
    for (const f of c.matchedFactions) {
      const exp = f.category || 'Unknown';
      expDist.set(exp, (expDist.get(exp) || 0) + 1);
    }
  }
  if (expDist.size > 0) {
    lines.push('', '## Creature-Linked Factions by Expansion', '');
    const sortedExp = [...expDist.entries()].sort((a, b) => b[1] - a[1]).slice(0, 15);
    for (const [exp, count] of sortedExp) {
      const bar = '#'.repeat(Math.min(Math.round(count / 2), 40));
      lines.push(`- **${exp}:** ${count} ${bar}`);
    }
  }

  // Creature types with NO faction matches
  const unmatched = creatureTypes.size - correlations.length;
  lines.push('', `## Unmatched Creature Types: ${unmatched}`, '');
  lines.push(`*${unmatched} creature types have no matching faction names — these are likely generic mob types or player-only races.*`);

  // Sample unmatched
  const unmatchedSet = new Set([...creatureTypes.keys()]);
  for (const c of correlations) unmatchedSet.delete(c.creatureId);
  const sampleUnmatched = [...unmatchedSet].slice(0, 15).map(id => creatureTypes!.get(id) || `ID ${id}`);
  if (sampleUnmatched.length > 0) {
    lines.push(`Sample: ${sampleUnmatched.join(', ')}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: AA ROLE THEME ANALYSIS ============

export async function getAARoleThemeAnalysis(): Promise<string> {
  await loadAAAbilities();
  if (!aaAbilities || aaAbilities.size === 0) return 'AA ability data not available.';

  const lines = ['# AA Role Theme Analysis', ''];
  lines.push('*2700+ AA abilities classified by role theme from description keywords.*', '');

  // Role keyword mapping
  const roleKeywords: Record<string, string[]> = {
    'Tank/Defense': ['mitigat', 'absorb', 'block', 'parry', 'riposte', 'avoidance', 'armor class', 'aggro', 'hate', 'taunt', 'shield', 'defensive', 'fortif'],
    'Healing': ['heal', 'cure', 'resurrect', 'restoration', 'mend', 'remedy', 'patch', 'bandage'],
    'Melee DPS': ['melee', 'backstab', 'double attack', 'triple attack', 'flurry', 'frenzy', 'kick', 'bash', 'slam', 'strikethrough', 'accuracy', 'weapon'],
    'Spell DPS': ['spell damage', 'nuke', 'critical spell', 'spell crit', 'focus effect', 'cast time', 'mana cost', 'spell haste', 'detrimental'],
    'DoT/Debuff': ['damage over time', 'dot', 'debuff', 'slow', 'reduce', 'weaken', 'corruption'],
    'Crowd Control': ['stun', 'root', 'snare', 'mezz', 'charm', 'fear', 'pacif'],
    'Buff/Support': ['buff', 'enhance', 'augment', 'aura', 'beneficial', 'group', 'raid', 'ally'],
    'Pet': ['pet', 'minion', 'companion', 'warder', 'swarm', 'summon'],
    'Utility': ['gate', 'bind', 'invis', 'levitat', 'see invis', 'track', 'forage', 'feign', 'fade', 'escape', 'teleport', 'evac'],
    'Resource': ['mana', 'endurance', 'regenerat', 'regen', 'conservation', 'efficiency'],
    'Resist/Survival': ['resist', 'fire resist', 'cold resist', 'magic resist', 'poison resist', 'disease resist', 'save', 'hit point', 'hp'],
  };

  const roleCounts: Record<string, number> = {};
  const roleAASamples: Record<string, string[]> = {};
  let classified = 0;
  let unclassified = 0;

  for (const aa of aaAbilities.values()) {
    const text = (aa.name + ' ' + aa.description).toLowerCase();
    let found = false;

    for (const [role, keywords] of Object.entries(roleKeywords)) {
      for (const kw of keywords) {
        if (text.includes(kw)) {
          roleCounts[role] = (roleCounts[role] || 0) + 1;
          if (!roleAASamples[role]) roleAASamples[role] = [];
          if (roleAASamples[role].length < 5) roleAASamples[role].push(aa.name);
          found = true;
          break;
        }
      }
      if (found) break; // Only count primary role
    }

    if (found) classified++; else unclassified++;
  }

  // Summary table
  lines.push('## Role Distribution', '');
  lines.push('| Role | AA Count | % |');
  lines.push('|------|--------:|---:|');
  const sortedRoles = Object.entries(roleCounts).sort((a, b) => b[1] - a[1]);
  for (const [role, count] of sortedRoles) {
    const pct = Math.round(count / aaAbilities.size * 100);
    lines.push(`| ${role} | ${count} | ${pct}% |`);
  }
  lines.push(`| *Unclassified* | *${unclassified}* | *${Math.round(unclassified / aaAbilities.size * 100)}%* |`);

  // Bar chart
  lines.push('', '## Visual Distribution', '');
  for (const [role, count] of sortedRoles) {
    const pct = Math.round(count / aaAbilities.size * 100);
    const bar = '█'.repeat(Math.min(pct * 2, 40));
    lines.push(`- **${role}:** ${bar} ${pct}% (${count})`);
  }

  // Samples per role
  lines.push('', '## Sample AAs by Role', '');
  for (const [role, count] of sortedRoles) {
    const samples = roleAASamples[role] || [];
    lines.push(`- **${role}:** ${samples.join(', ')}`);
  }

  lines.push('', `*${classified} classified / ${unclassified} unclassified out of ${aaAbilities.size} total AAs.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: ACHIEVEMENT CATEGORY DEPTH ANALYSIS ============

export async function getAchievementCategoryDepthAnalysis(): Promise<string> {
  await loadAchievements();
  await loadAchievementCategories();
  await loadAchievementComponents();
  if (!achievementCategories || achievementCategories.size === 0) return 'Achievement category data not available.';

  const lines = ['# Achievement Category Hierarchy Analysis', ''];

  // Build parent-child tree
  const children = new Map<number, number[]>(); // parentId -> childIds
  const rootCategories: number[] = [];

  for (const [catId, cat] of achievementCategories) {
    if (cat.parentId === 0 || cat.parentId === -1 || !achievementCategories.has(cat.parentId)) {
      rootCategories.push(catId);
    } else {
      if (!children.has(cat.parentId)) children.set(cat.parentId, []);
      children.get(cat.parentId)!.push(catId);
    }
  }

  // Calculate depth and breadth for each category
  interface CategoryStats {
    id: number;
    name: string;
    depth: number;
    totalDescendants: number;
    directChildren: number;
    achievementCount: number;
    totalPoints: number;
  }

  function getDepth(catId: number): number {
    const kids = children.get(catId) || [];
    if (kids.length === 0) return 0;
    return 1 + Math.max(...kids.map(getDepth));
  }

  function countDescendants(catId: number): number {
    const kids = children.get(catId) || [];
    let count = kids.length;
    for (const kid of kids) count += countDescendants(kid);
    return count;
  }

  const rootStats: CategoryStats[] = [];
  for (const rootId of rootCategories) {
    const cat = achievementCategories.get(rootId)!;
    const depth = getDepth(rootId);
    const totalDescendants = countDescendants(rootId);
    const directChildren = (children.get(rootId) || []).length;

    // Count achievements in this tree
    let achievementCount = 0;
    let totalPoints = 0;
    function countInTree(id: number) {
      const achs = categoryToAchievements?.get(id) || [];
      achievementCount += achs.length;
      if (achievements) {
        for (const aId of achs) {
          const ach = achievements.get(aId);
          if (ach) totalPoints += ach.points;
        }
      }
      for (const kid of (children.get(id) || [])) countInTree(kid);
    }
    countInTree(rootId);

    rootStats.push({ id: rootId, name: cat.name, depth, totalDescendants, directChildren, achievementCount, totalPoints });
  }

  // Sort by achievement count
  rootStats.sort((a, b) => b.achievementCount - a.achievementCount);

  lines.push(`## Category Overview`, '');
  lines.push(`- **Top-level categories:** ${rootCategories.length}`);
  lines.push(`- **Total categories:** ${achievementCategories.size}`);
  lines.push(`- **Max hierarchy depth:** ${Math.max(...rootStats.map(r => r.depth))}`);

  lines.push('', '## Top-Level Categories', '');
  lines.push('| Category | Depth | Subcategories | Achievements | Points |');
  lines.push('|----------|------:|-------------:|-----------:|-------:|');
  for (const s of rootStats) {
    lines.push(`| ${s.name} | ${s.depth} | ${s.totalDescendants} | ${s.achievementCount} | ${s.totalPoints} |`);
  }

  // Depth distribution
  const depthCounts = new Map<number, number>();
  for (const s of rootStats) {
    depthCounts.set(s.depth, (depthCounts.get(s.depth) || 0) + 1);
  }
  lines.push('', '## Hierarchy Depth Distribution', '');
  for (const [depth, count] of [...depthCounts.entries()].sort((a, b) => a[0] - b[0])) {
    const bar = '#'.repeat(Math.min(count * 2, 40));
    lines.push(`- **Depth ${depth}:** ${count} categories ${bar}`);
  }

  // Most complex (deepest + widest)
  const byComplexity = [...rootStats].sort((a, b) => (b.depth + b.totalDescendants) - (a.depth + a.totalDescendants));
  lines.push('', '## Most Complex Category Trees', '');
  for (const s of byComplexity.slice(0, 10)) {
    lines.push(`- **${s.name}:** depth ${s.depth}, ${s.totalDescendants} subcategories, ${s.achievementCount} achievements`);
  }

  // Point density (points per achievement)
  lines.push('', '## Point Density by Category', '');
  lines.push('| Category | Achievements | Total Points | Avg Points |');
  lines.push('|----------|------------:|------------:|----------:|');
  const withAch = rootStats.filter(s => s.achievementCount > 0);
  withAch.sort((a, b) => (b.totalPoints / b.achievementCount) - (a.totalPoints / a.achievementCount));
  for (const s of withAch.slice(0, 15)) {
    const avg = (s.totalPoints / s.achievementCount).toFixed(1);
    lines.push(`| ${s.name} | ${s.achievementCount} | ${s.totalPoints} | ${avg} |`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: MAP POI FUNCTIONAL CLASSIFICATION ============

export async function getMapPOIFunctionalClassification(): Promise<string> {
  await loadZones();

  const lines = ['# Map POI Functional Classification', ''];
  lines.push('*34K+ map points of interest classified into functional categories.*', '');

  const mapDir = gamePath('maps');
  if (!existsSync(mapDir)) return 'Maps directory not found at ' + mapDir;

  const allFiles = await readdir(mapDir);
  const files = allFiles.filter((f: string) => f.endsWith('.txt') && !f.endsWith('_1.txt') && !f.endsWith('_2.txt') && !f.endsWith('_3.txt'));

  // Functional categories with keyword patterns
  const categories: Record<string, string[]> = {
    'Merchant/Vendor': ['merchant', 'vendor', 'shop', 'trader', 'bazaar', 'store', 'supply', 'dealer'],
    'Zone Line/Portal': ['zone', 'portal', 'entrance', 'exit', 'tunnel', 'passage', 'door', 'gate to', 'to ', 'from '],
    'Quest NPC': ['quest', 'task', 'mission', 'giver', 'objective'],
    'Bank/Vault': ['bank', 'vault', 'deposit', 'storage'],
    'Guild/Class': ['guild', 'guildmaster', 'guildmast', 'class trainer', 'trainer'],
    'Guard/Military': ['guard', 'soldier', 'captain', 'lieutenant', 'sergeant', 'commander', 'watchman', 'patrol'],
    'Temple/Shrine': ['temple', 'shrine', 'altar', 'church', 'chapel', 'priest', 'cleric'],
    'Camp/Spawn': ['camp', 'spawn', 'named', 'rare', 'boss', 'ph'],
    'Craft/Trade': ['forge', 'loom', 'oven', 'brew', 'kiln', 'pottery', 'tinkering', 'fletching', 'jewel'],
    'Binding/Resurrection': ['bind', 'soulbinder', 'resurrect', 'graveyard'],
    'Boat/Transport': ['boat', 'ship', 'dock', 'translocator', 'port', 'harbor'],
    'Inn/Tavern': ['inn', 'tavern', 'bar', 'pub', 'brew'],
    'Landmark': ['tower', 'bridge', 'fountain', 'statue', 'monument', 'ruins', 'cave', 'lake', 'river', 'mountain'],
  };

  const categoryCounts: Record<string, number> = {};
  const categoryZones: Record<string, Set<string>> = {};
  let totalPOIs = 0;
  let classified = 0;

  for (const cat of Object.keys(categories)) {
    categoryCounts[cat] = 0;
    categoryZones[cat] = new Set();
  }

  for (const file of files) {
    try {
      const content = await readFile(join(mapDir, file), 'utf-8');
      const poiLines = content.split('\n').filter((l: string) => l.startsWith('P '));
      const zoneName = file.replace('.txt', '');

      for (const line of poiLines) {
        const parts = line.split(',');
        if (parts.length < 8) continue;
        totalPOIs++;

        const label = parts.slice(7).join(',').trim().toLowerCase();
        if (!label) continue;

        let matched = false;
        for (const [cat, keywords] of Object.entries(categories)) {
          for (const kw of keywords) {
            if (label.includes(kw)) {
              categoryCounts[cat]++;
              categoryZones[cat].add(zoneName);
              matched = true;
              break;
            }
          }
          if (matched) break;
        }
        if (matched) classified++;
      }
    } catch {
      continue;
    }
  }

  // Category summary
  lines.push('## Functional Category Summary', '');
  lines.push('| Category | POIs | % of Total | Zones |');
  lines.push('|----------|-----:|----------:|------:|');
  const sortedCats = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);
  for (const [cat, count] of sortedCats) {
    if (count > 0) {
      const pct = Math.round(count / totalPOIs * 100);
      lines.push(`| ${cat} | ${count} | ${pct}% | ${categoryZones[cat].size} |`);
    }
  }
  const unclassified = totalPOIs - classified;
  lines.push(`| *Unclassified* | *${unclassified}* | *${Math.round(unclassified / totalPOIs * 100)}%* | - |`);

  // Visual distribution
  lines.push('', '## Visual Distribution', '');
  for (const [cat, count] of sortedCats) {
    if (count > 0) {
      const pct = Math.round(count / totalPOIs * 100);
      const bar = '█'.repeat(Math.min(pct * 2, 40));
      lines.push(`- **${cat}:** ${bar} ${pct}% (${count})`);
    }
  }

  lines.push('', `## Totals`, '');
  lines.push(`- **Total POIs scanned:** ${totalPOIs.toLocaleString()}`);
  lines.push(`- **Classified:** ${classified.toLocaleString()} (${Math.round(classified / totalPOIs * 100)}%)`);
  lines.push(`- **Unclassified:** ${unclassified.toLocaleString()} (${Math.round(unclassified / totalPOIs * 100)}%)`);
  lines.push(`- **Map files scanned:** ${files.length}`);

  return lines.join('\n');
}

// ============ PUBLIC API: UNIFIED LOCAL DATA SEARCH ============

export async function searchAllLocalData(query: string): Promise<string> {
  // Load all searchable data systems in parallel
  await Promise.all([
    loadSpells(), loadZones(), loadFactions(), loadAchievements(),
    loadAAAbilities(), loadTributes(), loadCreatureTypes(), loadCombatAbilities(),
    loadItemEffects(), loadOverseerMinions(), loadOverseerQuests(),
    loadGameEvents(), loadExpansions(), loadLore(),
  ]);

  const lower = query.toLowerCase();
  const lines = [`# Unified Search: "${query}"`, ''];
  let totalMatches = 0;

  // Search spells
  if (spells && spells.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const spell of spells.values()) {
      if (spell.name.toLowerCase().includes(lower) && spell.name !== 'UNKNOWN DB STR' && !spell.name.startsWith('*')) {
        matches.push({ id: spell.id, name: spell.name });
        if (matches.length >= 15) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Spells (${matches.length}${matches.length >= 15 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search zones
  if (zones && zones.size > 0) {
    const matches: { id: number; name: string; level: string }[] = [];
    for (const z of zones.values()) {
      if (z.name.toLowerCase().includes(lower)) {
        matches.push({ id: z.id, name: z.name, level: z.levelMin > 0 ? `${z.levelMin}-${z.levelMax}` : '' });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Zones (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}${m.level ? ` (${m.level})` : ''}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search factions
  if (factions && factions.size > 0) {
    const matches: { id: number; name: string; category: string }[] = [];
    for (const f of factions.values()) {
      if (f.name.toLowerCase().includes(lower)) {
        matches.push({ id: f.id, name: f.name, category: f.category || '' });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Factions (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}${m.category ? ` (${m.category})` : ''}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search achievements
  if (achievements && achievements.size > 0) {
    const matches: { id: number; name: string; points: number }[] = [];
    for (const a of achievements.values()) {
      if (a.name.toLowerCase().includes(lower)) {
        matches.push({ id: a.id, name: a.name, points: a.points });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Achievements (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name} (${m.points} pts)`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search AA abilities
  if (aaAbilities && aaAbilities.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const aa of aaAbilities.values()) {
      if (aa.name.toLowerCase().includes(lower)) {
        matches.push({ id: aa.id, name: aa.name });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## AA Abilities (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search combat abilities
  if (combatAbilities && combatAbilities.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const [id, name] of combatAbilities) {
      if (name.toLowerCase().includes(lower)) {
        matches.push({ id, name });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Combat Abilities (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search tributes
  if (tributes && tributes.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const t of tributes.values()) {
      if (t.name.toLowerCase().includes(lower)) {
        matches.push({ id: t.id, name: t.name });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Tributes (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search creature types
  if (creatureTypes && creatureTypes.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const [id, name] of creatureTypes) {
      if (name.toLowerCase().includes(lower)) {
        matches.push({ id, name });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Creature Types (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search overseer agents
  if (overseerMinions && overseerMinions.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const m of overseerMinions.values()) {
      if (m.fullName.toLowerCase().includes(lower) || m.shortName.toLowerCase().includes(lower)) {
        matches.push({ id: m.id, name: m.fullName });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Overseer Agents (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search overseer quests
  if (overseerQuests && overseerQuests.size > 0) {
    const matches: { id: number; name: string }[] = [];
    for (const q of overseerQuests.values()) {
      if (q.name.toLowerCase().includes(lower)) {
        matches.push({ id: q.id, name: q.name });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Overseer Quests (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.name}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search game events
  if (gameEvents && gameEvents.size > 0) {
    const matches: { id: number; banner: string }[] = [];
    for (const [id, evt] of gameEvents) {
      if (evt.banner.toLowerCase().includes(lower) || evt.description.toLowerCase().includes(lower)) {
        matches.push({ id, banner: evt.banner });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Game Events (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.banner}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search lore
  if (loreEntries && loreEntries.length > 0) {
    const matches: { title: string }[] = [];
    for (const l of loreEntries) {
      if (l.title.toLowerCase().includes(lower) || l.content.toLowerCase().includes(lower)) {
        matches.push({ title: l.title });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Lore Entries (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- ${m.title}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  // Search item effects
  if (itemEffectDescs && itemEffectDescs.size > 0) {
    const matches: { id: number; desc: string }[] = [];
    for (const [id, desc] of itemEffectDescs) {
      if (desc.toLowerCase().includes(lower)) {
        matches.push({ id, desc: desc.slice(0, 80) });
        if (matches.length >= 10) break;
      }
    }
    if (matches.length > 0) {
      lines.push(`## Item Effects (${matches.length}${matches.length >= 10 ? '+' : ''})`, '');
      for (const m of matches) lines.push(`- [${m.id}] ${m.desc}${m.desc.length >= 80 ? '...' : ''}`);
      lines.push('');
      totalMatches += matches.length;
    }
  }

  if (totalMatches === 0) {
    lines.push(`No results found for "${query}" across any local data system.`);
  } else {
    lines.push(`---`, `**Total matches:** ${totalMatches} across local data systems`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: GAME EVENT CALENDAR ANALYSIS ============

export async function getGameEventCalendarAnalysis(): Promise<string> {
  await loadGameEvents();
  await loadExpansions();
  if (!gameEvents || gameEvents.size === 0) return 'Game event data not available.';

  const lines = ['# Game Event Calendar Analysis', ''];
  lines.push('*573 game events classified by type and content.*', '');

  // Classify events by keywords
  const categories: Record<string, string[]> = {
    'Double/Bonus XP': ['double', 'bonus', 'experience', 'rare spawn', 'rare loot'],
    'Expansion Launch': ['expansion', 'launch', 'available now', 'now available', 'new expansion'],
    'Seasonal/Holiday': ['frostfell', 'halloween', 'erollisi', 'bristlebane', 'anniversary', 'birthday', 'new year', 'valentine', 'feast'],
    'Content Update': ['update', 'patch', 'new content', 'added', 'revamp', 'tuning'],
    'Marketplace/Store': ['marketplace', 'store', 'sale', 'discount', 'free', 'claim', 'bundle'],
    'Server/Maintenance': ['server', 'maintenance', 'downtime', 'merge', 'transfer'],
    'Competition/Contest': ['contest', 'competition', 'challenge', 'race', 'tournament'],
    'Community': ['community', 'player', 'guild', 'fanfaire', 'fan faire', 'event'],
  };

  const catCounts: Record<string, number> = {};
  const catSamples: Record<string, string[]> = {};
  let classified = 0;

  for (const [, evt] of gameEvents) {
    const text = (evt.banner + ' ' + evt.description).toLowerCase();
    let found = false;

    for (const [cat, keywords] of Object.entries(categories)) {
      for (const kw of keywords) {
        if (text.includes(kw)) {
          catCounts[cat] = (catCounts[cat] || 0) + 1;
          if (!catSamples[cat]) catSamples[cat] = [];
          if (catSamples[cat].length < 3) catSamples[cat].push(evt.banner || evt.description.slice(0, 50));
          found = true;
          break;
        }
      }
      if (found) break;
    }

    if (found) classified++;
  }

  // Category summary
  const unclassified = gameEvents.size - classified;

  lines.push('## Event Type Distribution', '');
  lines.push('| Type | Count | % |');
  lines.push('|------|------:|---:|');
  const sortedCats = Object.entries(catCounts).sort((a, b) => b[1] - a[1]);
  for (const [cat, count] of sortedCats) {
    const pct = Math.round(count / gameEvents.size * 100);
    lines.push(`| ${cat} | ${count} | ${pct}% |`);
  }
  lines.push(`| *Unclassified* | *${unclassified}* | *${Math.round(unclassified / gameEvents.size * 100)}%* |`);

  // Visual distribution
  lines.push('', '## Visual Distribution', '');
  for (const [cat, count] of sortedCats) {
    const pct = Math.round(count / gameEvents.size * 100);
    const bar = '█'.repeat(Math.min(pct * 2, 40));
    lines.push(`- **${cat}:** ${bar} ${pct}% (${count})`);
  }

  // Samples per category
  lines.push('', '## Sample Events', '');
  for (const [cat] of sortedCats) {
    const samples = catSamples[cat] || [];
    lines.push(`- **${cat}:** ${samples.join(' | ')}`);
  }

  // Expansion mentions in events
  if (expansionNames && expansionNames.size > 0) {
    lines.push('', '## Expansion Mentions in Events', '');
    const expMentions: { name: string; count: number }[] = [];
    for (const [, expName] of expansionNames) {
      let count = 0;
      const expLower = expName.toLowerCase();
      for (const [, evt] of gameEvents) {
        if ((evt.banner + ' ' + evt.description).toLowerCase().includes(expLower)) count++;
      }
      if (count > 0) expMentions.push({ name: expName, count });
    }
    expMentions.sort((a, b) => b.count - a.count);
    for (const m of expMentions.slice(0, 15)) {
      const bar = '#'.repeat(Math.min(m.count, 30));
      lines.push(`- **${m.name}:** ${m.count} ${bar}`);
    }
  }

  // Word frequency in event banners
  lines.push('', '## Common Event Banner Words', '');
  const wordFreq = new Map<string, number>();
  const stopWords = new Set(['the', 'and', 'for', 'are', 'you', 'all', 'your', 'has', 'been', 'will', 'now', 'with', 'new', 'this', 'from', 'that', 'have', 'our']);
  for (const [, evt] of gameEvents) {
    const words = evt.banner.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter(w => w.length > 2 && !stopWords.has(w));
    for (const w of words) wordFreq.set(w, (wordFreq.get(w) || 0) + 1);
  }
  const topWords = [...wordFreq.entries()].sort((a, b) => b[1] - a[1]).slice(0, 20);
  lines.push(topWords.map(([w, c]) => `${w} (${c})`).join(', '));

  lines.push('', `*${gameEvents.size} total events analyzed, ${classified} classified (${Math.round(classified / gameEvents.size * 100)}%).*`);

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS GROUP BUFF CONTRIBUTION ============

export async function getClassGroupBuffContribution(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Group Buff Contribution', ''];
  lines.push('*What unique group/raid buffs each class brings — the reason to invite them.*', '');

  // Find group-target beneficial spells per class
  // Target types: 3=Group, 41=Group v2, 6=Self, 14=Pet, etc.
  const GROUP_TARGETS = new Set(['3', '41', '40']); // Group, Group v2, AE PC

  interface BuffInfo {
    name: string;
    category: string;
    level: number;
    targetType: string;
  }

  const classBufs: Map<number, BuffInfo[]> = new Map();

  for (let cid = 1; cid <= 16; cid++) {
    classBufs.set(cid, []);
  }

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    if (spell.fields[SF.BENEFICIAL] !== '1') continue;

    const targetType = spell.fields[SF.TARGET_TYPE] || '';
    if (!GROUP_TARGETS.has(targetType)) continue;

    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Category ${catId}`);

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      classBufs.get(cid)!.push({ name: spell.name, category: catName, level, targetType });
    }
  }

  // Summary table
  lines.push('## Group Buff Counts by Class', '');
  lines.push('| Class | Group Buffs | Top Categories |');
  lines.push('|-------|----------:|----------------|');

  for (let cid = 1; cid <= 16; cid++) {
    const bufs = classBufs.get(cid)!;
    // Count by category
    const catCounts = new Map<string, number>();
    for (const b of bufs) {
      catCounts.set(b.category, (catCounts.get(b.category) || 0) + 1);
    }
    const topCats = [...catCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 3);
    const catStr = topCats.map(([c, n]) => `${c} (${n})`).join(', ');
    lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${bufs.length} | ${catStr} |`);
  }

  // Find class-exclusive group buffs
  lines.push('', '## Class-Exclusive Group Buffs', '');
  lines.push('*Group buff categories that only one class provides.*', '');

  // Map category to which classes provide it as a group buff
  const categoryClasses = new Map<string, Set<number>>();
  for (let cid = 1; cid <= 16; cid++) {
    for (const b of classBufs.get(cid)!) {
      if (!categoryClasses.has(b.category)) categoryClasses.set(b.category, new Set());
      categoryClasses.get(b.category)!.add(cid);
    }
  }

  // Exclusive categories
  const exclusiveCats: { category: string; classId: number; count: number }[] = [];
  for (const [cat, classes] of categoryClasses) {
    if (classes.size === 1) {
      const cid = [...classes][0];
      const count = classBufs.get(cid)!.filter(b => b.category === cat).length;
      exclusiveCats.push({ category: cat, classId: cid, count });
    }
  }
  exclusiveCats.sort((a, b) => b.count - a.count);

  if (exclusiveCats.length > 0) {
    lines.push('| Category | Exclusive To | Group Buffs |');
    lines.push('|----------|-------------|----------:|');
    for (const e of exclusiveCats.slice(0, 20)) {
      lines.push(`| ${e.category} | ${CLASS_IDS[e.classId]} (${CLASS_SHORT[e.classId]}) | ${e.count} |`);
    }
  }

  // Rare group buff categories (2-3 classes)
  const rareCats = [...categoryClasses.entries()]
    .filter(([, c]) => c.size >= 2 && c.size <= 3)
    .map(([cat, classes]) => ({
      category: cat,
      classes: [...classes].map(c => CLASS_SHORT[c]),
      total: [...classes].reduce((s, c) => s + classBufs.get(c)!.filter(b => b.category === cat).length, 0)
    }))
    .sort((a, b) => a.classes.length - b.classes.length || b.total - a.total);

  if (rareCats.length > 0) {
    lines.push('', '## Rare Group Buff Categories (2-3 Classes)', '');
    lines.push('| Category | Classes | Total Buffs |');
    lines.push('|----------|---------|----------:|');
    for (const r of rareCats.slice(0, 15)) {
      lines.push(`| ${r.category} | ${r.classes.join(', ')} | ${r.total} |`);
    }
  }

  // Universal categories (all 16 classes)
  const universalCats = [...categoryClasses.entries()].filter(([, c]) => c.size === 16);
  if (universalCats.length > 0) {
    lines.push('', `## Universal Group Buff Categories (All 16 Classes): ${universalCats.length}`, '');
    lines.push(universalCats.map(([c]) => c).join(', '));
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS SYNERGY MATRIX ============

export async function getClassSynergyMatrix(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Synergy Matrix', ''];
  lines.push('*16×16 class pair synergy scored by exclusive buff category coverage.*', '');

  // Build a map of class → set of group buff categories (beneficial, group-target)
  const GROUP_TARGETS = new Set(['3', '41', '40']);
  const classCategories: Map<number, Set<string>> = new Map();
  for (let cid = 1; cid <= 16; cid++) classCategories.set(cid, new Set());

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    if (spell.fields[SF.BENEFICIAL] !== '1') continue;
    if (!GROUP_TARGETS.has(spell.fields[SF.TARGET_TYPE] || '')) continue;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Category ${catId}`);
    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level >= 1 && level <= 254) {
        classCategories.get(cid)!.add(catName);
      }
    }
  }

  // For each pair, count union of categories (more = better synergy)
  interface PairScore { c1: number; c2: number; union: number; exclusive1: number; exclusive2: number; shared: number }
  const pairs: PairScore[] = [];

  for (let c1 = 1; c1 <= 16; c1++) {
    for (let c2 = c1 + 1; c2 <= 16; c2++) {
      const cats1 = classCategories.get(c1)!;
      const cats2 = classCategories.get(c2)!;
      const union = new Set([...cats1, ...cats2]);
      let shared = 0, exclusive1 = 0, exclusive2 = 0;
      for (const c of cats1) { if (cats2.has(c)) shared++; else exclusive1++; }
      for (const c of cats2) { if (!cats1.has(c)) exclusive2++; }
      pairs.push({ c1, c2, union: union.size, exclusive1, exclusive2, shared });
    }
  }

  pairs.sort((a, b) => b.union - a.union);

  // Top 20 pairs
  lines.push('## Top 20 Class Pairs (Most Buff Category Coverage)', '');
  lines.push('| Rank | Classes | Union | Exclusive A | Exclusive B | Shared |');
  lines.push('|-----:|---------|------:|----------:|----------:|------:|');
  for (let i = 0; i < 20 && i < pairs.length; i++) {
    const p = pairs[i];
    lines.push(`| ${i + 1} | ${CLASS_SHORT[p.c1]}+${CLASS_SHORT[p.c2]} | ${p.union} | ${p.exclusive1} | ${p.exclusive2} | ${p.shared} |`);
  }

  // Bottom 10 (most redundant)
  lines.push('', '## Bottom 10 Pairs (Most Redundant)', '');
  lines.push('| Rank | Classes | Union | Exclusive A | Exclusive B | Shared |');
  lines.push('|-----:|---------|------:|----------:|----------:|------:|');
  const bottom = pairs.slice(-10).reverse();
  for (let i = 0; i < bottom.length; i++) {
    const p = bottom[i];
    lines.push(`| ${pairs.length - 9 + i} | ${CLASS_SHORT[p.c1]}+${CLASS_SHORT[p.c2]} | ${p.union} | ${p.exclusive1} | ${p.exclusive2} | ${p.shared} |`);
  }

  // Per-class best partner
  lines.push('', '## Best Partner for Each Class', '');
  lines.push('| Class | Best Partner | Union Categories | Unique Contribution |');
  lines.push('|-------|-------------|------:|---------------------|');
  for (let cid = 1; cid <= 16; cid++) {
    const myPairs = pairs.filter(p => p.c1 === cid || p.c2 === cid);
    myPairs.sort((a, b) => b.union - a.union);
    if (myPairs.length > 0) {
      const best = myPairs[0];
      const partner = best.c1 === cid ? best.c2 : best.c1;
      const partnerExcl = best.c1 === cid ? best.exclusive2 : best.exclusive1;
      lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${CLASS_IDS[partner]} (${CLASS_SHORT[partner]}) | ${best.union} | +${partnerExcl} categories |`);
    }
  }

  // Category coverage per class
  lines.push('', '## Buff Categories per Class', '');
  const classCatSorted = [...classCategories.entries()].sort((a, b) => b[1].size - a[1].size);
  for (const [cid, cats] of classCatSorted) {
    const bar = '█'.repeat(Math.min(cats.size * 2, 40));
    lines.push(`- **${CLASS_SHORT[cid]}:** ${bar} ${cats.size} categories`);
  }

  lines.push('', `*${pairs.length} class pairs analyzed across ${new Set([...classCategories.values()].flatMap(s => [...s])).size} total group buff categories.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL EFFECT ENCYCLOPEDIA ============

export async function getSpellEffectEncyclopedia(spaId: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const targetSPA = parseInt(spaId);
  if (isNaN(targetSPA)) return 'Error: Invalid SPA ID. Provide a numeric spell effect ID (e.g., "0" for HP, "11" for Attack Speed).';

  const spaName = SPA_NAMES[targetSPA] || `Unknown SPA ${targetSPA}`;
  const lines = [`# Spell Effect Encyclopedia: SPA ${targetSPA} — ${spaName}`, ''];

  // Find all spells containing this SPA
  interface SPASpell {
    id: number;
    name: string;
    beneficial: boolean;
    level: Map<number, number>;
    category: string;
    base1: number;
    slotNum: number;
  }

  const matchingSpells: SPASpell[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    // Parse effect slots - scan backward for pipe-containing field
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    let foundSlot = -1;
    let foundBase = 0;
    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const slotSPA = parseInt(parts[1]);
        if (slotSPA === targetSPA) {
          foundSlot = parseInt(parts[0]);
          foundBase = parseInt(parts[2]) || 0;
          break;
        }
      }
    }
    if (foundSlot < 0) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Category ${catId}`);
    const levels = new Map<number, number>();
    for (let cid = 1; cid <= 16; cid++) {
      const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (lv >= 1 && lv <= 254) levels.set(cid, lv);
    }

    matchingSpells.push({ id: spell.id, name: spell.name, beneficial, level: levels, category: catName, base1: foundBase, slotNum: foundSlot });
  }

  if (matchingSpells.length === 0) {
    return `No spells found with SPA ${targetSPA} (${spaName}). Use list_spell_effect_types to see valid SPA IDs.`;
  }

  lines.push(`**Total spells with this effect:** ${matchingSpells.length}`, '');

  // Beneficial / detrimental split
  const beneficial = matchingSpells.filter(s => s.beneficial).length;
  const detrimental = matchingSpells.length - beneficial;
  lines.push(`- **Beneficial:** ${beneficial} (${Math.round(beneficial / matchingSpells.length * 100)}%)`);
  lines.push(`- **Detrimental:** ${detrimental} (${Math.round(detrimental / matchingSpells.length * 100)}%)`);

  // Class distribution
  lines.push('', '## Class Distribution', '');
  lines.push('| Class | Spells | Min Level | Max Level |');
  lines.push('|-------|------:|----------:|----------:|');
  for (let cid = 1; cid <= 16; cid++) {
    const classSpells = matchingSpells.filter(s => s.level.has(cid));
    if (classSpells.length === 0) {
      lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | 0 | — | — |`);
    } else {
      const levels = classSpells.map(s => s.level.get(cid)!);
      lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${classSpells.length} | ${Math.min(...levels)} | ${Math.max(...levels)} |`);
    }
  }

  // Category distribution
  lines.push('', '## Category Distribution', '');
  const catCounts = new Map<string, number>();
  for (const s of matchingSpells) {
    catCounts.set(s.category, (catCounts.get(s.category) || 0) + 1);
  }
  const sortedCats = [...catCounts.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('| Category | Count | % |');
  lines.push('|----------|------:|---:|');
  for (const [cat, count] of sortedCats.slice(0, 15)) {
    lines.push(`| ${cat} | ${count} | ${Math.round(count / matchingSpells.length * 100)}% |`);
  }
  if (sortedCats.length > 15) lines.push(`| *(${sortedCats.length - 15} more)* | | |`);

  // Base value analysis
  lines.push('', '## Effect Value (Base1) Distribution', '');
  const bases = matchingSpells.map(s => s.base1).filter(b => b !== 0);
  if (bases.length > 0) {
    bases.sort((a, b) => a - b);
    lines.push(`- **Range:** ${bases[0]} to ${bases[bases.length - 1]}`);
    lines.push(`- **Median:** ${bases[Math.floor(bases.length / 2)]}`);
    const avg = Math.round(bases.reduce((a, b) => a + b, 0) / bases.length);
    lines.push(`- **Average:** ${avg}`);
    const positiveCount = bases.filter(b => b > 0).length;
    const negativeCount = bases.filter(b => b < 0).length;
    lines.push(`- **Positive values:** ${positiveCount}, **Negative values:** ${negativeCount}`);
  } else {
    lines.push('- All spells have base value of 0');
  }

  // Slot position analysis
  lines.push('', '## Slot Position Distribution', '');
  const slotCounts = new Map<number, number>();
  for (const s of matchingSpells) {
    slotCounts.set(s.slotNum, (slotCounts.get(s.slotNum) || 0) + 1);
  }
  const sortedSlots = [...slotCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [slot, count] of sortedSlots.slice(0, 10)) {
    const pct = Math.round(count / matchingSpells.length * 100);
    const bar = '█'.repeat(Math.min(pct, 40));
    lines.push(`- **Slot ${slot}:** ${bar} ${pct}% (${count})`);
  }

  // Sample spells (beneficial and detrimental)
  lines.push('', '## Sample Beneficial Spells', '');
  const sampleBen = matchingSpells.filter(s => s.beneficial).slice(0, 10);
  for (const s of sampleBen) {
    const classes = [...s.level.entries()].map(([c, l]) => `${CLASS_SHORT[c]}:${l}`).join(', ');
    lines.push(`- **${s.name}** [${s.id}] (base: ${s.base1}) — ${classes}`);
  }

  if (detrimental > 0) {
    lines.push('', '## Sample Detrimental Spells', '');
    const sampleDet = matchingSpells.filter(s => !s.beneficial).slice(0, 10);
    for (const s of sampleDet) {
      const classes = [...s.level.entries()].map(([c, l]) => `${CLASS_SHORT[c]}:${l}`).join(', ');
      lines.push(`- **${s.name}** [${s.id}] (base: ${s.base1}) — ${classes}`);
    }
  }

  lines.push('', `*${matchingSpells.length} spells analyzed for SPA ${targetSPA} (${spaName}).*`);

  return lines.join('\n');
}

// ============ PUBLIC API: ACHIEVEMENT POINT OPTIMIZER ============

export async function getAchievementPointOptimizer(): Promise<string> {
  await loadAchievements();
  await loadAchievementComponents();
  if (!achievements || achievements.size === 0) return 'Achievement data not available.';

  const lines = ['# Achievement Point Optimizer', ''];
  lines.push('*Most efficient achievements ranked by points per component.*', '');

  // Build list of achievements with component counts
  interface AchEff {
    id: number;
    name: string;
    points: number;
    components: number;
    efficiency: number;
    hidden: boolean;
  }

  const achList: AchEff[] = [];

  for (const ach of achievements.values()) {
    if (ach.points <= 0) continue;
    const comps = achievementComponents ? (achievementComponents.get(ach.id)?.length ?? 0) : 0;
    const steps = Math.max(comps, 1);
    achList.push({
      id: ach.id,
      name: ach.name,
      points: ach.points,
      components: steps,
      efficiency: ach.points / steps,
      hidden: ach.hidden,
    });
  }

  achList.sort((a, b) => b.efficiency - a.efficiency);

  // Overall stats
  const totalPoints = achList.reduce((s, a) => s + a.points, 0);
  const totalSteps = achList.reduce((s, a) => s + a.components, 0);
  lines.push('## Overview', '');
  lines.push(`- **Achievements with points:** ${achList.length}`);
  lines.push(`- **Total points available:** ${totalPoints.toLocaleString()}`);
  lines.push(`- **Total component steps:** ${totalSteps.toLocaleString()}`);
  lines.push(`- **Overall avg efficiency:** ${(totalPoints / totalSteps).toFixed(2)} pts/step`);

  // Top 30 most efficient
  lines.push('', '## Top 30 Most Efficient Achievements', '');
  lines.push('| Rank | Achievement | Points | Steps | Pts/Step |');
  lines.push('|-----:|------------|------:|------:|---------:|');
  for (let i = 0; i < 30 && i < achList.length; i++) {
    const a = achList[i];
    lines.push(`| ${i + 1} | ${a.name} [${a.id}] | ${a.points} | ${a.components} | ${a.efficiency.toFixed(1)} |`);
  }

  // Efficiency distribution
  lines.push('', '## Efficiency Distribution', '');
  const buckets: Record<string, number> = {
    '10+ pts/step': 0,
    '5-10 pts/step': 0,
    '2-5 pts/step': 0,
    '1-2 pts/step': 0,
    '<1 pt/step': 0,
  };
  for (const a of achList) {
    if (a.efficiency >= 10) buckets['10+ pts/step']++;
    else if (a.efficiency >= 5) buckets['5-10 pts/step']++;
    else if (a.efficiency >= 2) buckets['2-5 pts/step']++;
    else if (a.efficiency >= 1) buckets['1-2 pts/step']++;
    else buckets['<1 pt/step']++;
  }
  for (const [bucket, count] of Object.entries(buckets)) {
    const pct = Math.round(count / achList.length * 100);
    const bar = '█'.repeat(Math.min(pct, 40));
    lines.push(`- **${bucket}:** ${bar} ${pct}% (${count})`);
  }

  // Point value tiers
  lines.push('', '## Point Value Tiers', '');
  const pointBuckets = new Map<number, number>();
  for (const a of achList) {
    pointBuckets.set(a.points, (pointBuckets.get(a.points) || 0) + 1);
  }
  const sortedPoints = [...pointBuckets.entries()].sort((a, b) => b[0] - a[0]);
  lines.push('| Points | Count | Avg Steps |');
  lines.push('|------:|------:|----------:|');
  for (const [pts, count] of sortedPoints.slice(0, 15)) {
    const withPts = achList.filter(a => a.points === pts);
    const avgSteps = (withPts.reduce((s, a) => s + a.components, 0) / withPts.length).toFixed(1);
    lines.push(`| ${pts} | ${count} | ${avgSteps} |`);
  }

  // Most complex achievements (most components)
  const byComponents = [...achList].sort((a, b) => b.components - a.components);
  lines.push('', '## Most Complex Achievements (Most Steps)', '');
  lines.push('| Achievement | Steps | Points | Pts/Step |');
  lines.push('|------------|------:|------:|---------:|');
  for (let i = 0; i < 15 && i < byComponents.length; i++) {
    const a = byComponents[i];
    lines.push(`| ${a.name} [${a.id}] | ${a.components} | ${a.points} | ${a.efficiency.toFixed(1)} |`);
  }

  // Highest point single achievements
  const byPoints = [...achList].sort((a, b) => b.points - a.points);
  lines.push('', '## Highest Point Achievements', '');
  lines.push('| Achievement | Points | Steps | Pts/Step |');
  lines.push('|------------|------:|------:|---------:|');
  for (let i = 0; i < 15 && i < byPoints.length; i++) {
    const a = byPoints[i];
    lines.push(`| ${a.name} [${a.id}] | ${a.points} | ${a.components} | ${a.efficiency.toFixed(1)} |`);
  }

  // Hidden vs visible efficiency
  const hidden = achList.filter(a => a.hidden);
  const visible = achList.filter(a => !a.hidden);
  if (hidden.length > 0 && visible.length > 0) {
    lines.push('', '## Hidden vs Visible Achievements', '');
    const hiddenAvg = hidden.reduce((s, a) => s + a.efficiency, 0) / hidden.length;
    const visibleAvg = visible.reduce((s, a) => s + a.efficiency, 0) / visible.length;
    const hiddenPts = hidden.reduce((s, a) => s + a.points, 0);
    const visiblePts = visible.reduce((s, a) => s + a.points, 0);
    lines.push(`- **Visible:** ${visible.length} achievements, ${visiblePts.toLocaleString()} total pts, ${visibleAvg.toFixed(2)} avg pts/step`);
    lines.push(`- **Hidden:** ${hidden.length} achievements, ${hiddenPts.toLocaleString()} total pts, ${hiddenAvg.toFixed(2)} avg pts/step`);
  }

  lines.push('', `*${achList.length} achievements analyzed.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: OVERSEER AGENT TRAIT-JOB MATRIX ============

export async function getOverseerAgentTraitJobMatrix(): Promise<string> {
  await loadOverseerMinions();
  await loadOverseerEnhancements();
  if (!overseerMinions || overseerMinions.size === 0) return 'Overseer agent data not available.';

  const lines = ['# Overseer Agent Trait-Job Matrix', ''];
  lines.push('*Cross-reference agent traits with jobs to find optimal agent selection.*', '');

  // Collect trait→job associations
  const traitJobCounts = new Map<string, Map<string, number>>(); // trait → jobName → count
  const traitCounts = new Map<string, number>();
  const jobCounts = new Map<string, number>();

  for (const minion of overseerMinions.values()) {
    for (const trait of minion.traits) {
      traitCounts.set(trait, (traitCounts.get(trait) || 0) + 1);
      if (!traitJobCounts.has(trait)) traitJobCounts.set(trait, new Map());
      const tjMap = traitJobCounts.get(trait)!;
      for (const job of minion.jobs) {
        const jobName = overseerJobNames?.get(job.jobTypeId) || `Job ${job.jobTypeId}`;
        jobCounts.set(jobName, (jobCounts.get(jobName) || 0) + 1);
        tjMap.set(jobName, (tjMap.get(jobName) || 0) + 1);
      }
    }
  }

  // Summary
  lines.push('## Overview', '');
  lines.push(`- **Total agents:** ${overseerMinions.size}`);
  lines.push(`- **Unique traits:** ${traitCounts.size}`);
  lines.push(`- **Unique job types:** ${jobCounts.size}`);

  // Top traits
  const sortedTraits = [...traitCounts.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('', '## Most Common Traits', '');
  lines.push('| Trait | Agents | Job Types |');
  lines.push('|-------|------:|----------:|');
  for (const [trait, count] of sortedTraits.slice(0, 20)) {
    const jobTypes = traitJobCounts.get(trait)?.size || 0;
    lines.push(`| ${trait} | ${count} | ${jobTypes} |`);
  }

  // Top jobs
  const sortedJobs = [...jobCounts.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('', '## Job Type Popularity', '');
  lines.push('| Job Type | Agents | % |');
  lines.push('|----------|------:|---:|');
  for (const [job, count] of sortedJobs) {
    const pct = Math.round(count / overseerMinions.size * 100);
    lines.push(`| ${job} | ${count} | ${pct}% |`);
  }

  // Trait-Job matrix (top traits × top jobs)
  const topTraits = sortedTraits.slice(0, 12).map(([t]) => t);
  const topJobs = sortedJobs.slice(0, 8).map(([j]) => j);
  lines.push('', '## Trait × Job Matrix (Top 12 Traits × Top 8 Jobs)', '');
  lines.push(`| Trait | ${topJobs.join(' | ')} |`);
  lines.push(`|-------|${topJobs.map(() => '---:').join('|')}|`);
  for (const trait of topTraits) {
    const tjMap = traitJobCounts.get(trait)!;
    const cells = topJobs.map(j => {
      const count = tjMap.get(j) || 0;
      return count > 0 ? String(count) : '—';
    });
    lines.push(`| ${trait} | ${cells.join(' | ')} |`);
  }

  // Rarest trait-job combos (unique agents)
  lines.push('', '## Rarest Trait-Job Combinations', '');
  lines.push('*Trait-job pairs found in only 1 agent.*', '');
  const rarePairs: { trait: string; job: string }[] = [];
  for (const [trait, tjMap] of traitJobCounts) {
    for (const [job, count] of tjMap) {
      if (count === 1) {
        rarePairs.push({ trait, job });
      }
    }
  }
  lines.push(`- **Rare pairs (count=1):** ${rarePairs.length}`);
  for (const p of rarePairs.slice(0, 15)) {
    lines.push(`  - ${p.trait} + ${p.job}`);
  }
  if (rarePairs.length > 15) lines.push(`  - *(${rarePairs.length - 15} more)*`);

  // Most versatile agents (most jobs)
  const byJobs = [...overseerMinions.values()].sort((a, b) => b.jobs.length - a.jobs.length);
  lines.push('', '## Most Versatile Agents (Most Jobs)', '');
  lines.push('| Agent | Rarity | Traits | Jobs |');
  lines.push('|-------|------:|------:|-----:|');
  for (const m of byJobs.slice(0, 15)) {
    const rarityNames: Record<number, string> = { 1: 'Common', 2: 'Uncommon', 3: 'Rare', 4: 'Elite', 5: 'Legendary' };
    lines.push(`| ${m.fullName} | ${rarityNames[m.rarity] || String(m.rarity)} | ${m.traits.length} | ${m.jobs.length} |`);
  }

  lines.push('', `*${overseerMinions.size} agents analyzed across ${traitCounts.size} traits and ${jobCounts.size} job types.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL DEBUFF COMPARISON BY CLASS ============

export async function getSpellDebuffComparisonByClass(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Debuff Comparison by Class', ''];
  lines.push('*Compare debuff arsenals across all 16 classes.*', '');

  // Define debuff categories by SPA and conditions
  const debuffTypes: { name: string; test: (spa: number, base: number, beneficial: boolean) => boolean }[] = [
    { name: 'Slow (Melee)', test: (spa, _b, ben) => spa === 11 && !ben },
    { name: 'Root', test: (spa) => spa === 99 },
    { name: 'Stun', test: (spa) => spa === 21 },
    { name: 'Mesmerize', test: (spa) => spa === 31 },
    { name: 'Charm', test: (spa) => spa === 22 },
    { name: 'Snare', test: (spa, _b, ben) => spa === 3 && !ben },
    { name: 'HP DoT', test: (spa, base, ben) => spa === 0 && base < 0 && !ben },
    { name: 'Mana Drain', test: (spa, base) => spa === 15 && base < 0 },
    { name: 'Blind', test: (spa) => spa === 20 },
    { name: 'Fear', test: (spa) => spa === 23 },
    { name: 'Silence', test: (spa) => spa === 96 },
    { name: 'Dispel', test: (spa) => spa === 27 },
  ];

  // Count debuff spells per class per type
  const classDebuffs: Map<number, Map<string, number>> = new Map();
  for (let cid = 1; cid <= 16; cid++) classDebuffs.set(cid, new Map());

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    // Parse effect slots
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    const spellDebuffTypes = new Set<string>();

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spa = parseInt(parts[1]);
        const base = parseInt(parts[2]) || 0;
        for (const dt of debuffTypes) {
          if (dt.test(spa, base, beneficial)) {
            spellDebuffTypes.add(dt.name);
          }
        }
      }
    }

    if (spellDebuffTypes.size === 0) continue;

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level >= 1 && level <= 254) {
        const dm = classDebuffs.get(cid)!;
        for (const dt of spellDebuffTypes) {
          dm.set(dt, (dm.get(dt) || 0) + 1);
        }
      }
    }
  }

  // Main comparison table
  lines.push('## Debuff Arsenal by Class', '');
  const dtNames = debuffTypes.map(d => d.name);
  lines.push(`| Class | ${dtNames.join(' | ')} | Total |`);
  lines.push(`|-------|${dtNames.map(() => '---:').join('|')}|------:|`);

  for (let cid = 1; cid <= 16; cid++) {
    const dm = classDebuffs.get(cid)!;
    const cells = dtNames.map(dt => {
      const count = dm.get(dt) || 0;
      return count > 0 ? String(count) : '—';
    });
    const total = [...dm.values()].reduce((s, v) => s + v, 0);
    lines.push(`| ${CLASS_SHORT[cid]} | ${cells.join(' | ')} | ${total} |`);
  }

  // Debuff type rankings
  lines.push('', '## Debuff Type Rankings (Top 3 Classes Each)', '');
  for (const dt of debuffTypes) {
    const classRanks: { cid: number; count: number }[] = [];
    for (let cid = 1; cid <= 16; cid++) {
      const count = classDebuffs.get(cid)!.get(dt.name) || 0;
      if (count > 0) classRanks.push({ cid, count });
    }
    classRanks.sort((a, b) => b.count - a.count);
    if (classRanks.length > 0) {
      const top3 = classRanks.slice(0, 3).map(r => `${CLASS_SHORT[r.cid]} (${r.count})`).join(', ');
      lines.push(`- **${dt.name}:** ${top3}`);
    }
  }

  // Class debuff diversity (how many different debuff types each class has)
  lines.push('', '## Debuff Diversity by Class', '');
  const diversityRanks: { cid: number; types: number; total: number }[] = [];
  for (let cid = 1; cid <= 16; cid++) {
    const dm = classDebuffs.get(cid)!;
    const types = [...dm.values()].filter(v => v > 0).length;
    const total = [...dm.values()].reduce((s, v) => s + v, 0);
    diversityRanks.push({ cid, types, total });
  }
  diversityRanks.sort((a, b) => b.types - a.types || b.total - a.total);
  lines.push('| Rank | Class | Debuff Types | Total Spells |');
  lines.push('|-----:|-------|----------:|------------:|');
  for (let i = 0; i < diversityRanks.length; i++) {
    const d = diversityRanks[i];
    lines.push(`| ${i + 1} | ${CLASS_IDS[d.cid]} (${CLASS_SHORT[d.cid]}) | ${d.types}/12 | ${d.total} |`);
  }

  // Exclusive debuff access (only 1-2 classes)
  lines.push('', '## Rare Debuff Access (1-2 Classes)', '');
  for (const dt of debuffTypes) {
    const hasIt: number[] = [];
    for (let cid = 1; cid <= 16; cid++) {
      if ((classDebuffs.get(cid)!.get(dt.name) || 0) > 0) hasIt.push(cid);
    }
    if (hasIt.length >= 1 && hasIt.length <= 2) {
      lines.push(`- **${dt.name}:** ${hasIt.map(c => `${CLASS_IDS[c]} (${CLASS_SHORT[c]})`).join(', ')}`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CONTENT PROGRESSION PATHWAY ============

export async function getContentProgressionPathway(): Promise<string> {
  await Promise.all([loadSpells(), loadZones(), loadAchievements(), loadAAAbilities()]);
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Content Progression Pathway', ''];
  lines.push('*Milestone levels showing new content unlocked at each tier.*', '');

  const milestones = [1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125];

  // Pre-compute: spells per level per class
  const spellsByLevel = new Map<number, number>(); // level -> total new spells
  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level >= 1 && level <= 125) {
        spellsByLevel.set(level, (spellsByLevel.get(level) || 0) + 1);
      }
    }
  }

  // Zones by level range
  const zonesByLevel = new Map<number, string[]>(); // milestone -> zone names
  if (zones && zones.size > 0) {
    for (const z of zones.values()) {
      if (z.levelMin > 0) {
        for (const ml of milestones) {
          if (z.levelMin <= ml && z.levelMax >= ml) {
            if (!zonesByLevel.has(ml)) zonesByLevel.set(ml, []);
            zonesByLevel.get(ml)!.push(z.name);
          }
        }
      }
    }
  }

  // Summary table
  lines.push('## Content per Milestone Level', '');
  lines.push('| Level | New Spells | Zones Available | Cumulative Spells |');
  lines.push('|------:|----------:|:--------------:|------------------:|');

  let cumulativeSpells = 0;
  for (const ml of milestones) {
    // Count spells at this exact level or in the bracket leading to it
    const prevMl = milestones[milestones.indexOf(ml) - 1] || 0;
    let bracketSpells = 0;
    for (let lv = prevMl + 1; lv <= ml; lv++) {
      bracketSpells += spellsByLevel.get(lv) || 0;
    }
    cumulativeSpells += bracketSpells;
    const zoneCount = zonesByLevel.get(ml)?.length || 0;
    lines.push(`| ${ml} | ${bracketSpells} | ${zoneCount} | ${cumulativeSpells.toLocaleString()} |`);
  }

  // Detail view for key milestones
  const keyMilestones = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 125];
  lines.push('', '## Key Milestone Details', '');

  for (const ml of keyMilestones) {
    lines.push(`### Level ${ml}`, '');

    // Spells at this level by class
    const classSpellCounts: { name: string; count: number }[] = [];
    for (let cid = 1; cid <= 16; cid++) {
      let count = 0;
      for (const spell of spells.values()) {
        if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
        const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
        if (level === ml) count++;
      }
      if (count > 0) classSpellCounts.push({ name: CLASS_SHORT[cid], count });
    }
    classSpellCounts.sort((a, b) => b.count - a.count);
    if (classSpellCounts.length > 0) {
      lines.push(`- **New spells:** ${classSpellCounts.map(c => `${c.name}:${c.count}`).join(', ')}`);
    }

    // Zones at this level
    const levelZones = zonesByLevel.get(ml) || [];
    if (levelZones.length > 0) {
      lines.push(`- **Zones (${levelZones.length}):** ${levelZones.slice(0, 8).join(', ')}${levelZones.length > 8 ? ` (+${levelZones.length - 8} more)` : ''}`);
    }
    lines.push('');
  }

  // Spell density chart
  lines.push('## Spell Density by Level', '');
  const maxSpells = Math.max(...milestones.map(ml => {
    const prevMl = milestones[milestones.indexOf(ml) - 1] || 0;
    let count = 0;
    for (let lv = prevMl + 1; lv <= ml; lv++) count += spellsByLevel.get(lv) || 0;
    return count;
  }));

  for (const ml of milestones) {
    const prevMl = milestones[milestones.indexOf(ml) - 1] || 0;
    let bracketSpells = 0;
    for (let lv = prevMl + 1; lv <= ml; lv++) bracketSpells += spellsByLevel.get(lv) || 0;
    const barLen = maxSpells > 0 ? Math.round(bracketSpells / maxSpells * 40) : 0;
    const bar = '█'.repeat(barLen);
    lines.push(`- **Lv ${String(ml).padStart(3)}-${String(prevMl + 1).padStart(3)}:** ${bar} ${bracketSpells}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL BUFF DURATION TIER LIST ============

export async function getSpellBuffDurationTierList(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Buff Duration Tier List', ''];
  lines.push('*Beneficial spells grouped by duration tier per class.*', '');

  // Duration formula interpretation:
  // Formula 0, value 0 = instant
  // Other formulas compute ticks (6s each)
  // We'll compute approximate duration in seconds
  function computeDurationTicks(formula: number, value: number): number {
    if (formula === 0 && value === 0) return 0;
    if (formula === 1) return value; // value ticks
    if (formula === 2) return Math.floor(value / 2) + 5; // (value/2)+5 ticks
    if (formula === 3) return value * 30; // value * 30 ticks (long)
    if (formula === 4) return 50; // 50 ticks
    if (formula === 5) return 2; // 2 ticks
    if (formula === 6) return Math.floor(value / 2) + 2; // (value/2)+2 ticks
    if (formula === 7) return value; // value ticks
    if (formula === 8) return value + 10; // value+10 ticks
    if (formula === 9) return value * 2 + 10; // 2*value+10 ticks
    if (formula === 10) return value * 3 + 10; // 3*value+10 ticks
    if (formula === 11) return value * 30 + 90; // 30*value+90 ticks
    if (formula === 12) return value; // value ticks
    if (formula === 15) return value; // value ticks (permanent if maintained)
    if (formula === 50) return 72000; // permanent (72000 ticks = many hours)
    if (formula === 3600) return 72000; // permanent marker
    return value > 0 ? value : 0;
  }

  type DurTier = 'Instant' | 'Short (<30s)' | 'Medium (30s-5min)' | 'Long (5-30min)' | 'Very Long (30min+)' | 'Permanent';

  function getTier(ticks: number): DurTier {
    if (ticks <= 0) return 'Instant';
    const seconds = ticks * 6;
    if (seconds < 30) return 'Short (<30s)';
    if (seconds < 300) return 'Medium (30s-5min)';
    if (seconds < 1800) return 'Long (5-30min)';
    if (ticks >= 72000) return 'Permanent';
    return 'Very Long (30min+)';
  }

  const tierOrder: DurTier[] = ['Instant', 'Short (<30s)', 'Medium (30s-5min)', 'Long (5-30min)', 'Very Long (30min+)', 'Permanent'];

  // Count beneficial spells by duration tier per class
  const classTierCounts: Map<number, Map<DurTier, number>> = new Map();
  for (let cid = 1; cid <= 16; cid++) classTierCounts.set(cid, new Map());
  const overallTierCounts = new Map<DurTier, number>();

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    if (spell.fields[SF.BENEFICIAL] !== '1') continue;

    const formula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const value = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    const ticks = computeDurationTicks(formula, value);
    const tier = getTier(ticks);

    overallTierCounts.set(tier, (overallTierCounts.get(tier) || 0) + 1);

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level >= 1 && level <= 254) {
        const m = classTierCounts.get(cid)!;
        m.set(tier, (m.get(tier) || 0) + 1);
      }
    }
  }

  // Overall distribution
  lines.push('## Overall Duration Distribution', '');
  const totalBen = [...overallTierCounts.values()].reduce((s, v) => s + v, 0);
  for (const tier of tierOrder) {
    const count = overallTierCounts.get(tier) || 0;
    const pct = Math.round(count / totalBen * 100);
    const bar = '█'.repeat(Math.min(pct * 2, 40));
    lines.push(`- **${tier}:** ${bar} ${pct}% (${count})`);
  }

  // Per-class table
  lines.push('', '## Duration Tiers by Class', '');
  lines.push(`| Class | ${tierOrder.join(' | ')} | Total |`);
  lines.push(`|-------|${tierOrder.map(() => '---:').join('|')}|------:|`);

  for (let cid = 1; cid <= 16; cid++) {
    const m = classTierCounts.get(cid)!;
    const cells = tierOrder.map(t => String(m.get(t) || 0));
    const total = [...m.values()].reduce((s, v) => s + v, 0);
    lines.push(`| ${CLASS_SHORT[cid]} | ${cells.join(' | ')} | ${total} |`);
  }

  // Buff upkeep rankings (% of long-duration buffs)
  lines.push('', '## Buff Upkeep Profile (% Long/Very Long/Permanent)', '');
  const upkeepRanks: { cid: number; longPct: number; total: number }[] = [];
  for (let cid = 1; cid <= 16; cid++) {
    const m = classTierCounts.get(cid)!;
    const total = [...m.values()].reduce((s, v) => s + v, 0);
    const longCount = (m.get('Long (5-30min)') || 0) + (m.get('Very Long (30min+)') || 0) + (m.get('Permanent') || 0);
    upkeepRanks.push({ cid, longPct: total > 0 ? Math.round(longCount / total * 100) : 0, total });
  }
  upkeepRanks.sort((a, b) => b.longPct - a.longPct);
  lines.push('| Rank | Class | Long+ Buffs % | Total Buffs |');
  lines.push('|-----:|-------|----------:|------------:|');
  for (let i = 0; i < upkeepRanks.length; i++) {
    const r = upkeepRanks[i];
    lines.push(`| ${i + 1} | ${CLASS_IDS[r.cid]} (${CLASS_SHORT[r.cid]}) | ${r.longPct}% | ${r.total} |`);
  }

  lines.push('', `*${totalBen} beneficial spells analyzed across 6 duration tiers.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS HEALING COMPARISON MATRIX ============

export async function getClassHealingComparisonMatrix(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Healing Comparison Matrix', ''];
  lines.push('*Compare healing capabilities across all 16 classes.*', '');

  // Heal types: SPA 0 with positive base and beneficial
  // Categories: Direct Heal, HoT, Group Heal, Cure, Resurrect
  // We'll detect by SPA + target type + category name keywords

  interface HealInfo {
    direct: number;    // SPA 0 positive, non-group target
    hot: number;       // SPA 100 (HoT) or duration > 0 with SPA 0
    group: number;     // Group target with heal
    cure: number;      // SPA 35/36/37 or category contains "Cure"
    resurrect: number; // SPA 82 (resurrect)
  }

  const classHeals: Map<number, HealInfo> = new Map();
  for (let cid = 1; cid <= 16; cid++) {
    classHeals.set(cid, { direct: 0, hot: 0, group: 0, cure: 0, resurrect: 0 });
  }

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    if (spell.fields[SF.BENEFICIAL] !== '1') continue;

    // Parse effect slots
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    let hasHeal = false;
    let hasCure = false;
    let hasRez = false;
    let hasHoTSPA = false;

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spa = parseInt(parts[1]);
        const base = parseInt(parts[2]) || 0;
        if (spa === 0 && base > 0) hasHeal = true;
        if (spa === 100) hasHoTSPA = true; // HoT SPA
        if (spa === 35 || spa === 36 || spa === 37) hasCure = true;
        if (spa === 82) hasRez = true;
      }
    }

    if (!hasHeal && !hasCure && !hasRez && !hasHoTSPA) continue;

    const targetType = spell.fields[SF.TARGET_TYPE] || '';
    const isGroup = targetType === '3' || targetType === '41' || targetType === '40';
    const durFormula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const durValue = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    const hasDuration = durFormula > 0 || durValue > 0;

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;

      const h = classHeals.get(cid)!;
      if (hasRez) h.resurrect++;
      if (hasCure) h.cure++;
      if (hasHeal || hasHoTSPA) {
        if (isGroup) h.group++;
        else if (hasDuration && (hasHoTSPA || hasHeal)) h.hot++;
        else h.direct++;
      }
    }
  }

  // Main comparison table
  lines.push('## Healing Arsenal by Class', '');
  lines.push('| Class | Direct | HoT | Group | Cure | Resurrect | Total |');
  lines.push('|-------|------:|----:|------:|-----:|----------:|------:|');
  for (let cid = 1; cid <= 16; cid++) {
    const h = classHeals.get(cid)!;
    const total = h.direct + h.hot + h.group + h.cure + h.resurrect;
    lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${h.direct} | ${h.hot} | ${h.group} | ${h.cure} | ${h.resurrect} | ${total} |`);
  }

  // Rankings per type
  lines.push('', '## Top Healers by Type', '');
  const healTypes: (keyof HealInfo)[] = ['direct', 'hot', 'group', 'cure', 'resurrect'];
  const healLabels: Record<keyof HealInfo, string> = { direct: 'Direct Heal', hot: 'Heal over Time', group: 'Group Heal', cure: 'Cure', resurrect: 'Resurrect' };
  for (const type of healTypes) {
    const ranked = [];
    for (let cid = 1; cid <= 16; cid++) {
      const count = classHeals.get(cid)![type];
      if (count > 0) ranked.push({ cid, count });
    }
    ranked.sort((a, b) => b.count - a.count);
    if (ranked.length > 0) {
      const top3 = ranked.slice(0, 3).map(r => `${CLASS_SHORT[r.cid]} (${r.count})`).join(', ');
      lines.push(`- **${healLabels[type]}:** ${top3}`);
    }
  }

  // Healing role classification
  lines.push('', '## Healing Role Classification', '');
  for (let cid = 1; cid <= 16; cid++) {
    const h = classHeals.get(cid)!;
    const total = h.direct + h.hot + h.group + h.cure + h.resurrect;
    let role: string;
    if (total >= 100) role = 'Primary Healer';
    else if (total >= 30) role = 'Secondary Healer';
    else if (total >= 5) role = 'Emergency Healer';
    else if (total > 0) role = 'Minimal Healing';
    else role = 'No Healing';
    lines.push(`- **${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}):** ${role} (${total} total heal spells)`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: ZONE-FACTION WEB ANALYSIS ============

export async function getZoneFactionWebAnalysis(): Promise<string> {
  await loadZones();
  await loadFactions();
  if (!zones || zones.size === 0) return 'Zone data not available.';
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Zone-Faction Web Analysis', ''];
  lines.push('*Cross-reference zone names with faction names to discover zone-faction relationships.*', '');

  // Build zone name word index
  interface ZoneMatch { zoneId: number; zoneName: string; factions: { id: number; name: string; category: string }[] }
  const matches: ZoneMatch[] = [];

  for (const zone of zones.values()) {
    if (!zone.name) continue;
    const zoneLower = zone.name.toLowerCase();
    const zoneWords = zoneLower.split(/[\s:,]+/).filter(w => w.length > 3);

    const matchingFactions: { id: number; name: string; category: string }[] = [];
    for (const faction of factions.values()) {
      const facLower = faction.name.toLowerCase();
      // Check if zone name appears in faction name, or key zone words do
      if (facLower.includes(zoneLower) || zoneLower.includes(facLower)) {
        matchingFactions.push({ id: faction.id, name: faction.name, category: faction.category || '' });
      } else {
        // Check significant zone words (not common words)
        const skipWords = new Set(['the', 'of', 'east', 'west', 'north', 'south', 'great', 'upper', 'lower', 'old', 'new']);
        for (const word of zoneWords) {
          if (!skipWords.has(word) && facLower.includes(word)) {
            matchingFactions.push({ id: faction.id, name: faction.name, category: faction.category || '' });
            break;
          }
        }
      }
    }

    if (matchingFactions.length > 0) {
      matches.push({ zoneId: zone.id, zoneName: zone.name, factions: matchingFactions });
    }
  }

  matches.sort((a, b) => b.factions.length - a.factions.length);

  // Summary
  lines.push('## Overview', '');
  lines.push(`- **Zones with faction matches:** ${matches.length} / ${zones.size}`);
  lines.push(`- **Total zone-faction links:** ${matches.reduce((s, m) => s + m.factions.length, 0)}`);

  // Top zones by faction count
  lines.push('', '## Zones with Most Associated Factions', '');
  lines.push('| Zone | Factions | Sample Factions |');
  lines.push('|------|--------:|-----------------|');
  for (const m of matches.slice(0, 25)) {
    const samples = m.factions.slice(0, 3).map(f => f.name).join(', ');
    const more = m.factions.length > 3 ? ` (+${m.factions.length - 3})` : '';
    lines.push(`| ${m.zoneName} | ${m.factions.length} | ${samples}${more} |`);
  }

  // Faction category breakdown for zone-associated factions
  const catCounts = new Map<string, number>();
  for (const m of matches) {
    for (const f of m.factions) {
      const cat = f.category || 'Uncategorized';
      catCounts.set(cat, (catCounts.get(cat) || 0) + 1);
    }
  }
  const sortedCats = [...catCounts.entries()].sort((a, b) => b[1] - a[1]);
  if (sortedCats.length > 0) {
    lines.push('', '## Faction Categories in Zone Matches', '');
    lines.push('| Category | Links |');
    lines.push('|----------|------:|');
    for (const [cat, count] of sortedCats.slice(0, 15)) {
      lines.push(`| ${cat} | ${count} |`);
    }
  }

  // Zones with no faction matches
  const unmatchedZones = [...zones.values()].filter(z => !matches.find(m => m.zoneId === z.id));
  lines.push('', `## Zones Without Faction Matches: ${unmatchedZones.length}`, '');
  if (unmatchedZones.length <= 20) {
    for (const z of unmatchedZones) lines.push(`- ${z.name}`);
  } else {
    for (const z of unmatchedZones.slice(0, 15)) lines.push(`- ${z.name}`);
    lines.push(`- *(${unmatchedZones.length - 15} more)*`);
  }

  // Factions matching most zones
  const factionZoneCounts = new Map<number, { name: string; zoneCount: number }>();
  for (const m of matches) {
    for (const f of m.factions) {
      const existing = factionZoneCounts.get(f.id);
      if (existing) existing.zoneCount++;
      else factionZoneCounts.set(f.id, { name: f.name, zoneCount: 1 });
    }
  }
  const topFactions = [...factionZoneCounts.values()].sort((a, b) => b.zoneCount - a.zoneCount);
  lines.push('', '## Factions Spanning Most Zones', '');
  lines.push('| Faction | Zone Matches |');
  lines.push('|---------|----------:|');
  for (const f of topFactions.slice(0, 20)) {
    lines.push(`| ${f.name} | ${f.zoneCount} |`);
  }

  lines.push('', `*${matches.length} zones linked to ${factionZoneCounts.size} factions.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL DAMAGE EFFICIENCY ============

export async function getSpellDamageEfficiency(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class ID
  const upper = className.toUpperCase();
  let classId = 0;
  for (const [id, short] of Object.entries(CLASS_SHORT)) {
    if (short === upper) { classId = parseInt(id); break; }
  }
  if (!classId) {
    const lower = className.toLowerCase();
    for (const [id, name] of Object.entries(CLASS_IDS)) {
      if (name.toLowerCase() === lower) { classId = parseInt(id); break; }
    }
  }
  if (!classId) return `Error: Unknown class "${className}". Use 3-letter code (WAR, CLR, etc.) or full name.`;

  const lines = [`# Spell Damage Efficiency: ${CLASS_IDS[classId]} (${CLASS_SHORT[classId]})`, ''];
  lines.push('*Damage spells ranked by damage-per-mana (DPM) efficiency.*', '');

  interface DmgSpell {
    id: number;
    name: string;
    level: number;
    mana: number;
    damage: number;
    dpm: number;
    castTime: number;
    category: string;
    isDoT: boolean;
  }

  const dmgSpells: DmgSpell[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    if (spell.fields[SF.BENEFICIAL] === '1') continue; // detrimental only

    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (level < 1 || level > 125) continue;

    const mana = parseInt(spell.fields[SF.MANA]) || 0;
    if (mana <= 0) continue;

    // Parse effect slots for total damage (SPA 0 with negative base = damage)
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    let totalDmg = 0;
    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spa = parseInt(parts[1]);
        const base = parseInt(parts[2]) || 0;
        if (spa === 0 && base < 0) totalDmg += Math.abs(base);
      }
    }
    if (totalDmg <= 0) continue;

    const castTime = (parseInt(spell.fields[SF.CAST_TIME]) || 0) / 1000;
    const durFormula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const durValue = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    const isDoT = durFormula > 0 || durValue > 0;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Category ${catId}`);

    dmgSpells.push({
      id: spell.id,
      name: spell.name,
      level,
      mana,
      damage: totalDmg,
      dpm: totalDmg / mana,
      castTime,
      category: catName,
      isDoT,
    });
  }

  dmgSpells.sort((a, b) => b.dpm - a.dpm);

  lines.push(`**Total damage spells:** ${dmgSpells.length}`, '');

  // Top 30 most efficient
  lines.push('## Top 30 Most Mana-Efficient Damage Spells', '');
  lines.push('| Rank | Spell | Lv | Damage | Mana | DPM | Cast | Type |');
  lines.push('|-----:|-------|---:|------:|-----:|----:|-----:|------|');
  for (let i = 0; i < 30 && i < dmgSpells.length; i++) {
    const s = dmgSpells[i];
    lines.push(`| ${i + 1} | ${s.name} | ${s.level} | ${s.damage.toLocaleString()} | ${s.mana} | ${s.dpm.toFixed(1)} | ${s.castTime.toFixed(1)}s | ${s.isDoT ? 'DoT' : 'DD'} |`);
  }

  // Efficiency by level bracket
  lines.push('', '## Efficiency by Level Bracket', '');
  const brackets = [[1, 20], [21, 40], [41, 60], [61, 80], [81, 100], [101, 125]];
  lines.push('| Bracket | Spells | Avg DPM | Best DPM | Best Spell |');
  lines.push('|---------|------:|--------:|---------:|------------|');
  for (const [lo, hi] of brackets) {
    const inBracket = dmgSpells.filter(s => s.level >= lo && s.level <= hi);
    if (inBracket.length === 0) continue;
    const avgDPM = inBracket.reduce((s, d) => s + d.dpm, 0) / inBracket.length;
    const best = inBracket[0]; // already sorted by DPM
    lines.push(`| ${lo}-${hi} | ${inBracket.length} | ${avgDPM.toFixed(1)} | ${best.dpm.toFixed(1)} | ${best.name} |`);
  }

  // DD vs DoT efficiency comparison
  const dds = dmgSpells.filter(s => !s.isDoT);
  const dots = dmgSpells.filter(s => s.isDoT);
  lines.push('', '## DD vs DoT Efficiency', '');
  if (dds.length > 0) {
    const avgDD = dds.reduce((s, d) => s + d.dpm, 0) / dds.length;
    lines.push(`- **Direct Damage:** ${dds.length} spells, avg DPM ${avgDD.toFixed(1)}, best ${dds[0].name} (${dds[0].dpm.toFixed(1)})`);
  }
  if (dots.length > 0) {
    const avgDoT = dots.reduce((s, d) => s + d.dpm, 0) / dots.length;
    lines.push(`- **DoT:** ${dots.length} spells, avg DPM ${avgDoT.toFixed(1)}, best ${dots[0].name} (${dots[0].dpm.toFixed(1)})`);
  }

  // Category breakdown
  const catCounts = new Map<string, { count: number; avgDPM: number; totalDPM: number }>();
  for (const s of dmgSpells) {
    const existing = catCounts.get(s.category);
    if (existing) {
      existing.count++;
      existing.totalDPM += s.dpm;
      existing.avgDPM = existing.totalDPM / existing.count;
    } else {
      catCounts.set(s.category, { count: 1, avgDPM: s.dpm, totalDPM: s.dpm });
    }
  }
  const sortedCats = [...catCounts.entries()].sort((a, b) => b[1].avgDPM - a[1].avgDPM);
  lines.push('', '## Damage Categories by Avg Efficiency', '');
  lines.push('| Category | Spells | Avg DPM |');
  lines.push('|----------|------:|--------:|');
  for (const [cat, data] of sortedCats.slice(0, 12)) {
    lines.push(`| ${cat} | ${data.count} | ${data.avgDPM.toFixed(1)} |`);
  }

  lines.push('', `*${dmgSpells.length} damage spells analyzed for ${CLASS_IDS[classId]}.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: SEARCH AA BY DESCRIPTION ============

export async function searchAAByDescription(query: string): Promise<string> {
  await loadAAAbilities();
  if (!aaAbilities || aaAbilities.size === 0) return 'AA data not available.';

  const lower = query.toLowerCase();
  const lines = [`# AA Description Search: "${query}"`, ''];

  const matches: { id: number; name: string; desc: string }[] = [];
  for (const aa of aaAbilities.values()) {
    if (aa.description && aa.description.toLowerCase().includes(lower)) {
      matches.push({ id: aa.id, name: aa.name, desc: aa.description });
    }
  }

  if (matches.length === 0) {
    lines.push(`No AAs found with "${query}" in their description.`);
    lines.push('', 'Try broader terms like "haste", "critical", "damage", "heal", "mana", "resist", "stun", "pet".');
    return lines.join('\n');
  }

  lines.push(`**Matches:** ${matches.length}`, '');

  // Group by common name prefix (first word before space or digit)
  const groups = new Map<string, typeof matches>();
  for (const m of matches) {
    const prefix = m.name.replace(/\s*(Rk\.\s*)?[IVX0-9]+$/, '').trim() || m.name;
    const groupName = prefix.split(/\s+/).slice(0, 3).join(' ');
    if (!groups.has(groupName)) groups.set(groupName, []);
    groups.get(groupName)!.push(m);
  }

  // Show results (if too many, group them)
  if (matches.length <= 50) {
    lines.push('| ID | Name | Description (excerpt) |');
    lines.push('|----|------|----------------------|');
    for (const m of matches.slice(0, 50)) {
      const excerpt = m.desc.length > 100 ? m.desc.slice(0, 100) + '...' : m.desc;
      lines.push(`| ${m.id} | ${m.name} | ${excerpt} |`);
    }
  } else {
    // Show grouped
    lines.push(`*${matches.length} matches found — showing grouped by name.*`, '');
    const sortedGroups = [...groups.entries()].sort((a, b) => b[1].length - a[1].length);
    lines.push('| Group | Count | Sample Description |');
    lines.push('|-------|------:|-------------------|');
    for (const [group, items] of sortedGroups.slice(0, 40)) {
      const sample = items[0].desc.length > 80 ? items[0].desc.slice(0, 80) + '...' : items[0].desc;
      lines.push(`| ${group} (${items.map(i => i.name).slice(0, 2).join(', ')}) | ${items.length} | ${sample} |`);
    }
    if (sortedGroups.length > 40) {
      lines.push(`| *(${sortedGroups.length - 40} more groups)* | | |`);
    }
  }

  return lines.join('\n');
}

// ============ PUBLIC API: EXPANSION FACTION TIMELINE ============

export async function getExpansionFactionTimeline(): Promise<string> {
  await loadFactions();
  await loadExpansions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Expansion Faction Timeline', ''];
  lines.push('*Track faction count growth across expansions.*', '');

  // Group factions by category (expansion)
  const catCounts = new Map<string, number>();
  let uncategorized = 0;
  for (const faction of factions.values()) {
    const cat = faction.category || '';
    if (!cat) {
      uncategorized++;
    } else {
      catCounts.set(cat, (catCounts.get(cat) || 0) + 1);
    }
  }

  // Sort by count
  const sorted = [...catCounts.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('## Factions by Expansion/Category', '');
  lines.push('| Rank | Expansion/Category | Factions | % | Cumulative |');
  lines.push('|-----:|-------------------|--------:|---:|----------:|');

  let cumulative = 0;
  for (let i = 0; i < sorted.length; i++) {
    const [cat, count] = sorted[i];
    cumulative += count;
    const pct = Math.round(count / factions.size * 100);
    lines.push(`| ${i + 1} | ${cat} | ${count} | ${pct}% | ${cumulative} |`);
  }
  if (uncategorized > 0) {
    cumulative += uncategorized;
    lines.push(`| — | *(Uncategorized)* | ${uncategorized} | ${Math.round(uncategorized / factions.size * 100)}% | ${cumulative} |`);
  }

  // Visual bar chart
  lines.push('', '## Visual Distribution', '');
  const maxCount = sorted.length > 0 ? sorted[0][1] : 1;
  for (const [cat, count] of sorted) {
    const barLen = Math.round(count / maxCount * 40);
    const bar = '█'.repeat(barLen);
    lines.push(`- **${cat}:** ${bar} ${count}`);
  }

  // Faction starting value analysis by expansion
  lines.push('', '## Starting Value Profile by Expansion', '');
  lines.push('| Expansion | Factions | With Modifiers | Avg Modifiers |');
  lines.push('|-----------|--------:|--------------:|-------------:|');
  for (const [cat, count] of sorted.slice(0, 20)) {
    let withMods = 0;
    let totalMods = 0;
    for (const faction of factions.values()) {
      if ((faction.category || '') !== cat) continue;
      const modCount = faction.startingValues?.length || 0;
      if (modCount > 0) {
        withMods++;
        totalMods += modCount;
      }
    }
    const avgMods = withMods > 0 ? (totalMods / withMods).toFixed(1) : '0';
    lines.push(`| ${cat} | ${count} | ${withMods} | ${avgMods} |`);
  }

  // Most faction-rich expansions
  lines.push('', '## Key Statistics', '');
  lines.push(`- **Total factions:** ${factions.size}`);
  lines.push(`- **Categorized:** ${factions.size - uncategorized} (${Math.round((factions.size - uncategorized) / factions.size * 100)}%)`);
  lines.push(`- **Expansion categories:** ${catCounts.size}`);
  if (sorted.length > 0) {
    lines.push(`- **Most factions:** ${sorted[0][0]} (${sorted[0][1]})`);
    lines.push(`- **Fewest factions:** ${sorted[sorted.length - 1][0]} (${sorted[sorted.length - 1][1]})`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS PET COMPARISON MATRIX ============

export async function getClassPetComparisonMatrix(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Class Pet Comparison Matrix', ''];
  lines.push('*Compare pet capabilities across all 16 classes.*', '');

  // Pet-related SPAs: 33=Summon Pet, 106=Pet Power, 109=Pet HP, 367=Pet Flurry
  // Also: SPA 22=Charm (temporary pet), SPA 71=Summon Swarm Pet
  // Categories: "Pet", "Charm", or names containing "pet", "ward", "swarm"
  const PET_SPAS = new Set([33, 106, 109, 367, 71, 150, 152, 162, 168, 169]);
  // SPA 22 = Charm counts separately

  interface PetInfo {
    summon: number;
    charm: number;
    swarm: number;
    buff: number;   // pet buffs (SPA 106, 109, etc.)
    total: number;
    minLevel: number;
    maxLevel: number;
  }

  const classPets: Map<number, PetInfo> = new Map();
  for (let cid = 1; cid <= 16; cid++) {
    classPets.set(cid, { summon: 0, charm: 0, swarm: 0, buff: 0, total: 0, minLevel: 255, maxLevel: 0 });
  }

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    // Parse effect slots
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    let hasSummon = false, hasCharm = false, hasSwarm = false, hasPetBuff = false;

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spa = parseInt(parts[1]);
        if (spa === 33) hasSummon = true;
        else if (spa === 22) hasCharm = true;
        else if (spa === 71) hasSwarm = true;
        else if (PET_SPAS.has(spa)) hasPetBuff = true;
      }
    }

    if (!hasSummon && !hasCharm && !hasSwarm && !hasPetBuff) continue;

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;

      const p = classPets.get(cid)!;
      if (hasSummon) p.summon++;
      if (hasCharm) p.charm++;
      if (hasSwarm) p.swarm++;
      if (hasPetBuff) p.buff++;
      p.total++;
      if (level < p.minLevel) p.minLevel = level;
      if (level > p.maxLevel) p.maxLevel = level;
    }
  }

  // Main comparison table
  lines.push('## Pet Arsenal by Class', '');
  lines.push('| Class | Summon | Charm | Swarm | Pet Buffs | Total | First Lv | Last Lv |');
  lines.push('|-------|------:|------:|------:|----------:|------:|---------:|--------:|');
  for (let cid = 1; cid <= 16; cid++) {
    const p = classPets.get(cid)!;
    const first = p.minLevel <= 254 ? String(p.minLevel) : '—';
    const last = p.maxLevel > 0 ? String(p.maxLevel) : '—';
    lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${p.summon} | ${p.charm} | ${p.swarm} | ${p.buff} | ${p.total} | ${first} | ${last} |`);
  }

  // Rankings
  lines.push('', '## Pet Class Rankings', '');
  const ranked = [...classPets.entries()].filter(([, p]) => p.total > 0).sort((a, b) => b[1].total - a[1].total);
  for (let i = 0; i < ranked.length; i++) {
    const [cid, p] = ranked[i];
    const types: string[] = [];
    if (p.summon > 0) types.push(`${p.summon} summon`);
    if (p.charm > 0) types.push(`${p.charm} charm`);
    if (p.swarm > 0) types.push(`${p.swarm} swarm`);
    if (p.buff > 0) types.push(`${p.buff} pet buffs`);
    lines.push(`${i + 1}. **${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}):** ${p.total} total — ${types.join(', ')}`);
  }

  // Pet class tier
  lines.push('', '## Pet Class Tiers', '');
  for (let cid = 1; cid <= 16; cid++) {
    const p = classPets.get(cid)!;
    let tier: string;
    if (p.summon >= 20) tier = 'Primary Pet Class';
    else if (p.summon >= 5 || p.charm >= 10) tier = 'Secondary Pet Class';
    else if (p.total >= 5) tier = 'Pet Support';
    else if (p.total > 0) tier = 'Minimal Pet Use';
    else tier = 'No Pets';
    lines.push(`- **${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}):** ${tier}`);
  }

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL RESIST BAR CHART ============

export async function getSpellResistBarChart(resistType: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve resist type
  let resistId = -1;
  const lower = resistType.toLowerCase();
  for (const [id, name] of Object.entries(RESIST_TYPES)) {
    if (name.toLowerCase() === lower || name.toLowerCase().startsWith(lower)) {
      resistId = parseInt(id);
      break;
    }
  }
  if (resistId < 0) {
    resistId = parseInt(resistType);
    if (isNaN(resistId) || !RESIST_TYPES[resistId]) {
      return `Error: Unknown resist type "${resistType}". Valid: ${Object.values(RESIST_TYPES).join(', ')}`;
    }
  }

  const resistName = RESIST_TYPES[resistId];
  const lines = [`# Spell Resist Analysis: ${resistName}`, ''];
  lines.push(`*All ${resistName} spells analyzed across classes and levels.*`, '');

  // Count spells per class
  interface ResistInfo {
    total: number;
    beneficial: number;
    detrimental: number;
    levels: number[];
  }

  const classInfo: Map<number, ResistInfo> = new Map();
  for (let cid = 1; cid <= 16; cid++) {
    classInfo.set(cid, { total: 0, beneficial: 0, detrimental: 0, levels: [] });
  }
  let totalSpells = 0;
  let totalBen = 0;

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const rt = parseInt(spell.fields[SF.RESIST_TYPE]) || 0;
    if (rt !== resistId) continue;

    const isBen = spell.fields[SF.BENEFICIAL] === '1';
    totalSpells++;
    if (isBen) totalBen++;

    for (let cid = 1; cid <= 16; cid++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (level < 1 || level > 254) continue;
      const info = classInfo.get(cid)!;
      info.total++;
      if (isBen) info.beneficial++;
      else info.detrimental++;
      info.levels.push(level);
    }
  }

  lines.push(`**Total ${resistName} spells:** ${totalSpells} (${totalBen} beneficial, ${totalSpells - totalBen} detrimental)`, '');

  // Class distribution table
  lines.push('## Spells by Class', '');
  lines.push('| Class | Total | Beneficial | Detrimental | Min Lv | Max Lv | Avg Lv |');
  lines.push('|-------|------:|-----------:|----------:|-------:|-------:|-------:|');
  for (let cid = 1; cid <= 16; cid++) {
    const info = classInfo.get(cid)!;
    if (info.total === 0) {
      lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | 0 | — | — | — | — | — |`);
    } else {
      const avg = Math.round(info.levels.reduce((s, l) => s + l, 0) / info.levels.length);
      lines.push(`| ${CLASS_IDS[cid]} (${CLASS_SHORT[cid]}) | ${info.total} | ${info.beneficial} | ${info.detrimental} | ${Math.min(...info.levels)} | ${Math.max(...info.levels)} | ${avg} |`);
    }
  }

  // Visual bar chart
  lines.push('', '## Visual Distribution', '');
  const maxCount = Math.max(...[...classInfo.values()].map(i => i.total));
  const sortedClasses = [...classInfo.entries()].sort((a, b) => b[1].total - a[1].total);
  for (const [cid, info] of sortedClasses) {
    if (info.total === 0) continue;
    const barLen = maxCount > 0 ? Math.round(info.total / maxCount * 40) : 0;
    const bar = '█'.repeat(barLen);
    lines.push(`- **${CLASS_SHORT[cid]}:** ${bar} ${info.total}`);
  }

  // Level distribution across brackets
  lines.push('', '## Level Distribution', '');
  const brackets = [[1, 20], [21, 40], [41, 60], [61, 80], [81, 100], [101, 125]];
  lines.push('| Bracket | Spells | % |');
  lines.push('|---------|------:|---:|');
  for (const [lo, hi] of brackets) {
    let count = 0;
    for (const spell of spells.values()) {
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
      if ((parseInt(spell.fields[SF.RESIST_TYPE]) || 0) !== resistId) continue;
      for (let cid = 1; cid <= 16; cid++) {
        const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
        if (level >= lo && level <= hi) { count++; break; }
      }
    }
    const pct = totalSpells > 0 ? Math.round(count / totalSpells * 100) : 0;
    lines.push(`| ${lo}-${hi} | ${count} | ${pct}% |`);
  }

  // Comparison to other resist types
  lines.push('', '## This Resist vs Others', '');
  const otherCounts: { name: string; count: number }[] = [];
  for (const [id, name] of Object.entries(RESIST_TYPES)) {
    let count = 0;
    for (const spell of spells.values()) {
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
      if ((parseInt(spell.fields[SF.RESIST_TYPE]) || 0) === parseInt(id)) count++;
    }
    otherCounts.push({ name, count });
  }
  otherCounts.sort((a, b) => b.count - a.count);
  for (const r of otherCounts) {
    const marker = r.name === resistName ? ' ◄' : '';
    lines.push(`- **${r.name}:** ${r.count}${marker}`);
  }

  lines.push('', `*${totalSpells} ${resistName} spells analyzed.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: OVERSEER QUEST CATEGORY GUIDE ============

export async function getOverseerQuestCategoryGuide(): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerEnhancements();
  if (!overseerQuests || overseerQuests.size === 0) return 'Overseer quest data not available.';

  const lines = ['# Overseer Quest Category Guide', ''];
  lines.push('*Practical guide for each quest category with difficulty, slots, and job requirements.*', '');

  // Group quests by category
  const categories = new Map<string, { quests: OverseerQuest[]; name: string }>();
  for (const quest of overseerQuests.values()) {
    const catName = overseerCategories?.get(quest.categoryId) || `Category ${quest.categoryId}`;
    if (!categories.has(catName)) categories.set(catName, { quests: [], name: catName });
    categories.get(catName)!.quests.push(quest);
  }

  // Summary table
  const sortedCats = [...categories.entries()].sort((a, b) => b[1].quests.length - a[1].quests.length);
  lines.push('## Category Overview', '');
  lines.push('| Category | Quests | Avg Difficulty | Avg Required | Avg Optional | Avg Duration |');
  lines.push('|----------|------:|:-------------:|:-----------:|:-----------:|:-----------:|');

  for (const [catName, data] of sortedCats) {
    const qs = data.quests;
    const avgDiff = (qs.reduce((s, q) => s + q.difficulty, 0) / qs.length).toFixed(1);
    const avgReq = (qs.reduce((s, q) => s + q.requiredSlots, 0) / qs.length).toFixed(1);
    const avgOpt = (qs.reduce((s, q) => s + q.optionalSlots, 0) / qs.length).toFixed(1);
    const avgDur = (qs.reduce((s, q) => s + q.duration, 0) / qs.length).toFixed(0);
    lines.push(`| ${catName} | ${qs.length} | ${avgDiff} | ${avgReq} | ${avgOpt} | ${avgDur}s |`);
  }

  // Detailed per-category
  lines.push('', '## Category Details', '');
  for (const [catName, data] of sortedCats) {
    const qs = data.quests;
    lines.push(`### ${catName} (${qs.length} quests)`, '');

    // Difficulty distribution
    const diffCounts = new Map<number, number>();
    for (const q of qs) diffCounts.set(q.difficulty, (diffCounts.get(q.difficulty) || 0) + 1);
    const diffStr = [...diffCounts.entries()].sort((a, b) => a[0] - b[0]).map(([d, c]) => {
      const name = overseerDifficulties?.get(d) || `D${d}`;
      return `${name}: ${c}`;
    }).join(', ');
    lines.push(`- **Difficulties:** ${diffStr}`);

    // Most needed job types
    const jobCounts = new Map<string, number>();
    for (const q of qs) {
      for (const slot of q.slotDetails) {
        const jobName = overseerJobNames?.get(slot.jobTypeId) || `Job ${slot.jobTypeId}`;
        jobCounts.set(jobName, (jobCounts.get(jobName) || 0) + 1);
      }
    }
    const topJobs = [...jobCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 5);
    lines.push(`- **Top jobs needed:** ${topJobs.map(([j, c]) => `${j} (${c})`).join(', ')}`);

    // Sample quests
    const samples = qs.slice(0, 3).map(q => q.name).join(', ');
    lines.push(`- **Sample quests:** ${samples}`);
    lines.push('');
  }

  lines.push(`*${overseerQuests.size} quests across ${categories.size} categories analyzed.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: SPELL NAME PATTERN ANALYSIS ============

export async function getSpellNamePatternAnalysis(): Promise<string> {
  await loadSpells();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Name Pattern Analysis', ''];
  lines.push('*Analyze spell naming conventions, rank patterns, and spell line prefixes.*', '');

  // Analyze name patterns
  let totalSpells = 0;
  const rankPatterns = new Map<string, number>(); // "Rk. II" -> count
  const prefixes = new Map<string, number>(); // First word -> count
  const suffixes = new Map<string, number>(); // Last word -> count
  const nameLengths: number[] = [];
  const wordCounts: number[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    totalSpells++;

    const name = spell.name;
    nameLengths.push(name.length);
    const words = name.split(/\s+/);
    wordCounts.push(words.length);

    // Detect rank patterns
    const rkMatch = name.match(/(Rk\.\s*(?:II|III|IV|V|VI|VII|VIII|IX|X))\s*$/);
    if (rkMatch) rankPatterns.set(rkMatch[1], (rankPatterns.get(rkMatch[1]) || 0) + 1);

    // Roman numeral suffix
    const romanMatch = name.match(/\s(I{1,3}|IV|V(?:I{0,3})|IX|X)$/);
    if (romanMatch) {
      const suffix = romanMatch[1];
      suffixes.set(suffix, (suffixes.get(suffix) || 0) + 1);
    }

    // First word as prefix
    if (words.length > 0) {
      const prefix = words[0];
      if (prefix.length > 2) {
        prefixes.set(prefix, (prefixes.get(prefix) || 0) + 1);
      }
    }
  }

  lines.push(`**Total valid spells:** ${totalSpells}`, '');

  // Name length statistics
  nameLengths.sort((a, b) => a - b);
  const avgLen = Math.round(nameLengths.reduce((s, l) => s + l, 0) / nameLengths.length);
  lines.push('## Name Statistics', '');
  lines.push(`- **Average name length:** ${avgLen} characters`);
  lines.push(`- **Shortest name:** ${nameLengths[0]} chars`);
  lines.push(`- **Longest name:** ${nameLengths[nameLengths.length - 1]} chars`);
  lines.push(`- **Median:** ${nameLengths[Math.floor(nameLengths.length / 2)]} chars`);
  lines.push(`- **Average word count:** ${(wordCounts.reduce((s, w) => s + w, 0) / wordCounts.length).toFixed(1)} words`);

  // Rank patterns
  const sortedRanks = [...rankPatterns.entries()].sort((a, b) => b[1] - a[1]);
  if (sortedRanks.length > 0) {
    lines.push('', '## Rank Pattern Distribution', '');
    lines.push('| Rank Pattern | Count | % |');
    lines.push('|-------------|------:|---:|');
    let totalRanked = 0;
    for (const [rk, count] of sortedRanks) {
      totalRanked += count;
      lines.push(`| ${rk} | ${count} | ${Math.round(count / totalSpells * 100)}% |`);
    }
    lines.push(`| *(No rank)* | ${totalSpells - totalRanked} | ${Math.round((totalSpells - totalRanked) / totalSpells * 100)}% |`);
  }

  // Top prefixes (spell line names)
  const sortedPrefixes = [...prefixes.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('', '## Most Common First Words (Spell Line Indicators)', '');
  lines.push('| Word | Spells | % |');
  lines.push('|------|------:|---:|');
  for (const [prefix, count] of sortedPrefixes.slice(0, 30)) {
    lines.push(`| ${prefix} | ${count} | ${Math.round(count / totalSpells * 100)}% |`);
  }

  // Suffix patterns
  const sortedSuffixes = [...suffixes.entries()].sort((a, b) => b[1] - a[1]);
  if (sortedSuffixes.length > 0) {
    lines.push('', '## Roman Numeral Suffixes', '');
    lines.push('| Suffix | Count |');
    lines.push('|--------|------:|');
    for (const [suf, count] of sortedSuffixes) {
      lines.push(`| ${suf} | ${count} |`);
    }
  }

  // Name length distribution
  lines.push('', '## Name Length Distribution', '');
  const lenBuckets: Record<string, number> = {
    '1-10': 0, '11-20': 0, '21-30': 0, '31-40': 0, '41+': 0,
  };
  for (const len of nameLengths) {
    if (len <= 10) lenBuckets['1-10']++;
    else if (len <= 20) lenBuckets['11-20']++;
    else if (len <= 30) lenBuckets['21-30']++;
    else if (len <= 40) lenBuckets['31-40']++;
    else lenBuckets['41+']++;
  }
  for (const [bucket, count] of Object.entries(lenBuckets)) {
    const pct = Math.round(count / totalSpells * 100);
    const bar = '█'.repeat(Math.min(pct * 2, 40));
    lines.push(`- **${bucket} chars:** ${bar} ${pct}% (${count})`);
  }

  lines.push('', `*${totalSpells} spell names analyzed.*`);

  return lines.join('\n');
}

// ============ PUBLIC API: ZONE LEVEL GAP ANALYSIS ============

export async function getZoneLevelGapAnalysis(): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const lines = ['# Zone Level Gap Analysis', ''];
  lines.push('*Find level ranges with sparse or no zone coverage.*', '');

  // Count zones per level
  const zonesPerLevel = new Map<number, number>();
  const zoneNamesPerLevel = new Map<number, string[]>();
  for (const zone of zones.values()) {
    if (zone.levelMin <= 0) continue;
    for (let lv = zone.levelMin; lv <= zone.levelMax; lv++) {
      zonesPerLevel.set(lv, (zonesPerLevel.get(lv) || 0) + 1);
      if (!zoneNamesPerLevel.has(lv)) zoneNamesPerLevel.set(lv, []);
      if (zoneNamesPerLevel.get(lv)!.length < 5) zoneNamesPerLevel.get(lv)!.push(zone.name);
    }
  }

  // Coverage chart (1-125)
  lines.push('## Zone Coverage by Level', '');
  lines.push('| Level | Zones | Bar |');
  lines.push('|------:|------:|-----|');
  const maxZones = Math.max(...[...zonesPerLevel.values()]);
  let gapLevels: number[] = [];
  let sparseLevels: number[] = [];

  for (let lv = 1; lv <= 125; lv++) {
    const count = zonesPerLevel.get(lv) || 0;
    if (count === 0) gapLevels.push(lv);
    else if (count <= 3) sparseLevels.push(lv);

    // Show every 5th level and all gaps/sparse
    if (lv % 5 === 0 || count === 0 || count <= 3) {
      const barLen = maxZones > 0 ? Math.round(count / maxZones * 30) : 0;
      const bar = count === 0 ? '⚠️ GAP' : '█'.repeat(barLen);
      lines.push(`| ${lv} | ${count} | ${bar} |`);
    }
  }

  // Gap summary
  lines.push('', '## Level Gaps (No Zones)', '');
  if (gapLevels.length === 0) {
    lines.push('No level gaps found — all levels 1-125 have at least one zone.');
  } else {
    // Group consecutive gaps into ranges
    const ranges: [number, number][] = [];
    let rangeStart = gapLevels[0];
    let rangePrev = gapLevels[0];
    for (let i = 1; i < gapLevels.length; i++) {
      if (gapLevels[i] === rangePrev + 1) {
        rangePrev = gapLevels[i];
      } else {
        ranges.push([rangeStart, rangePrev]);
        rangeStart = gapLevels[i];
        rangePrev = gapLevels[i];
      }
    }
    ranges.push([rangeStart, rangePrev]);

    lines.push(`**Total gap levels:** ${gapLevels.length}`);
    for (const [lo, hi] of ranges) {
      if (lo === hi) lines.push(`- Level ${lo}`);
      else lines.push(`- Levels ${lo}-${hi} (${hi - lo + 1} levels)`);
    }
  }

  // Sparse levels
  lines.push('', '## Sparse Levels (1-3 Zones)', '');
  if (sparseLevels.length === 0) {
    lines.push('All levels have 4+ zones.');
  } else {
    lines.push(`**Sparse levels:** ${sparseLevels.length}`, '');
    // Group consecutive
    const ranges: [number, number][] = [];
    let rangeStart = sparseLevels[0];
    let rangePrev = sparseLevels[0];
    for (let i = 1; i < sparseLevels.length; i++) {
      if (sparseLevels[i] === rangePrev + 1) {
        rangePrev = sparseLevels[i];
      } else {
        ranges.push([rangeStart, rangePrev]);
        rangeStart = sparseLevels[i];
        rangePrev = sparseLevels[i];
      }
    }
    ranges.push([rangeStart, rangePrev]);

    for (const [lo, hi] of ranges) {
      const count = zonesPerLevel.get(lo) || 0;
      if (lo === hi) lines.push(`- Level ${lo} (${count} zones)`);
      else lines.push(`- Levels ${lo}-${hi} (${hi - lo + 1} levels, ${count}-${zonesPerLevel.get(hi) || 0} zones)`);
    }
  }

  // Peak levels (most zones)
  const peakLevels = [...zonesPerLevel.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
  lines.push('', '## Peak Levels (Most Zones)', '');
  lines.push('| Level | Zones | Sample Zones |');
  lines.push('|------:|------:|-------------|');
  for (const [lv, count] of peakLevels) {
    const names = zoneNamesPerLevel.get(lv)?.join(', ') || '';
    lines.push(`| ${lv} | ${count} | ${names} |`);
  }

  // Overall statistics
  const levelsWithZones = [...zonesPerLevel.entries()].filter(([, c]) => c > 0).length;
  lines.push('', '## Statistics', '');
  lines.push(`- **Levels with zones:** ${levelsWithZones}/125`);
  lines.push(`- **Levels without zones:** ${125 - levelsWithZones}`);
  lines.push(`- **Average zones per level:** ${(([...zonesPerLevel.values()].reduce((s, v) => s + v, 0)) / 125).toFixed(1)}`);

  return lines.join('\n');
}

// ============ PUBLIC API: CLASS IDENTITY PROFILE ============

export async function getClassIdentityProfile(className: string): Promise<string> {
  await Promise.all([loadSpells(), loadSpellDescriptions(), loadBaseStats(), loadSkillCaps(), loadACMitigation()]);
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class ID
  const upper = className.toUpperCase();
  let classId = 0;
  for (const [id, short] of Object.entries(CLASS_SHORT)) {
    if (short === upper) { classId = parseInt(id); break; }
  }
  if (!classId) {
    const lower = className.toLowerCase();
    for (const [id, name] of Object.entries(CLASS_IDS)) {
      if (name.toLowerCase() === lower) { classId = parseInt(id); break; }
    }
  }
  if (!classId) return `Error: Unknown class "${className}". Use 3-letter code (WAR, CLR, etc.) or full name.`;

  const lines = [`# Class Identity Profile: ${CLASS_IDS[classId]} (${CLASS_SHORT[classId]})`, ''];
  lines.push('*What makes this class unique — exclusive abilities, best-in-class roles, and identity traits.*', '');

  // Count total and exclusive spells
  let totalSpells = 0;
  let exclusiveSpells = 0;
  const categoryBreakdown = new Map<string, { total: number; exclusive: number }>();
  const effectsUsed = new Set<number>(); // SPA IDs this class uses
  let groupBuffs = 0;
  let heals = 0;
  let nukes = 0;
  let dots = 0;

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (level < 1 || level > 254) continue;

    totalSpells++;

    // Check if exclusive to this class
    let isExclusive = true;
    for (let cid = 1; cid <= 16; cid++) {
      if (cid === classId) continue;
      const otherLv = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (otherLv >= 1 && otherLv <= 254) { isExclusive = false; break; }
    }
    if (isExclusive) exclusiveSpells++;

    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Category ${catId}`);
    if (!categoryBreakdown.has(catName)) categoryBreakdown.set(catName, { total: 0, exclusive: 0 });
    const cb = categoryBreakdown.get(catName)!;
    cb.total++;
    if (isExclusive) cb.exclusive++;

    const isBen = spell.fields[SF.BENEFICIAL] === '1';
    const targetType = spell.fields[SF.TARGET_TYPE] || '';
    if (isBen && (targetType === '3' || targetType === '41')) groupBuffs++;

    // Parse SPA effects
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) { slotsField = i; break; }
    }
    if (slotsField >= 0) {
      const slots = spell.fields[slotsField].split('$');
      for (const slot of slots) {
        const parts = slot.split('|');
        if (parts.length >= 3) {
          const spa = parseInt(parts[1]);
          const base = parseInt(parts[2]) || 0;
          effectsUsed.add(spa);
          if (spa === 0 && base > 0 && isBen) heals++;
          if (spa === 0 && base < 0 && !isBen) {
            const dur = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
            if (dur > 0) dots++; else nukes++;
          }
        }
      }
    }
  }

  // Summary
  lines.push('## Spell Book Summary', '');
  lines.push(`- **Total spells:** ${totalSpells}`);
  lines.push(`- **Exclusive spells:** ${exclusiveSpells} (${Math.round(exclusiveSpells / totalSpells * 100)}%)`);
  lines.push(`- **Group buffs:** ${groupBuffs}`);
  lines.push(`- **Heal spells:** ${heals}`);
  lines.push(`- **Direct damage:** ${nukes}`);
  lines.push(`- **DoT spells:** ${dots}`);
  lines.push(`- **Distinct spell effects (SPAs):** ${effectsUsed.size}`);

  // Top exclusive categories
  const exclusiveCats = [...categoryBreakdown.entries()]
    .filter(([, d]) => d.exclusive > 0)
    .sort((a, b) => b[1].exclusive - a[1].exclusive);
  if (exclusiveCats.length > 0) {
    lines.push('', '## Exclusive Spell Categories', '');
    lines.push('| Category | Exclusive | Total |');
    lines.push('|----------|--------:|------:|');
    for (const [cat, data] of exclusiveCats.slice(0, 15)) {
      lines.push(`| ${cat} | ${data.exclusive} | ${data.total} |`);
    }
  }

  // Base stats at level 125
  if (baseStats && baseStats.length > 0) {
    const stats125 = baseStats.filter(s => s.classId === classId && s.level === 125);
    if (stats125.length > 0) {
      const s = stats125[0];
      lines.push('', '## Base Stats (Level 125)', '');
      lines.push(`- **HP:** ${s.hp.toLocaleString()}`);
      lines.push(`- **Mana:** ${s.mana.toLocaleString()}`);
      lines.push(`- **Endurance:** ${s.endurance.toLocaleString()}`);
      lines.push(`- **HP Regen:** ${s.hpRegen} | **Mana Regen:** ${s.manaRegen} | **End Regen:** ${s.enduranceRegen}`);
    }
  }

  // Top categories by total spell count
  const sortedCats = [...categoryBreakdown.entries()].sort((a, b) => b[1].total - a[1].total);
  lines.push('', '## Top Spell Categories', '');
  lines.push('| Category | Spells | Exclusive |');
  lines.push('|----------|------:|---------:|');
  for (const [cat, data] of sortedCats.slice(0, 12)) {
    lines.push(`| ${cat} | ${data.total} | ${data.exclusive} |`);
  }

  // Role identity
  lines.push('', '## Role Identity', '');
  const roles: string[] = [];
  if (heals > 50) roles.push('Healer');
  if (nukes > 100) roles.push('Nuker');
  if (dots > 50) roles.push('DoT Specialist');
  if (groupBuffs > 50) roles.push('Buffer');
  if (effectsUsed.has(22)) roles.push('Charmer');
  if (effectsUsed.has(33)) roles.push('Pet Master');
  if (effectsUsed.has(21)) roles.push('Stunner');
  if (effectsUsed.has(31)) roles.push('Mezzer');
  if (effectsUsed.has(99)) roles.push('Rooter');
  lines.push(`**Primary Roles:** ${roles.length > 0 ? roles.join(', ') : 'Support'}`);
  lines.push(`**Exclusivity:** ${Math.round(exclusiveSpells / totalSpells * 100)}% of spells are class-exclusive`);

  lines.push('', `*${totalSpells} spells analyzed for ${CLASS_IDS[classId]}.*`);

  return lines.join('\n');
}

// ============ TOOL 228: Spell School Analysis ============
export async function getSpellSchoolAnalysis(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell School Analysis', '', '*Spells grouped by resist type × beneficial/detrimental "school" with class dominance.*', ''];

  // Build schools: resistType + beneficial → class counts
  interface SchoolData {
    resistType: number;
    beneficial: boolean;
    total: number;
    byClass: Map<number, number>;
    categories: Map<string, number>;
  }

  const schools = new Map<string, SchoolData>();

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const resistType = parseInt(spell.fields[SF.RESIST_TYPE]) || 0;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const key = `${resistType}-${beneficial ? 'B' : 'D'}`;

    if (!schools.has(key)) {
      schools.set(key, { resistType, beneficial, total: 0, byClass: new Map(), categories: new Map() });
    }
    const school = schools.get(key)!;
    school.total++;

    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Cat ${catId}`);
    school.categories.set(catName, (school.categories.get(catName) || 0) + 1);

    for (let cid = 1; cid <= 16; cid++) {
      const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (lv >= 1 && lv <= 254) {
        school.byClass.set(cid, (school.byClass.get(cid) || 0) + 1);
      }
    }
  }

  // Sort schools by total spell count
  const sortedSchools = [...schools.values()].sort((a, b) => b.total - a.total);

  // Overview table
  lines.push('## School Overview', '');
  lines.push('| School | Type | Spells | Classes | Top Category |');
  lines.push('|--------|------|------:|--------:|-------------|');
  for (const school of sortedSchools) {
    const resistName = RESIST_TYPES[school.resistType] || `Resist ${school.resistType}`;
    const type = school.beneficial ? 'Buff' : 'Debuff';
    const classCount = school.byClass.size;
    const topCat = [...school.categories.entries()].sort((a, b) => b[1] - a[1])[0];
    lines.push(`| ${resistName} | ${type} | ${school.total} | ${classCount} | ${topCat ? topCat[0] : '-'} |`);
  }

  // Top 8 schools — class dominance detail
  lines.push('', '## Class Dominance by School (Top 8)', '');
  for (const school of sortedSchools.slice(0, 8)) {
    const resistName = RESIST_TYPES[school.resistType] || `Resist ${school.resistType}`;
    const type = school.beneficial ? 'Buff' : 'Debuff';
    lines.push(`### ${resistName} ${type}s (${school.total} spells)`, '');

    // Rank classes
    const classRanking = [...school.byClass.entries()]
      .sort((a, b) => b[1] - a[1]);
    if (classRanking.length > 0) {
      lines.push('| Rank | Class | Spells | Share |');
      lines.push('|-----:|-------|------:|------:|');
      let rank = 1;
      for (const [cid, count] of classRanking.slice(0, 10)) {
        const pct = Math.round(count / school.total * 100);
        lines.push(`| ${rank} | ${CLASS_SHORT[cid] || `C${cid}`} | ${count} | ${pct}% |`);
        rank++;
      }
    }

    // Top categories
    const topCats = [...school.categories.entries()].sort((a, b) => b[1] - a[1]).slice(0, 5);
    if (topCats.length > 0) {
      lines.push('', '**Top categories:** ' + topCats.map(([name, count]) => `${name} (${count})`).join(', '));
    }
    lines.push('');
  }

  // Cross-school class specialization
  lines.push('## Class School Specialization', '');
  lines.push('| Class | Strongest School | Spells | 2nd School | Spells |');
  lines.push('|-------|-----------------|------:|-----------|------:|');
  for (let cid = 1; cid <= 16; cid++) {
    const classSchools: { name: string; count: number }[] = [];
    for (const school of sortedSchools) {
      const count = school.byClass.get(cid) || 0;
      if (count > 0) {
        const resistName = RESIST_TYPES[school.resistType] || `R${school.resistType}`;
        const type = school.beneficial ? 'Buff' : 'Debuff';
        classSchools.push({ name: `${resistName} ${type}`, count });
      }
    }
    classSchools.sort((a, b) => b.count - a.count);
    const s1 = classSchools[0];
    const s2 = classSchools[1];
    lines.push(`| ${CLASS_SHORT[cid] || `C${cid}`} | ${s1?.name || '-'} | ${s1?.count || 0} | ${s2?.name || '-'} | ${s2?.count || 0} |`);
  }

  lines.push('', `*${sortedSchools.length} schools analyzed across ${spells.size} spells.*`);
  return lines.join('\n');
}

// ============ TOOL 229: AA-Spell Category Correlation ============
export async function getAASpellCorrelation(): Promise<string> {
  await loadAAAbilities();
  await loadSpells();
  await loadSpellDescriptions();
  if (!aaAbilities || aaAbilities.size === 0) return 'AA ability data not available.';
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# AA-Spell Category Correlation', '', '*Cross-reference AA ability descriptions with spell categories and effect types.*', ''];

  // Build spell category list
  const categoryNames = new Set<string>();
  if (spellCategories) {
    for (const name of spellCategories.values()) {
      categoryNames.add(name.toLowerCase());
    }
  }

  // Build SPA name list (lowercased for matching)
  const spaKeywords: { keyword: string; spaId: number; name: string }[] = [];
  for (const [id, name] of Object.entries(SPA_NAMES)) {
    const words = name.toLowerCase().split(/[\s\/]+/).filter(w => w.length >= 3);
    for (const word of words) {
      spaKeywords.push({ keyword: word, spaId: parseInt(id), name });
    }
  }

  // Spell effect keywords commonly referenced in AA descriptions
  const effectKeywords = [
    'heal', 'nuke', 'damage', 'haste', 'slow', 'mez', 'mesmerize', 'charm', 'root',
    'snare', 'stun', 'dot', 'damage over time', 'rune', 'ward', 'shield',
    'resist', 'critical', 'crit', 'proc', 'trigger', 'twincast',
    'mana', 'endurance', 'pet', 'summon', 'teleport', 'gate',
    'aggro', 'hate', 'taunt', 'backstab', 'kick', 'bash',
    'parry', 'dodge', 'riposte', 'block', 'avoidance',
    'flurry', 'double attack', 'triple attack',
    'fear', 'blind', 'silence', 'dispel', 'cure',
    'buff', 'debuff', 'aura', 'illusion',
    'regeneration', 'regen', 'lifetap',
  ];

  // Match AAs to effect keywords
  const keywordMatches = new Map<string, { aaCount: number; aaSamples: string[] }>();
  const categoryMatches = new Map<string, { aaCount: number; aaSamples: string[] }>();

  for (const aa of aaAbilities.values()) {
    const descLower = (aa.description + ' ' + aa.name).toLowerCase();

    // Match effect keywords
    for (const kw of effectKeywords) {
      if (descLower.includes(kw)) {
        if (!keywordMatches.has(kw)) {
          keywordMatches.set(kw, { aaCount: 0, aaSamples: [] });
        }
        const match = keywordMatches.get(kw)!;
        match.aaCount++;
        if (match.aaSamples.length < 3) match.aaSamples.push(aa.name);
      }
    }

    // Match spell category names
    for (const catName of categoryNames) {
      if (catName.length >= 4 && descLower.includes(catName)) {
        if (!categoryMatches.has(catName)) {
          categoryMatches.set(catName, { aaCount: 0, aaSamples: [] });
        }
        const match = categoryMatches.get(catName)!;
        match.aaCount++;
        if (match.aaSamples.length < 2) match.aaSamples.push(aa.name);
      }
    }
  }

  // Effect keyword matches
  const sortedKeywords = [...keywordMatches.entries()].sort((a, b) => b[1].aaCount - a[1].aaCount);
  lines.push('## AA-Spell Effect Keyword Matches', '');
  lines.push('| Keyword | AAs Referencing | Sample AAs |');
  lines.push('|---------|---------------:|-----------|');
  for (const [kw, data] of sortedKeywords.slice(0, 30)) {
    lines.push(`| ${kw} | ${data.aaCount} | ${data.aaSamples.join(', ')} |`);
  }

  // Category matches
  const sortedCategories = [...categoryMatches.entries()].sort((a, b) => b[1].aaCount - a[1].aaCount);
  if (sortedCategories.length > 0) {
    lines.push('', '## AA-Spell Category Name Matches', '');
    lines.push('| Category | AAs Referencing | Sample AAs |');
    lines.push('|----------|---------------:|-----------|');
    for (const [cat, data] of sortedCategories.slice(0, 20)) {
      lines.push(`| ${cat} | ${data.aaCount} | ${data.aaSamples.join(', ')} |`);
    }
  }

  // Multi-keyword AAs (AAs that reference 3+ effect keywords)
  lines.push('', '## Multi-Effect AAs (3+ keyword matches)', '');
  const multiEffect: { name: string; keywords: string[]; desc: string }[] = [];
  for (const aa of aaAbilities.values()) {
    const descLower = (aa.description + ' ' + aa.name).toLowerCase();
    const matched: string[] = [];
    for (const kw of effectKeywords) {
      if (descLower.includes(kw)) matched.push(kw);
    }
    if (matched.length >= 3) {
      multiEffect.push({ name: aa.name, keywords: matched, desc: aa.description.slice(0, 80) });
    }
  }
  multiEffect.sort((a, b) => b.keywords.length - a.keywords.length);

  if (multiEffect.length > 0) {
    lines.push('| AA Name | Keywords | Description |');
    lines.push('|---------|---------|------------|');
    for (const me of multiEffect.slice(0, 20)) {
      lines.push(`| ${me.name} | ${me.keywords.join(', ')} | ${me.desc}... |`);
    }
  }

  // Summary stats
  const totalAAs = aaAbilities.size;
  const aasWithEffectRef = new Set<number>();
  for (const aa of aaAbilities.values()) {
    const descLower = (aa.description + ' ' + aa.name).toLowerCase();
    for (const kw of effectKeywords) {
      if (descLower.includes(kw)) {
        aasWithEffectRef.add(aa.id);
        break;
      }
    }
  }

  lines.push('', '## Summary', '');
  lines.push(`- **Total AAs:** ${totalAAs}`);
  lines.push(`- **AAs referencing spell effects:** ${aasWithEffectRef.size} (${Math.round(aasWithEffectRef.size / totalAAs * 100)}%)`);
  lines.push(`- **Distinct effect keywords matched:** ${sortedKeywords.length}`);
  lines.push(`- **Spell categories found in AA text:** ${sortedCategories.length}`);
  lines.push(`- **Multi-effect AAs (3+ keywords):** ${multiEffect.length}`);

  lines.push('', `*${totalAAs} AA abilities cross-referenced with ${effectKeywords.length} effect keywords and ${categoryNames.size} spell categories.*`);
  return lines.join('\n');
}

// ============ TOOL 230: Class Defensive Profile ============
export async function getClassDefensiveProfile(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  await loadBaseStats();
  await loadACMitigation();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class
  const classNameUpper = className.toUpperCase().trim();
  let classId = 0;
  for (const [id, short] of Object.entries(CLASS_SHORT)) {
    if (short === classNameUpper) { classId = parseInt(id); break; }
  }
  if (!classId) {
    for (const [id, name] of Object.entries(CLASS_IDS)) {
      if (name.toUpperCase() === classNameUpper) { classId = parseInt(id); break; }
    }
  }
  if (!classId) return `Unknown class: "${className}". Use 3-letter code (WAR, CLR) or full name (Warrior, Cleric).`;

  const fullName = CLASS_IDS[classId];
  const lines = [`# Class Defensive Profile: ${fullName} (${CLASS_SHORT[classId]})`, '', '*Defensive capabilities analysis — runes, heals, AC, resists, damage shields, and defensive cooldowns.*', ''];

  // Defensive SPA categories
  const defensiveCategories: Record<string, number[]> = {
    'Rune/Absorb': [55, 54, 63, 97],       // Damage absorb, Stoneskin, Magic absorb, Spell shield
    'Heal': [0],                             // HP (positive base = heal)
    'HP Regen': [34, 69],                    // HP Regen, Max HP
    'AC Buff': [1],                          // AC
    'Fire Resist': [46],
    'Cold Resist': [47],
    'Poison Resist': [48],
    'Disease Resist': [49],
    'Magic Resist': [50],
    'Damage Shield': [87, 89],               // Damage Shield, Reverse DS
    'Cure': [36, 77],                        // Dispel Magic, Dispel Detrimental
    'Fade/Aggro': [92, 68],                  // Adjust aggro, Feign Death
    'Root/Snare': [99, 3],                   // Root (self defensive use), Snare
    'Stun': [21],
    'Mez': [31, 74],
    'Fear': [23],
  };

  // Scan all class spells for defensive effects
  interface DefSpell {
    id: number;
    name: string;
    level: number;
    beneficial: boolean;
    category: string;
    defTypes: string[];
    base1Values: Map<string, number>;
  }

  const defSpells: DefSpell[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (lv < 1 || lv > 254) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    // Parse effect slots
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    const foundDef: string[] = [];
    const baseValues = new Map<string, number>();

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length < 3) continue;
      const spaId = parseInt(parts[1]);
      const base1 = parseInt(parts[2]) || 0;

      for (const [defName, spaIds] of Object.entries(defensiveCategories)) {
        if (spaIds.includes(spaId)) {
          // For heals, only count beneficial spells with positive HP effect
          if (defName === 'Heal' && (!beneficial || base1 <= 0)) continue;
          // For HP regen, only count beneficial
          if (defName === 'HP Regen' && !beneficial) continue;
          // For AC/resist buffs, only count beneficial
          if (['AC Buff', 'Fire Resist', 'Cold Resist', 'Poison Resist', 'Disease Resist', 'Magic Resist'].includes(defName) && !beneficial) continue;

          if (!foundDef.includes(defName)) {
            foundDef.push(defName);
            baseValues.set(defName, base1);
          }
        }
      }
    }

    if (foundDef.length > 0) {
      const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
      const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Cat ${catId}`);
      defSpells.push({ id: spell.id, name: spell.name, level: lv, beneficial, category: catName, defTypes: foundDef, base1Values: baseValues });
    }
  }

  lines.push(`**Total defensive spells:** ${defSpells.length}`, '');

  // Breakdown by defensive type
  lines.push('## Defensive Capability Breakdown', '');
  lines.push('| Category | Spells | Level Range | Max Value |');
  lines.push('|----------|------:|:------------|----------:|');

  const typeOrder = Object.keys(defensiveCategories);
  for (const defType of typeOrder) {
    const matching = defSpells.filter(s => s.defTypes.includes(defType));
    if (matching.length === 0) continue;
    const levels = matching.map(s => s.level);
    const minLv = Math.min(...levels);
    const maxLv = Math.max(...levels);
    const maxBase = Math.max(...matching.map(s => Math.abs(s.base1Values.get(defType) || 0)));
    lines.push(`| ${defType} | ${matching.length} | ${minLv}-${maxLv} | ${maxBase > 0 ? maxBase.toLocaleString() : '-'} |`);
  }

  // Top defensive spells by level
  lines.push('', '## Top Defensive Spells (Highest Level)', '');
  const sorted = [...defSpells].sort((a, b) => b.level - a.level);
  lines.push('| Level | Spell | Types | Category |');
  lines.push('|------:|-------|-------|----------|');
  const seen = new Set<string>();
  let shown = 0;
  for (const s of sorted) {
    if (seen.has(s.name)) continue;
    seen.add(s.name);
    lines.push(`| ${s.level} | ${s.name} | ${s.defTypes.join(', ')} | ${s.category} |`);
    shown++;
    if (shown >= 20) break;
  }

  // Multi-defense spells (spells with 2+ defensive types)
  const multiDef = defSpells.filter(s => s.defTypes.length >= 2)
    .sort((a, b) => b.defTypes.length - a.defTypes.length || b.level - a.level);
  if (multiDef.length > 0) {
    lines.push('', '## Multi-Defense Spells (2+ defensive effects)', '');
    lines.push('| Spell | Level | Effects | Category |');
    lines.push('|-------|------:|---------|----------|');
    const multiSeen = new Set<string>();
    let mShown = 0;
    for (const s of multiDef) {
      if (multiSeen.has(s.name)) continue;
      multiSeen.add(s.name);
      lines.push(`| ${s.name} | ${s.level} | ${s.defTypes.join(', ')} | ${s.category} |`);
      mShown++;
      if (mShown >= 15) break;
    }
  }

  // AC and base stats at 125
  if (baseStats && baseStats.length > 0) {
    const stats125 = baseStats.filter(s => s.classId === classId && s.level === 125);
    if (stats125.length > 0) {
      const s = stats125[0];
      lines.push('', '## Base Defensive Stats (Level 125)', '');
      lines.push(`- **HP:** ${s.hp.toLocaleString()}`);
      lines.push(`- **HP Regen:** ${s.hpRegen}`);
      lines.push(`- **Mana:** ${s.mana.toLocaleString()}`);
      lines.push(`- **Endurance:** ${s.endurance.toLocaleString()}`);
    }
  }

  if (acMitigation && acMitigation.length > 0) {
    const ac125 = acMitigation.filter(a => a.classId === classId && a.level === 125);
    if (ac125.length > 0) {
      const ac = ac125[0];
      lines.push(`- **AC Soft Cap:** ${ac.acCap}`);
      lines.push(`- **AC Multiplier:** ${ac.softCapMultiplier}`);
    }
  }

  // Defensive rating summary
  lines.push('', '## Defensive Rating Summary', '');
  const healCount = defSpells.filter(s => s.defTypes.includes('Heal')).length;
  const runeCount = defSpells.filter(s => s.defTypes.includes('Rune/Absorb')).length;
  const acBuffCount = defSpells.filter(s => s.defTypes.includes('AC Buff')).length;
  const dsCount = defSpells.filter(s => s.defTypes.includes('Damage Shield')).length;
  const resistTotal = defSpells.filter(s =>
    s.defTypes.some(d => d.includes('Resist'))
  ).length;
  const ccCount = defSpells.filter(s =>
    s.defTypes.some(d => ['Stun', 'Mez', 'Fear', 'Root/Snare'].includes(d))
  ).length;
  const fadeCount = defSpells.filter(s => s.defTypes.includes('Fade/Aggro')).length;

  lines.push(`| Aspect | Count | Rating |`);
  lines.push(`|--------|------:|--------|`);
  const rate = (count: number, thresholds: number[]): string => {
    if (count >= thresholds[2]) return 'Excellent';
    if (count >= thresholds[1]) return 'Good';
    if (count >= thresholds[0]) return 'Basic';
    return 'None';
  };
  lines.push(`| Self-Healing | ${healCount} | ${rate(healCount, [5, 20, 50])} |`);
  lines.push(`| Rune/Absorb | ${runeCount} | ${rate(runeCount, [5, 15, 30])} |`);
  lines.push(`| AC Buffs | ${acBuffCount} | ${rate(acBuffCount, [3, 10, 20])} |`);
  lines.push(`| Damage Shields | ${dsCount} | ${rate(dsCount, [2, 5, 10])} |`);
  lines.push(`| Resist Buffs | ${resistTotal} | ${rate(resistTotal, [5, 15, 30])} |`);
  lines.push(`| Crowd Control | ${ccCount} | ${rate(ccCount, [5, 15, 30])} |`);
  lines.push(`| Fade/Aggro Mgmt | ${fadeCount} | ${rate(fadeCount, [1, 3, 5])} |`);

  lines.push('', `*${defSpells.length} defensive spells analyzed for ${fullName}.*`);
  return lines.join('\n');
}

// ============ TOOL 231: Spell Category Co-occurrence ============
export async function getSpellCategoryCooccurrence(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Category Co-occurrence Analysis', '', '*Which spell categories tend to appear together in class spell books.*', ''];

  // Build per-class category sets
  const classCats = new Map<number, Map<string, number>>();
  for (let cid = 1; cid <= 16; cid++) classCats.set(cid, new Map());

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    if (catId === 0) continue;
    const catName = spellCategories?.get(catId) || `Cat ${catId}`;

    for (let cid = 1; cid <= 16; cid++) {
      const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (lv >= 1 && lv <= 254) {
        const cats = classCats.get(cid)!;
        cats.set(catName, (cats.get(catName) || 0) + 1);
      }
    }
  }

  // Find top categories across all classes
  const globalCatCounts = new Map<string, number>();
  for (const [, cats] of classCats) {
    for (const [cat, count] of cats) {
      globalCatCounts.set(cat, (globalCatCounts.get(cat) || 0) + count);
    }
  }
  const topCats = [...globalCatCounts.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 20)
    .map(([name]) => name);

  // Co-occurrence matrix: count how many classes have BOTH categories
  lines.push('## Category Co-occurrence Matrix (classes sharing both)', '');
  const pairCounts = new Map<string, number>();
  for (const cat1 of topCats) {
    for (const cat2 of topCats) {
      if (cat1 >= cat2) continue;
      let shared = 0;
      for (let cid = 1; cid <= 16; cid++) {
        const cats = classCats.get(cid)!;
        if (cats.has(cat1) && cats.has(cat2)) shared++;
      }
      if (shared > 0) {
        pairCounts.set(`${cat1} + ${cat2}`, shared);
      }
    }
  }

  // Top co-occurring pairs
  const sortedPairs = [...pairCounts.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('### Most Common Category Pairs', '');
  lines.push('| Category Pair | Classes | Universality |');
  lines.push('|---------------|--------:|:------------|');
  for (const [pair, count] of sortedPairs.slice(0, 25)) {
    const pct = Math.round(count / 16 * 100);
    const label = pct === 100 ? 'Universal' : pct >= 75 ? 'Widespread' : pct >= 50 ? 'Common' : 'Specialized';
    lines.push(`| ${pair} | ${count}/16 | ${label} |`);
  }

  // Rare pairs (only 1-2 classes)
  const rarePairs = sortedPairs.filter(([, count]) => count <= 2 && count > 0);
  if (rarePairs.length > 0) {
    lines.push('', '### Rare Category Pairs (1-2 classes)', '');
    lines.push('| Category Pair | Classes | Which Classes |');
    lines.push('|---------------|--------:|:-------------|');
    for (const [pair, count] of rarePairs.slice(0, 15)) {
      const [cat1, cat2] = pair.split(' + ');
      const which: string[] = [];
      for (let cid = 1; cid <= 16; cid++) {
        const cats = classCats.get(cid)!;
        if (cats.has(cat1) && cats.has(cat2)) {
          which.push(CLASS_SHORT[cid] || `C${cid}`);
        }
      }
      lines.push(`| ${pair} | ${count}/16 | ${which.join(', ')} |`);
    }
  }

  // Per-class category diversity
  lines.push('', '## Class Category Diversity', '');
  lines.push('| Class | Categories | Top 3 Categories |');
  lines.push('|-------|----------:|:-----------------|');
  for (let cid = 1; cid <= 16; cid++) {
    const cats = classCats.get(cid)!;
    const sortedCats = [...cats.entries()].sort((a, b) => b[1] - a[1]);
    const top3 = sortedCats.slice(0, 3).map(([name, count]) => `${name} (${count})`).join(', ');
    lines.push(`| ${CLASS_SHORT[cid] || `C${cid}`} | ${cats.size} | ${top3} |`);
  }

  // Exclusive categories (only 1 class has them)
  const catToClasses = new Map<string, number[]>();
  for (let cid = 1; cid <= 16; cid++) {
    for (const cat of classCats.get(cid)!.keys()) {
      if (!catToClasses.has(cat)) catToClasses.set(cat, []);
      catToClasses.get(cat)!.push(cid);
    }
  }
  const exclusiveCats = [...catToClasses.entries()].filter(([, cls]) => cls.length === 1);
  if (exclusiveCats.length > 0) {
    lines.push('', '## Class-Exclusive Categories', '');
    lines.push('| Category | Class | Spells |');
    lines.push('|----------|-------|------:|');
    for (const [cat, cls] of exclusiveCats.sort((a, b) => {
      const countA = classCats.get(a[1][0])!.get(a[0]) || 0;
      const countB = classCats.get(b[1][0])!.get(b[0]) || 0;
      return countB - countA;
    }).slice(0, 20)) {
      const count = classCats.get(cls[0])!.get(cat) || 0;
      lines.push(`| ${cat} | ${CLASS_SHORT[cls[0]] || `C${cls[0]}`} | ${count} |`);
    }
  }

  lines.push('', `*${topCats.length} top categories analyzed across 16 classes.*`);
  return lines.join('\n');
}

// ============ TOOL 232: Class Mana Profile ============
export async function getClassManaProfile(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  await loadBaseStats();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class
  const classNameUpper = className.toUpperCase().trim();
  let classId = 0;
  for (const [id, short] of Object.entries(CLASS_SHORT)) {
    if (short === classNameUpper) { classId = parseInt(id); break; }
  }
  if (!classId) {
    for (const [id, name] of Object.entries(CLASS_IDS)) {
      if (name.toUpperCase() === classNameUpper) { classId = parseInt(id); break; }
    }
  }
  if (!classId) return `Unknown class: "${className}". Use 3-letter code (WAR, CLR) or full name (Warrior, Cleric).`;

  const fullName = CLASS_IDS[classId];
  const lines = [`# Class Mana/Endurance Profile: ${fullName} (${CLASS_SHORT[classId]})`, '', '*Resource efficiency analysis — costs vs pools at various levels.*', ''];

  // Gather spells with mana or endurance costs
  interface CostSpell {
    name: string;
    level: number;
    manaCost: number;
    endCost: number;
    beneficial: boolean;
    category: string;
  }

  const costSpells: CostSpell[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (lv < 1 || lv > 254) continue;

    const manaCost = parseInt(spell.fields[SF.MANA]) || 0;
    const endCost = parseInt(spell.fields[SF.ENDURANCE]) || 0;
    if (manaCost <= 0 && endCost <= 0) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Cat ${catId}`);

    costSpells.push({ name: spell.name, level: lv, manaCost, endCost, beneficial, category: catName });
  }

  lines.push(`**Total spells/abilities with resource cost:** ${costSpells.length}`, '');

  // Mana vs endurance split
  const manaSpells = costSpells.filter(s => s.manaCost > 0);
  const endSpells = costSpells.filter(s => s.endCost > 0);
  lines.push(`- **Mana-cost spells:** ${manaSpells.length}`);
  lines.push(`- **Endurance-cost abilities:** ${endSpells.length}`);

  // Cost distribution by level bracket
  const brackets = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 125];
  lines.push('', '## Mana Cost by Level Bracket', '');
  lines.push('| Level | Spells | Avg Mana | Max Mana | Pool | Casts at Max |');
  lines.push('|------:|------:|--------:|--------:|-----:|------------:|');

  for (let i = 0; i < brackets.length - 1; i++) {
    const minLv = brackets[i];
    const maxLv = brackets[i + 1] - 1;
    const bracketSpells = manaSpells.filter(s => s.level >= minLv && s.level <= maxLv);
    if (bracketSpells.length === 0) continue;

    const avgMana = Math.round(bracketSpells.reduce((sum, s) => sum + s.manaCost, 0) / bracketSpells.length);
    const maxMana = Math.max(...bracketSpells.map(s => s.manaCost));

    // Find mana pool at max bracket level
    let pool = 0;
    if (baseStats && baseStats.length > 0) {
      const stat = baseStats.filter(s => s.classId === classId && s.level === maxLv);
      if (stat.length > 0) pool = stat[0].mana;
    }
    const casts = maxMana > 0 && pool > 0 ? Math.floor(pool / maxMana) : 0;

    lines.push(`| ${minLv}-${maxLv} | ${bracketSpells.length} | ${avgMana} | ${maxMana.toLocaleString()} | ${pool > 0 ? pool.toLocaleString() : '-'} | ${casts > 0 ? casts : '-'} |`);
  }

  // Endurance cost analysis if applicable
  if (endSpells.length > 0) {
    lines.push('', '## Endurance Cost by Level Bracket', '');
    lines.push('| Level | Abilities | Avg End | Max End | Pool | Casts at Max |');
    lines.push('|------:|--------:|-------:|-------:|-----:|------------:|');

    for (let i = 0; i < brackets.length - 1; i++) {
      const minLv = brackets[i];
      const maxLv = brackets[i + 1] - 1;
      const bracketSpells = endSpells.filter(s => s.level >= minLv && s.level <= maxLv);
      if (bracketSpells.length === 0) continue;

      const avgEnd = Math.round(bracketSpells.reduce((sum, s) => sum + s.endCost, 0) / bracketSpells.length);
      const maxEnd = Math.max(...bracketSpells.map(s => s.endCost));

      let pool = 0;
      if (baseStats && baseStats.length > 0) {
        const stat = baseStats.filter(s => s.classId === classId && s.level === maxLv);
        if (stat.length > 0) pool = stat[0].endurance;
      }
      const casts = maxEnd > 0 && pool > 0 ? Math.floor(pool / maxEnd) : 0;

      lines.push(`| ${minLv}-${maxLv} | ${bracketSpells.length} | ${avgEnd} | ${maxEnd.toLocaleString()} | ${pool > 0 ? pool.toLocaleString() : '-'} | ${casts > 0 ? casts : '-'} |`);
    }
  }

  // Most expensive spells
  lines.push('', '## Most Expensive Spells (by mana)', '');
  const topMana = [...manaSpells].sort((a, b) => b.manaCost - a.manaCost);
  if (topMana.length > 0) {
    lines.push('| Spell | Level | Mana | Category | Type |');
    lines.push('|-------|------:|-----:|----------|------|');
    const seenNames = new Set<string>();
    let shown = 0;
    for (const s of topMana) {
      if (seenNames.has(s.name)) continue;
      seenNames.add(s.name);
      lines.push(`| ${s.name} | ${s.level} | ${s.manaCost.toLocaleString()} | ${s.category} | ${s.beneficial ? 'Buff' : 'Debuff'} |`);
      shown++;
      if (shown >= 15) break;
    }
  }

  // Cost by category
  lines.push('', '## Average Mana Cost by Category', '');
  const catCosts = new Map<string, { total: number; count: number }>();
  for (const s of manaSpells) {
    if (!catCosts.has(s.category)) catCosts.set(s.category, { total: 0, count: 0 });
    const c = catCosts.get(s.category)!;
    c.total += s.manaCost;
    c.count++;
  }
  const sortedCatCosts = [...catCosts.entries()]
    .map(([cat, data]) => ({ cat, avg: Math.round(data.total / data.count), count: data.count }))
    .sort((a, b) => b.avg - a.avg);

  lines.push('| Category | Spells | Avg Mana |');
  lines.push('|----------|------:|--------:|');
  for (const { cat, avg, count } of sortedCatCosts.slice(0, 15)) {
    lines.push(`| ${cat} | ${count} | ${avg.toLocaleString()} |`);
  }

  // Resource pool at key levels
  if (baseStats && baseStats.length > 0) {
    lines.push('', '## Resource Pool Milestones', '');
    lines.push('| Level | HP | Mana | Endurance | Mana Regen |');
    lines.push('|------:|---:|-----:|----------:|-----------:|');
    for (const lv of [1, 10, 25, 50, 65, 75, 85, 100, 115, 125]) {
      const stat = baseStats.filter(s => s.classId === classId && s.level === lv);
      if (stat.length > 0) {
        const s = stat[0];
        lines.push(`| ${lv} | ${s.hp.toLocaleString()} | ${s.mana.toLocaleString()} | ${s.endurance.toLocaleString()} | ${s.manaRegen} |`);
      }
    }
  }

  lines.push('', `*${costSpells.length} spells with resource costs analyzed for ${fullName}.*`);
  return lines.join('\n');
}

// ============ TOOL 233: Overseer Agent Job Coverage Optimizer ============
export async function getOverseerAgentJobCoverageOptimizer(): Promise<string> {
  await loadOverseerMinions();
  await loadOverseerQuests();
  await loadOverseerEnhancements();
  if (!overseerMinions || overseerMinions.size === 0) return 'Overseer agent data not available.';
  if (!overseerQuests || overseerQuests.size === 0) return 'Overseer quest data not available.';

  const lines = ['# Overseer Agent Job Coverage Optimizer', '', '*Which agents cover the most quest slot requirements.*', ''];

  // Count job demand across all quests
  const jobDemand = new Map<number, { required: number; optional: number }>();
  for (const quest of overseerQuests.values()) {
    for (const slot of quest.slotDetails) {
      if (!jobDemand.has(slot.jobTypeId)) {
        jobDemand.set(slot.jobTypeId, { required: 0, optional: 0 });
      }
      const demand = jobDemand.get(slot.jobTypeId)!;
      if (slot.isRequired) demand.required++;
      else demand.optional++;
    }
  }

  // Job demand ranking
  const sortedJobs = [...jobDemand.entries()]
    .map(([jobId, data]) => ({
      jobId,
      name: overseerJobNames?.get(jobId) || `Job ${jobId}`,
      required: data.required,
      optional: data.optional,
      total: data.required + data.optional
    }))
    .sort((a, b) => b.total - a.total);

  lines.push('## Job Demand Ranking', '');
  lines.push('| Rank | Job | Required | Optional | Total Demand |');
  lines.push('|-----:|-----|--------:|--------:|------------:|');
  let rank = 1;
  for (const job of sortedJobs.slice(0, 20)) {
    lines.push(`| ${rank} | ${job.name} | ${job.required} | ${job.optional} | ${job.total} |`);
    rank++;
  }

  // Score each agent by how much demand they can fill
  interface AgentScore {
    id: number;
    name: string;
    jobs: { jobName: string; level: number }[];
    totalDemand: number;
    requiredDemand: number;
    traits: string[];
  }

  const agentScores: AgentScore[] = [];
  for (const agent of overseerMinions.values()) {
    let totalDemand = 0;
    let requiredDemand = 0;
    const jobDetails: { jobName: string; level: number }[] = [];

    for (const job of agent.jobs) {
      const demand = jobDemand.get(job.jobTypeId);
      if (demand) {
        totalDemand += demand.required + demand.optional;
        requiredDemand += demand.required;
        jobDetails.push({
          jobName: overseerJobNames?.get(job.jobTypeId) || `Job ${job.jobTypeId}`,
          level: job.level
        });
      }
    }

    agentScores.push({
      id: agent.id,
      name: agent.shortName || agent.fullName,
      jobs: jobDetails,
      totalDemand,
      requiredDemand,
      traits: agent.traits
    });
  }

  // Top agents by total demand coverage
  agentScores.sort((a, b) => b.totalDemand - a.totalDemand);

  lines.push('', '## Top Agents by Quest Coverage', '');
  lines.push('| Rank | Agent | Jobs | Total Coverage | Required Coverage | Traits |');
  lines.push('|-----:|-------|-----:|-------------:|------------------:|--------|');
  const seenNames = new Set<string>();
  let shown = 0;
  for (const agent of agentScores) {
    if (seenNames.has(agent.name)) continue;
    seenNames.add(agent.name);
    const jobStr = agent.jobs.map(j => `${j.jobName} L${j.level}`).join(', ');
    const traitStr = agent.traits.slice(0, 3).join(', ');
    lines.push(`| ${shown + 1} | ${agent.name} | ${agent.jobs.length} | ${agent.totalDemand} | ${agent.requiredDemand} | ${traitStr} |`);
    shown++;
    if (shown >= 20) break;
  }

  // Job coverage gaps — jobs with high demand but few agents
  lines.push('', '## Job Coverage Analysis', '');
  const jobAgentCount = new Map<number, number>();
  for (const agent of overseerMinions.values()) {
    for (const job of agent.jobs) {
      jobAgentCount.set(job.jobTypeId, (jobAgentCount.get(job.jobTypeId) || 0) + 1);
    }
  }

  lines.push('| Job | Demand | Agents Available | Demand/Agent Ratio |');
  lines.push('|-----|------:|----------------:|---------:|');
  const jobAnalysis = sortedJobs.map(job => ({
    ...job,
    agents: jobAgentCount.get(job.jobId) || 0,
    ratio: (job.total / Math.max(1, jobAgentCount.get(job.jobId) || 0)).toFixed(1)
  })).sort((a, b) => parseFloat(b.ratio) - parseFloat(a.ratio));

  for (const job of jobAnalysis.slice(0, 15)) {
    lines.push(`| ${job.name} | ${job.total} | ${job.agents} | ${job.ratio} |`);
  }

  // Multi-job agents (most versatile)
  lines.push('', '## Most Versatile Agents (Most Jobs)', '');
  const versatile = [...agentScores]
    .sort((a, b) => b.jobs.length - a.jobs.length);

  lines.push('| Agent | Jobs | Job List |');
  lines.push('|-------|-----:|---------|');
  const vSeen = new Set<string>();
  let vShown = 0;
  for (const agent of versatile) {
    if (vSeen.has(agent.name)) continue;
    vSeen.add(agent.name);
    lines.push(`| ${agent.name} | ${agent.jobs.length} | ${agent.jobs.map(j => j.jobName).join(', ')} |`);
    vShown++;
    if (vShown >= 15) break;
  }

  lines.push('', '## Summary', '');
  lines.push(`- **Total agents:** ${overseerMinions.size}`);
  lines.push(`- **Total quests:** ${overseerQuests.size}`);
  lines.push(`- **Distinct jobs in demand:** ${jobDemand.size}`);
  lines.push(`- **Highest demand job:** ${sortedJobs[0]?.name || '-'} (${sortedJobs[0]?.total || 0} slots)`);
  lines.push(`- **Most versatile agent:** ${versatile[0]?.name || '-'} (${versatile[0]?.jobs.length || 0} jobs)`);

  lines.push('', `*${overseerMinions.size} agents scored against ${overseerQuests.size} quests.*`);
  return lines.join('\n');
}

// ============ TOOL 234: Class Offensive Profile ============
export async function getClassOffensiveProfile(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  await loadBaseStats();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class
  const classNameUpper = className.toUpperCase().trim();
  let classId = 0;
  for (const [id, short] of Object.entries(CLASS_SHORT)) {
    if (short === classNameUpper) { classId = parseInt(id); break; }
  }
  if (!classId) {
    for (const [id, name] of Object.entries(CLASS_IDS)) {
      if (name.toUpperCase() === classNameUpper) { classId = parseInt(id); break; }
    }
  }
  if (!classId) return `Unknown class: "${className}". Use 3-letter code (WAR, CLR) or full name (Warrior, Cleric).`;

  const fullName = CLASS_IDS[classId];
  const lines = [`# Class Offensive Profile: ${fullName} (${CLASS_SHORT[classId]})`, '', '*Offensive capabilities — nukes, DoTs, debuffs, AE damage, procs with rating summary.*', ''];

  // Offensive SPA categories
  const offensiveCategories: Record<string, { spas: number[]; detrimental: boolean; negativeBase?: boolean }> = {
    'Direct Damage': { spas: [0], detrimental: true, negativeBase: true },
    'DoT': { spas: [0], detrimental: true, negativeBase: true },
    'Slow': { spas: [11], detrimental: true },
    'Debuff AC': { spas: [1], detrimental: true },
    'Debuff ATK': { spas: [2], detrimental: true },
    'Debuff STR': { spas: [4], detrimental: true },
    'Snare': { spas: [3], detrimental: true },
    'Root': { spas: [99], detrimental: true },
    'Stun': { spas: [21], detrimental: true },
    'Mez': { spas: [31, 74], detrimental: true },
    'Charm': { spas: [22], detrimental: true },
    'Fear': { spas: [23], detrimental: true },
    'Blind': { spas: [20], detrimental: true },
    'Silence': { spas: [96], detrimental: true },
    'Mana Drain': { spas: [15], detrimental: true },
    'Damage Shield': { spas: [87], detrimental: false },
    'Proc': { spas: [85], detrimental: false },
  };

  interface OffSpell {
    id: number;
    name: string;
    level: number;
    category: string;
    offTypes: string[];
    isAE: boolean;
    base1: number;
  }

  const offSpells: OffSpell[] = [];
  const ddSpells: OffSpell[] = [];
  const dotSpells: OffSpell[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (lv < 1 || lv > 254) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const isAE = [2, 4, 8, 40, 42, 44, 46].includes(targetType);

    // Parse duration for DD vs DoT classification
    const durFormula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const durValue = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    const isInstant = durFormula === 0 || (durFormula === 50 && durValue === 0);

    // Parse effect slots
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    const foundOff: string[] = [];
    let maxBase = 0;

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length < 3) continue;
      const spaId = parseInt(parts[1]);
      const base1 = parseInt(parts[2]) || 0;

      for (const [offName, config] of Object.entries(offensiveCategories)) {
        if (!config.spas.includes(spaId)) continue;

        // Check detrimental requirement
        if (config.detrimental && beneficial) continue;
        if (!config.detrimental && !beneficial) continue;

        // For HP effect (SPA 0), distinguish DD vs DoT
        if (spaId === 0 && base1 < 0 && !beneficial) {
          if (offName === 'Direct Damage' && isInstant) {
            if (!foundOff.includes('Direct Damage')) {
              foundOff.push('Direct Damage');
              maxBase = Math.max(maxBase, Math.abs(base1));
            }
          } else if (offName === 'DoT' && !isInstant) {
            if (!foundOff.includes('DoT')) {
              foundOff.push('DoT');
              maxBase = Math.max(maxBase, Math.abs(base1));
            }
          }
        } else if (spaId !== 0) {
          if (!foundOff.includes(offName)) {
            foundOff.push(offName);
            maxBase = Math.max(maxBase, Math.abs(base1));
          }
        }
      }
    }

    if (foundOff.length > 0) {
      const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
      const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Cat ${catId}`);
      const offSpell: OffSpell = { id: spell.id, name: spell.name, level: lv, category: catName, offTypes: foundOff, isAE, base1: maxBase };
      offSpells.push(offSpell);
      if (foundOff.includes('Direct Damage')) ddSpells.push(offSpell);
      if (foundOff.includes('DoT')) dotSpells.push(offSpell);
    }
  }

  lines.push(`**Total offensive spells:** ${offSpells.length}`, '');

  // Breakdown by offensive type
  lines.push('## Offensive Capability Breakdown', '');
  lines.push('| Category | Spells | AE Spells | Level Range | Max Effect |');
  lines.push('|----------|------:|--------:|:------------|----------:|');

  const typeOrder = Object.keys(offensiveCategories);
  for (const offType of typeOrder) {
    const matching = offSpells.filter(s => s.offTypes.includes(offType));
    if (matching.length === 0) continue;
    const aeCount = matching.filter(s => s.isAE).length;
    const levels = matching.map(s => s.level);
    const minLv = Math.min(...levels);
    const maxLv = Math.max(...levels);
    const maxEffect = Math.max(...matching.map(s => s.base1));
    lines.push(`| ${offType} | ${matching.length} | ${aeCount} | ${minLv}-${maxLv} | ${maxEffect > 0 ? maxEffect.toLocaleString() : '-'} |`);
  }

  // Top nukes
  if (ddSpells.length > 0) {
    lines.push('', '## Top Direct Damage Spells', '');
    const sortedDD = [...ddSpells].sort((a, b) => b.base1 - a.base1);
    lines.push('| Spell | Level | Damage | AE | Category |');
    lines.push('|-------|------:|------:|:--:|----------|');
    const seenDD = new Set<string>();
    let ddShown = 0;
    for (const s of sortedDD) {
      if (seenDD.has(s.name)) continue;
      seenDD.add(s.name);
      lines.push(`| ${s.name} | ${s.level} | ${s.base1.toLocaleString()} | ${s.isAE ? 'Yes' : '-'} | ${s.category} |`);
      ddShown++;
      if (ddShown >= 12) break;
    }
  }

  // Top DoTs
  if (dotSpells.length > 0) {
    lines.push('', '## Top DoT Spells', '');
    const sortedDoT = [...dotSpells].sort((a, b) => b.base1 - a.base1);
    lines.push('| Spell | Level | Per Tick | Category |');
    lines.push('|-------|------:|--------:|----------|');
    const seenDoT = new Set<string>();
    let dotShown = 0;
    for (const s of sortedDoT) {
      if (seenDoT.has(s.name)) continue;
      seenDoT.add(s.name);
      lines.push(`| ${s.name} | ${s.level} | ${s.base1.toLocaleString()} | ${s.category} |`);
      dotShown++;
      if (dotShown >= 12) break;
    }
  }

  // Offensive rating summary
  lines.push('', '## Offensive Rating Summary', '');
  const ddCount = ddSpells.length;
  const dotCount = dotSpells.length;
  const slowCount = offSpells.filter(s => s.offTypes.includes('Slow')).length;
  const stunCount = offSpells.filter(s => s.offTypes.includes('Stun')).length;
  const mezCount = offSpells.filter(s => s.offTypes.includes('Mez')).length;
  const aeCount = offSpells.filter(s => s.isAE).length;
  const procCount = offSpells.filter(s => s.offTypes.includes('Proc')).length;

  const rate = (count: number, thresholds: number[]): string => {
    if (count >= thresholds[2]) return 'Excellent';
    if (count >= thresholds[1]) return 'Good';
    if (count >= thresholds[0]) return 'Basic';
    return 'None';
  };

  lines.push('| Aspect | Count | Rating |');
  lines.push('|--------|------:|--------|');
  lines.push(`| Direct Damage | ${ddCount} | ${rate(ddCount, [5, 20, 50])} |`);
  lines.push(`| DoT | ${dotCount} | ${rate(dotCount, [5, 15, 30])} |`);
  lines.push(`| AE Damage | ${aeCount} | ${rate(aeCount, [5, 15, 30])} |`);
  lines.push(`| Slow | ${slowCount} | ${rate(slowCount, [1, 3, 8])} |`);
  lines.push(`| Stun | ${stunCount} | ${rate(stunCount, [3, 10, 20])} |`);
  lines.push(`| Mez | ${mezCount} | ${rate(mezCount, [3, 8, 15])} |`);
  lines.push(`| Procs | ${procCount} | ${rate(procCount, [2, 5, 10])} |`);

  lines.push('', `*${offSpells.length} offensive spells analyzed for ${fullName}.*`);
  return lines.join('\n');
}

// ============ TOOL 235: Spell Target-Effect Matrix ============
export async function getSpellTargetEffectMatrix(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines = ['# Spell Target Type × Effect Matrix', '', '*How spell effects distribute across target types.*', ''];

  // Track target type + SPA combinations
  const targetEffectMatrix = new Map<string, Map<number, number>>(); // targetName -> (spaId -> count)
  const targetTotals = new Map<string, number>();
  const spaTotals = new Map<number, number>();

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;

    const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const targetName = TARGET_TYPES[targetType] || `Target ${targetType}`;

    // Check if any class can use it
    let usable = false;
    for (let cid = 1; cid <= 16; cid++) {
      const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
      if (lv >= 1 && lv <= 254) { usable = true; break; }
    }
    if (!usable) continue;

    // Parse effects
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const slots = spell.fields[slotsField].split('$');
    const seenSPA = new Set<number>();

    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length < 3) continue;
      const spaId = parseInt(parts[1]);
      if (spaId === 254 || spaId === 10 || seenSPA.has(spaId)) continue; // skip blank/limit/dupes
      seenSPA.add(spaId);

      if (!targetEffectMatrix.has(targetName)) targetEffectMatrix.set(targetName, new Map());
      const row = targetEffectMatrix.get(targetName)!;
      row.set(spaId, (row.get(spaId) || 0) + 1);

      spaTotals.set(spaId, (spaTotals.get(spaId) || 0) + 1);
    }

    targetTotals.set(targetName, (targetTotals.get(targetName) || 0) + 1);
  }

  // Top target types
  const sortedTargets = [...targetTotals.entries()].sort((a, b) => b[1] - a[1]);
  lines.push('## Target Type Distribution', '');
  lines.push('| Target Type | Spells | Top Effects |');
  lines.push('|-------------|------:|:-----------|');
  for (const [target, count] of sortedTargets.slice(0, 15)) {
    const effects = targetEffectMatrix.get(target)!;
    const topEffects = [...effects.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([spa, c]) => `${SPA_NAMES[spa] || `SPA${spa}`} (${c})`);
    lines.push(`| ${target} | ${count} | ${topEffects.join(', ')} |`);
  }

  // Top SPAs — which target types use them most
  const topSPAs = [...spaTotals.entries()].sort((a, b) => b[1] - a[1]).slice(0, 15);
  lines.push('', '## Top Effects by Target Preference', '');
  lines.push('| Effect | Total | Primary Target | % | Secondary Target | % |');
  lines.push('|--------|------:|:--------------|---:|:----------------|---:|');

  for (const [spa, total] of topSPAs) {
    const spaName = SPA_NAMES[spa] || `SPA ${spa}`;
    const targetCounts: { name: string; count: number }[] = [];
    for (const [target, effects] of targetEffectMatrix) {
      const count = effects.get(spa) || 0;
      if (count > 0) targetCounts.push({ name: target, count });
    }
    targetCounts.sort((a, b) => b.count - a.count);
    const t1 = targetCounts[0];
    const t2 = targetCounts[1];
    lines.push(`| ${spaName} | ${total} | ${t1?.name || '-'} | ${t1 ? Math.round(t1.count / total * 100) : 0}% | ${t2?.name || '-'} | ${t2 ? Math.round(t2.count / total * 100) : 0}% |`);
  }

  // AE-specific effects (which effects are most common in AE spells)
  const aeTargets = ['PB AE', 'Targeted AE', 'Directional AE', 'Beam', 'AE (PC v1)', 'AE (PC v2)', 'Target Ring AE'];
  const aeEffects = new Map<number, number>();
  let totalAE = 0;
  for (const target of aeTargets) {
    const effects = targetEffectMatrix.get(target);
    if (effects) {
      totalAE += targetTotals.get(target) || 0;
      for (const [spa, count] of effects) {
        aeEffects.set(spa, (aeEffects.get(spa) || 0) + count);
      }
    }
  }

  if (totalAE > 0) {
    lines.push('', '## AE-Specific Effects', '');
    lines.push('| Effect | AE Spells | % of Total Effect Uses |');
    lines.push('|--------|--------:|------------:|');
    const sortedAE = [...aeEffects.entries()].sort((a, b) => b[1] - a[1]);
    for (const [spa, count] of sortedAE.slice(0, 12)) {
      const totalSpa = spaTotals.get(spa) || 1;
      const pct = Math.round(count / totalSpa * 100);
      lines.push(`| ${SPA_NAMES[spa] || `SPA ${spa}`} | ${count} | ${pct}% |`);
    }
  }

  lines.push('', `*${sortedTargets.length} target types and ${topSPAs.length} top effects analyzed.*`);
  return lines.join('\n');
}

// ============ TOOL 236: Achievement Expansion Timeline ============
export async function getAchievementExpansionTimeline(): Promise<string> {
  await loadAchievements();
  await loadAchievementCategories();
  await loadAchievementComponents();
  if (!achievements || achievements.size === 0) return 'Achievement data not available.';
  if (!achievementCategories || achievementCategories.size === 0) return 'Achievement category data not available.';

  const lines = ['# Achievement Expansion Timeline', '', '*Achievement growth across expansions — point density, category evolution, and content trends.*', ''];

  // Map top-level categories to expansion names
  // Top-level categories (parentId === 0) are usually expansion names
  const topLevelCats = [...achievementCategories.values()]
    .filter(c => c.parentId === 0)
    .sort((a, b) => a.order - b.order);

  // For each top-level category, count achievements, points, subcategories
  interface ExpansionAch {
    name: string;
    catId: number;
    achievementCount: number;
    totalPoints: number;
    subcategories: number;
    components: number;
    hiddenCount: number;
  }

  const expansionData: ExpansionAch[] = [];

  for (const topCat of topLevelCats) {
    // Find all subcategories
    const subCats = [...achievementCategories.values()].filter(c => c.parentId === topCat.id);

    // Collect all achievement IDs under this top-level category (direct + subcategories)
    const allCatIds = [topCat.id, ...subCats.map(s => s.id)];
    let achCount = 0;
    let totalPoints = 0;
    let componentCount = 0;
    let hiddenCount = 0;

    for (const catId of allCatIds) {
      const achIds = categoryToAchievements?.get(catId) || [];
      for (const achId of achIds) {
        const ach = achievements.get(achId);
        if (ach) {
          achCount++;
          totalPoints += ach.points;
          if (ach.hidden) hiddenCount++;
          const comps = achievementComponents?.get(ach.id);
          if (comps) componentCount += comps.length;
        }
      }
    }

    if (achCount > 0) {
      expansionData.push({
        name: topCat.name,
        catId: topCat.id,
        achievementCount: achCount,
        totalPoints,
        subcategories: subCats.length,
        components: componentCount,
        hiddenCount
      });
    }
  }

  // Timeline table
  lines.push('## Achievement Timeline', '');
  lines.push('| Expansion | Achievements | Points | Sub-categories | Components | Hidden |');
  lines.push('|-----------|:-----------:|------:|:-----------:|----------:|------:|');

  let cumulativeAch = 0;
  let cumulativePoints = 0;
  for (const exp of expansionData) {
    cumulativeAch += exp.achievementCount;
    cumulativePoints += exp.totalPoints;
    lines.push(`| ${exp.name} | ${exp.achievementCount} | ${exp.totalPoints} | ${exp.subcategories} | ${exp.components} | ${exp.hiddenCount} |`);
  }

  // Cumulative growth
  lines.push('', '## Cumulative Growth', '');
  lines.push('| Expansion | Cumulative Achs | Cumulative Points | Avg Points/Ach |');
  lines.push('|-----------|:--------------:|:----------------:|:---------:|');
  let runAch = 0;
  let runPoints = 0;
  for (const exp of expansionData) {
    runAch += exp.achievementCount;
    runPoints += exp.totalPoints;
    const avg = runAch > 0 ? (runPoints / runAch).toFixed(1) : '0';
    lines.push(`| ${exp.name} | ${runAch} | ${runPoints} | ${avg} |`);
  }

  // Point density analysis
  lines.push('', '## Point Density Analysis', '');
  const densities = expansionData
    .map(e => ({ name: e.name, density: e.achievementCount > 0 ? (e.totalPoints / e.achievementCount).toFixed(1) : '0', count: e.achievementCount, points: e.totalPoints }))
    .sort((a, b) => parseFloat(b.density) - parseFloat(a.density));

  lines.push('| Expansion | Points/Achievement | Achievements | Total Points |');
  lines.push('|-----------|:---------:|:-----------:|:-----------:|');
  for (const d of densities.slice(0, 15)) {
    lines.push(`| ${d.name} | ${d.density} | ${d.count} | ${d.points} |`);
  }

  // Complexity analysis (components per achievement)
  lines.push('', '## Complexity Analysis (Steps per Achievement)', '');
  const complexity = expansionData
    .filter(e => e.components > 0)
    .map(e => ({ name: e.name, avg: (e.components / e.achievementCount).toFixed(1), total: e.components, count: e.achievementCount }))
    .sort((a, b) => parseFloat(b.avg) - parseFloat(a.avg));

  lines.push('| Expansion | Avg Steps/Ach | Total Steps | Achievements |');
  lines.push('|-----------|:-----:|----------:|:-----------:|');
  for (const c of complexity.slice(0, 15)) {
    lines.push(`| ${c.name} | ${c.avg} | ${c.total} | ${c.count} |`);
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Total expansions with achievements:** ${expansionData.length}`);
  lines.push(`- **Total achievements:** ${cumulativeAch}`);
  lines.push(`- **Total points:** ${cumulativePoints}`);
  const biggest = expansionData.sort((a, b) => b.achievementCount - a.achievementCount)[0];
  if (biggest) lines.push(`- **Largest expansion:** ${biggest.name} (${biggest.achievementCount} achievements, ${biggest.totalPoints} points)`);
  const densest = densities[0];
  if (densest) lines.push(`- **Highest point density:** ${densest.name} (${densest.density} points/achievement)`);

  lines.push('', `*${cumulativeAch} achievements across ${expansionData.length} expansions analyzed.*`);
  return lines.join('\n');
}

// ============ TOOL 237: Item Effect Category Breakdown ============
export async function getItemEffectCategoryBreakdown(): Promise<string> {
  await loadDbStrings([DBSTR_TYPES.ITEM_EFFECT_DESC]);
  const descs = dbStrings?.get(DBSTR_TYPES.ITEM_EFFECT_DESC) || new Map();
  if (descs.size === 0) return 'Item effect data not available.';

  const lines = ['# Item Effect Category Breakdown', '', '*Classify item click/proc effects into functional categories.*', ''];

  // Define categories by keyword
  const categoryKeywords: Record<string, string[]> = {
    'Offensive (Damage)': ['damage', 'nuke', 'strike', 'blast', 'bolt', 'fire', 'ice', 'frost', 'shock', 'burn', 'smite', 'wrath'],
    'Healing': ['heal', 'cure', 'remedy', 'mend', 'restoration', 'rejuvenation', 'regeneration', 'resurrect'],
    'Defensive (Buff)': ['shield', 'ward', 'protection', 'armor', 'fortif', 'resist', 'guard', 'absorb', 'rune', 'block'],
    'Haste/Speed': ['haste', 'speed', 'quickness', 'celerity', 'alacrity', 'velocity'],
    'Stat Boost': ['strength', 'stamina', 'agility', 'dexterity', 'intelligence', 'wisdom', 'charisma', 'attack'],
    'Mana/Endurance': ['mana', 'endurance', 'clarity', 'focus'],
    'Movement/Travel': ['teleport', 'gate', 'levitat', 'invis', 'shrink', 'grow', 'bind', 'evacuate', 'succor'],
    'Crowd Control': ['stun', 'root', 'snare', 'slow', 'mez', 'charm', 'fear', 'calm', 'pacif'],
    'Pet/Summon': ['pet', 'summon', 'companion', 'familiar', 'minion', 'swarm'],
    'Illusion': ['illusion', 'form of', 'disguise', 'morph'],
    'Utility': ['identify', 'sense', 'detect', 'see invis', 'ultravision', 'infravision', 'water breath', 'endure'],
    'Food/Drink': ['food', 'drink', 'water', 'ration', 'sustenance', 'nourish'],
  };

  const categorized = new Map<string, { count: number; samples: string[] }>();
  for (const cat of Object.keys(categoryKeywords)) {
    categorized.set(cat, { count: 0, samples: [] });
  }
  categorized.set('Uncategorized', { count: 0, samples: [] });

  for (const [, desc] of descs) {
    const lower = desc.toLowerCase();
    let matched = false;
    for (const [cat, keywords] of Object.entries(categoryKeywords)) {
      if (keywords.some(kw => lower.includes(kw))) {
        const data = categorized.get(cat)!;
        data.count++;
        if (data.samples.length < 3) data.samples.push(desc.slice(0, 60));
        matched = true;
        break; // first match wins
      }
    }
    if (!matched) {
      const data = categorized.get('Uncategorized')!;
      data.count++;
      if (data.samples.length < 3) data.samples.push(desc.slice(0, 60));
    }
  }

  // Category table
  lines.push('## Effect Categories', '');
  lines.push('| Category | Effects | % | Sample Descriptions |');
  lines.push('|----------|-------:|---:|:-------------------|');
  const sorted = [...categorized.entries()].sort((a, b) => b[1].count - a[1].count);
  for (const [cat, data] of sorted) {
    if (data.count === 0) continue;
    const pct = Math.round(data.count / descs.size * 100);
    lines.push(`| ${cat} | ${data.count} | ${pct}% | ${data.samples.join(' / ')} |`);
  }

  // Word frequency in descriptions
  const wordCounts = new Map<string, number>();
  for (const [, desc] of descs) {
    const words = desc.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter((w: string) => w.length >= 4);
    for (const word of words) {
      wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
    }
  }
  const topWords = [...wordCounts.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('', '## Most Common Words in Item Effects', '');
  lines.push('| Word | Occurrences |');
  lines.push('|------|----------:|');
  for (const [word, count] of topWords.slice(0, 25)) {
    lines.push(`| ${word} | ${count} |`);
  }

  // Description length distribution
  const lengths = [...descs.values()].map(d => d.length);
  const avgLen = Math.round(lengths.reduce((s, l) => s + l, 0) / lengths.length);
  const maxLen = Math.max(...lengths);
  const minLen = Math.min(...lengths);

  lines.push('', '## Statistics', '');
  lines.push(`- **Total item effects:** ${descs.size}`);
  lines.push(`- **Avg description length:** ${avgLen} chars`);
  lines.push(`- **Shortest:** ${minLen} chars`);
  lines.push(`- **Longest:** ${maxLen} chars`);
  lines.push(`- **Categorized:** ${descs.size - (categorized.get('Uncategorized')?.count || 0)} (${Math.round((descs.size - (categorized.get('Uncategorized')?.count || 0)) / descs.size * 100)}%)`);

  lines.push('', `*${descs.size} item effects classified into ${sorted.filter(([, d]) => d.count > 0).length} categories.*`);
  return lines.join('\n');
}

// ============ TOOL 238: Tribute Efficiency Analysis ============
export async function getTributeEfficiencyAnalysis(): Promise<string> {
  await loadTributes();
  if (!tributes || tributes.size === 0) return 'Tribute data not available.';

  const lines = ['# Tribute Efficiency Analysis', '', '*Compare tribute benefits by type, personal vs guild, and keyword optimization.*', ''];

  // Split personal vs guild
  const personal = [...tributes.values()].filter(t => !t.isGuild);
  const guild = [...tributes.values()].filter(t => t.isGuild);

  lines.push(`- **Total tributes:** ${tributes.size}`);
  lines.push(`- **Personal tributes:** ${personal.length}`);
  lines.push(`- **Guild tributes:** ${guild.length}`);
  lines.push('');

  // Keyword classification
  const benefitKeywords: Record<string, string[]> = {
    'HP/Health': ['hit point', 'hp', 'health'],
    'Mana': ['mana'],
    'AC/Armor': ['armor class', 'avoidance'],
    'Attack/DPS': ['attack', 'damage', 'melee', 'crit', 'flurry', 'double attack'],
    'Haste': ['haste', 'attack speed'],
    'Resist': ['resist', 'fire resist', 'cold resist', 'magic resist', 'poison resist', 'disease resist'],
    'Regeneration': ['regen', 'regenerat'],
    'Endurance': ['endurance'],
    'Spell': ['spell', 'casting', 'focus'],
    'Experience': ['experience', 'xp'],
    'Movement': ['movement', 'run speed'],
  };

  // Classify tributes
  const personalByType = new Map<string, TributeEntry[]>();
  const guildByType = new Map<string, TributeEntry[]>();

  for (const t of tributes.values()) {
    const lower = (t.name + ' ' + t.description).toLowerCase();
    let classified = false;
    for (const [type, keywords] of Object.entries(benefitKeywords)) {
      if (keywords.some(kw => lower.includes(kw))) {
        const map = t.isGuild ? guildByType : personalByType;
        if (!map.has(type)) map.set(type, []);
        map.get(type)!.push(t);
        classified = true;
        break;
      }
    }
    if (!classified) {
      const map = t.isGuild ? guildByType : personalByType;
      if (!map.has('Other')) map.set('Other', []);
      map.get('Other')!.push(t);
    }
  }

  // Personal tribute breakdown
  lines.push('## Personal Tribute by Benefit Type', '');
  lines.push('| Benefit Type | Count | Sample Tributes |');
  lines.push('|-------------|------:|:---------------|');
  const personalSorted = [...personalByType.entries()].sort((a, b) => b[1].length - a[1].length);
  for (const [type, tribList] of personalSorted) {
    const samples = tribList.slice(0, 2).map(t => t.name).join(', ');
    lines.push(`| ${type} | ${tribList.length} | ${samples} |`);
  }

  // Guild tribute breakdown
  if (guild.length > 0) {
    lines.push('', '## Guild Tribute by Benefit Type', '');
    lines.push('| Benefit Type | Count | Sample Tributes |');
    lines.push('|-------------|------:|:---------------|');
    const guildSorted = [...guildByType.entries()].sort((a, b) => b[1].length - a[1].length);
    for (const [type, tribList] of guildSorted) {
      const samples = tribList.slice(0, 2).map(t => t.name).join(', ');
      lines.push(`| ${type} | ${tribList.length} | ${samples} |`);
    }
  }

  // Coverage comparison
  lines.push('', '## Personal vs Guild Coverage', '');
  lines.push('| Benefit Type | Personal | Guild |');
  lines.push('|-------------|--------:|------:|');
  const allTypes = new Set([...personalByType.keys(), ...guildByType.keys()]);
  for (const type of [...allTypes].sort()) {
    const pCount = personalByType.get(type)?.length || 0;
    const gCount = guildByType.get(type)?.length || 0;
    lines.push(`| ${type} | ${pCount} | ${gCount} |`);
  }

  // Name pattern analysis
  const nameWords = new Map<string, number>();
  for (const t of tributes.values()) {
    const words = t.name.toLowerCase().split(/\s+/).filter(w => w.length >= 3);
    for (const word of words) {
      nameWords.set(word, (nameWords.get(word) || 0) + 1);
    }
  }
  const topNameWords = [...nameWords.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('', '## Most Common Tribute Name Words', '');
  lines.push('| Word | Count |');
  lines.push('|------|------:|');
  for (const [word, count] of topNameWords.slice(0, 15)) {
    lines.push(`| ${word} | ${count} |`);
  }

  lines.push('', `*${tributes.size} tributes analyzed across ${allTypes.size} benefit types.*`);
  return lines.join('\n');
}

// ============ TOOL 239: Game String Category Analysis ============
export async function getGameStringCategoryAnalysis(): Promise<string> {
  await loadGameStrings();
  if (!gameStrings || gameStrings.size === 0) return 'Game string data not available.';

  const lines = ['# Game String Category Analysis', '', '*Analyze 7000+ game UI strings by topic and content type.*', ''];

  // Topic categories by keyword
  const topicKeywords: Record<string, string[]> = {
    'Combat': ['attack', 'damage', 'hit', 'miss', 'dodge', 'parry', 'riposte', 'block', 'slay', 'kill'],
    'Spells/Magic': ['spell', 'cast', 'mana', 'resist', 'fizzle', 'component', 'reagent', 'scribe'],
    'Items/Loot': ['item', 'loot', 'equip', 'inventory', 'bag', 'slot', 'augment', 'tribute'],
    'Trading/Economy': ['buy', 'sell', 'trade', 'merchant', 'bazaar', 'price', 'coin', 'platinum', 'gold', 'silver'],
    'Group/Raid': ['group', 'raid', 'invite', 'disband', 'leader', 'loot', 'split'],
    'Guild': ['guild', 'banner', 'rank', 'officer', 'member', 'recruit'],
    'Chat/Social': ['tell', 'say', 'shout', 'auction', 'ooc', 'emote', 'channel', 'chat', 'message'],
    'Navigation': ['zone', 'teleport', 'gate', 'bind', 'location', 'compass', 'map', 'waypoint'],
    'Character': ['level', 'experience', 'skill', 'ability', 'class', 'race', 'stat', 'train'],
    'UI/System': ['window', 'button', 'click', 'display', 'option', 'setting', 'default', 'enable', 'disable'],
    'Pet': ['pet', 'familiar', 'companion', 'minion'],
    'Housing': ['house', 'plot', 'yard', 'real estate', 'trophy', 'placeable'],
    'Achievement': ['achievement', 'reward', 'accomplish', 'complete'],
    'Error/Warning': ['error', 'cannot', 'invalid', 'failed', 'unable', 'must', 'require'],
  };

  const categorized = new Map<string, { count: number; samples: string[] }>();
  for (const cat of Object.keys(topicKeywords)) {
    categorized.set(cat, { count: 0, samples: [] });
  }
  categorized.set('Other', { count: 0, samples: [] });

  let totalLength = 0;
  let longestStr = '';

  for (const [, text] of gameStrings) {
    totalLength += text.length;
    if (text.length > longestStr.length) longestStr = text;

    const lower = text.toLowerCase();
    let matched = false;
    for (const [cat, keywords] of Object.entries(topicKeywords)) {
      if (keywords.some(kw => lower.includes(kw))) {
        const data = categorized.get(cat)!;
        data.count++;
        if (data.samples.length < 2) data.samples.push(text.slice(0, 60));
        matched = true;
        break;
      }
    }
    if (!matched) {
      const data = categorized.get('Other')!;
      data.count++;
      if (data.samples.length < 2) data.samples.push(text.slice(0, 60));
    }
  }

  // Category table
  lines.push('## String Topics', '');
  lines.push('| Topic | Strings | % | Samples |');
  lines.push('|-------|-------:|---:|:--------|');
  const sorted = [...categorized.entries()].sort((a, b) => b[1].count - a[1].count);
  for (const [cat, data] of sorted) {
    if (data.count === 0) continue;
    const pct = Math.round(data.count / gameStrings.size * 100);
    lines.push(`| ${cat} | ${data.count} | ${pct}% | ${data.samples.join(' / ')} |`);
  }

  // ID range analysis
  const ids = [...gameStrings.keys()].sort((a, b) => a - b);
  const ranges: { start: number; end: number; count: number }[] = [];
  const bucketSize = 1000;
  for (let start = 0; start <= ids[ids.length - 1]; start += bucketSize) {
    const end = start + bucketSize - 1;
    const count = ids.filter(id => id >= start && id <= end).length;
    if (count > 0) ranges.push({ start, end, count });
  }

  lines.push('', '## ID Range Distribution (Top Ranges)', '');
  lines.push('| ID Range | Strings | Bar |');
  lines.push('|----------|-------:|:----|');
  const topRanges = ranges.sort((a, b) => b.count - a.count).slice(0, 15);
  const maxCount = topRanges[0]?.count || 1;
  for (const r of topRanges) {
    const barLen = Math.ceil(r.count / maxCount * 20);
    lines.push(`| ${r.start}-${r.end} | ${r.count} | ${'█'.repeat(barLen)} |`);
  }

  // Word frequency
  const wordCounts = new Map<string, number>();
  for (const [, text] of gameStrings) {
    const words = text.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter(w => w.length >= 4);
    for (const word of words) {
      wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
    }
  }
  const topWords = [...wordCounts.entries()].sort((a, b) => b[1] - a[1]);

  lines.push('', '## Most Common Words', '');
  lines.push('| Word | Occurrences |');
  lines.push('|------|----------:|');
  for (const [word, count] of topWords.slice(0, 20)) {
    lines.push(`| ${word} | ${count} |`);
  }

  // Statistics
  const avgLen = Math.round(totalLength / gameStrings.size);
  lines.push('', '## Statistics', '');
  lines.push(`- **Total strings:** ${gameStrings.size}`);
  lines.push(`- **Average length:** ${avgLen} chars`);
  lines.push(`- **Longest string:** ${longestStr.length} chars`);
  lines.push(`- **ID range:** ${ids[0]} to ${ids[ids.length - 1]}`);
  lines.push(`- **Categorized:** ${gameStrings.size - (categorized.get('Other')?.count || 0)} (${Math.round((gameStrings.size - (categorized.get('Other')?.count || 0)) / gameStrings.size * 100)}%)`);

  lines.push('', `*${gameStrings.size} game strings analyzed across ${sorted.filter(([, d]) => d.count > 0).length} topics.*`);
  return lines.join('\n');
}

// ============ TOOL 240: Lore Theme Analysis ============
export async function getLoreThemeAnalysis(): Promise<string> {
  await loadLore();
  if (!loreEntries || loreEntries.length === 0) return 'Lore data not available.';

  const lines = ['# Lore Theme Analysis', '', '*Analyze in-game lore stories for themes, recurring names, and connections.*', ''];

  lines.push(`**Total lore entries:** ${loreEntries.length}`, '');

  // Word frequency across all lore
  const wordCounts = new Map<string, number>();
  const nameWords = new Map<string, number>(); // capitalized words (potential names)
  let totalWords = 0;
  let totalChars = 0;

  for (const entry of loreEntries) {
    totalChars += entry.content.length;
    const words = entry.content.split(/\s+/).filter((w: string) => w.length >= 1);
    totalWords += words.length;

    for (const word of words) {
      const clean = word.replace(/[^a-zA-Z']/g, '');
      if (clean.length < 3) continue;

      const lower = clean.toLowerCase();
      wordCounts.set(lower, (wordCounts.get(lower) || 0) + 1);

      // Track capitalized words as potential proper nouns
      if (clean[0] >= 'A' && clean[0] <= 'Z' && clean.length >= 4) {
        nameWords.set(clean, (nameWords.get(clean) || 0) + 1);
      }
    }
  }

  // Theme keywords
  const themeKeywords: Record<string, string[]> = {
    'War/Battle': ['war', 'battle', 'fight', 'army', 'soldier', 'sword', 'weapon', 'siege', 'conquer', 'warrior'],
    'Magic/Arcane': ['magic', 'spell', 'wizard', 'mana', 'arcane', 'enchant', 'sorcery', 'power', 'mystic'],
    'Gods/Divine': ['god', 'goddess', 'divine', 'deity', 'worship', 'temple', 'prayer', 'holy', 'sacred'],
    'Death/Undead': ['death', 'dead', 'undead', 'necro', 'grave', 'tomb', 'skeleton', 'lich', 'corpse'],
    'Nature/Druid': ['forest', 'tree', 'nature', 'animal', 'druid', 'wild', 'beast', 'earth', 'grove'],
    'Dark/Evil': ['dark', 'evil', 'shadow', 'corrupt', 'curse', 'malice', 'hatred', 'demon', 'plague'],
    'Light/Good': ['light', 'good', 'hero', 'noble', 'virtue', 'honor', 'justice', 'protect', 'pure'],
    'Creation/Origin': ['create', 'origin', 'begin', 'born', 'first', 'ancient', 'elder', 'dawn'],
    'Kingdom/Politics': ['king', 'queen', 'ruler', 'throne', 'empire', 'realm', 'lord', 'council'],
    'Race/People': ['elf', 'dwarf', 'human', 'gnome', 'troll', 'ogre', 'iksar', 'erudite', 'barbarian'],
  };

  const themeCounts = new Map<string, { count: number; stories: Set<string> }>();
  for (const theme of Object.keys(themeKeywords)) {
    themeCounts.set(theme, { count: 0, stories: new Set() });
  }

  for (const entry of loreEntries) {
    const lower = entry.content.toLowerCase();
    for (const [theme, keywords] of Object.entries(themeKeywords)) {
      let themeHits = 0;
      for (const kw of keywords) {
        const regex = new RegExp(`\\b${kw}`, 'gi');
        const matches = lower.match(regex);
        if (matches) themeHits += matches.length;
      }
      if (themeHits > 0) {
        const data = themeCounts.get(theme)!;
        data.count += themeHits;
        data.stories.add(entry.title);
      }
    }
  }

  // Theme ranking
  const sortedThemes = [...themeCounts.entries()].sort((a, b) => b[1].count - a[1].count);
  lines.push('## Theme Analysis', '');
  lines.push('| Theme | Mentions | Stories | Sample Stories |');
  lines.push('|-------|--------:|-------:|:-------------|');
  for (const [theme, data] of sortedThemes) {
    if (data.count === 0) continue;
    const samples = [...data.stories].slice(0, 3).join(', ');
    lines.push(`| ${theme} | ${data.count} | ${data.stories.size} | ${samples} |`);
  }

  // Recurring proper nouns (potential character/place names)
  const stopWords = new Set(['The', 'And', 'But', 'For', 'Not', 'With', 'This', 'That', 'From', 'They', 'Were', 'Have', 'Has', 'Their', 'Would', 'Could', 'There', 'Which', 'When', 'What', 'Into', 'Upon', 'Over', 'After', 'Before', 'Through', 'Between', 'Those', 'These', 'Only', 'Such', 'Many', 'Some', 'More', 'Most', 'Other', 'Each', 'Every', 'Then', 'Than', 'Also', 'Very', 'Even', 'Much', 'Great', 'Long', 'Though']);
  const filteredNames = [...nameWords.entries()]
    .filter(([name, count]) => count >= 3 && !stopWords.has(name))
    .sort((a, b) => b[1] - a[1]);

  lines.push('', '## Recurring Names (Proper Nouns)', '');
  lines.push('| Name | Occurrences |');
  lines.push('|------|----------:|');
  for (const [name, count] of filteredNames.slice(0, 25)) {
    lines.push(`| ${name} | ${count} |`);
  }

  // Story statistics
  const storyLengths = loreEntries.map(e => e.content.length);
  const sortedByLength = [...loreEntries].sort((a, b) => b.content.length - a.content.length);

  lines.push('', '## Story Length Distribution', '');
  lines.push('| Story | Characters | Words |');
  lines.push('|-------|----------:|------:|');
  for (const entry of sortedByLength.slice(0, 10)) {
    const wc = entry.content.split(/\s+/).length;
    lines.push(`| ${entry.title} | ${entry.content.length.toLocaleString()} | ${wc.toLocaleString()} |`);
  }

  // Most common words (excluding common English)
  const commonStop = new Set(['the', 'and', 'was', 'that', 'with', 'for', 'his', 'her', 'had', 'not', 'but', 'this', 'from', 'they', 'were', 'have', 'their', 'been', 'would', 'could', 'which', 'when', 'what', 'who', 'all', 'she', 'there', 'into', 'them', 'has', 'its', 'are', 'upon', 'him', 'than', 'then', 'out', 'over', 'more', 'only', 'those', 'also', 'other', 'many', 'some']);
  const contentWords = [...wordCounts.entries()]
    .filter(([w, c]) => c >= 5 && !commonStop.has(w))
    .sort((a, b) => b[1] - a[1]);

  lines.push('', '## Most Frequent Content Words', '');
  lines.push('| Word | Count |');
  lines.push('|------|------:|');
  for (const [word, count] of contentWords.slice(0, 20)) {
    lines.push(`| ${word} | ${count} |`);
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Total stories:** ${loreEntries.length}`);
  lines.push(`- **Total words:** ${totalWords.toLocaleString()}`);
  lines.push(`- **Total characters:** ${totalChars.toLocaleString()}`);
  lines.push(`- **Avg story length:** ${Math.round(totalChars / loreEntries.length).toLocaleString()} chars`);
  lines.push(`- **Longest story:** ${sortedByLength[0]?.title || '-'} (${sortedByLength[0]?.content.length.toLocaleString() || 0} chars)`);
  lines.push(`- **Dominant theme:** ${sortedThemes[0]?.[0] || '-'}`);

  lines.push('', `*${loreEntries.length} lore stories analyzed.*`);
  return lines.join('\n');
}

// ============ TOOL 241: Augmentation System Analysis ============
export async function getAugmentationSystemAnalysis(): Promise<string> {
  await loadDbStrings([DBSTR_TYPES.AUGMENT_GROUP, DBSTR_TYPES.AUGMENT_SLOT_TYPE]);
  const augGroups = dbStrings?.get(DBSTR_TYPES.AUGMENT_GROUP) || new Map();
  const slotTypes = dbStrings?.get(DBSTR_TYPES.AUGMENT_SLOT_TYPE) || new Map();

  if (augGroups.size === 0 && slotTypes.size === 0) return 'Augmentation data not available.';

  const lines = ['# Augmentation System Analysis', '', '*Analyze augmentation groups and slot types for gear planning.*', ''];

  // Slot types
  if (slotTypes.size > 0) {
    lines.push('## Augmentation Slot Types', '');
    lines.push('| ID | Slot Type |');
    lines.push('|---:|:---------|');
    const sortedSlots = [...slotTypes.entries()].sort((a, b) => a[0] - b[0]);
    for (const [id, name] of sortedSlots) {
      lines.push(`| ${id} | ${name} |`);
    }
    lines.push('');
  }

  // Augment group analysis
  if (augGroups.size > 0) {
    lines.push('## Augmentation Groups', '');

    // Classify groups by keywords
    const groupCategories: Record<string, string[]> = {
      'Stat': ['stat', 'strength', 'stamina', 'agility', 'dexterity', 'intelligence', 'wisdom', 'charisma'],
      'Combat': ['combat', 'attack', 'damage', 'melee', 'weapon', 'strike'],
      'Defensive': ['defense', 'armor', 'shielding', 'avoidance', 'mitigation', 'resist'],
      'Spell': ['spell', 'focus', 'cast', 'mana'],
      'Skill': ['skill', 'ability', 'proficiency'],
      'Special': ['special', 'quest', 'epic', 'ornament', 'evolving'],
    };

    const catCounts = new Map<string, { count: number; samples: string[] }>();
    for (const cat of Object.keys(groupCategories)) {
      catCounts.set(cat, { count: 0, samples: [] });
    }
    catCounts.set('General', { count: 0, samples: [] });

    for (const [, name] of augGroups) {
      const lower = name.toLowerCase();
      let classified = false;
      for (const [cat, keywords] of Object.entries(groupCategories)) {
        if (keywords.some(kw => lower.includes(kw))) {
          const data = catCounts.get(cat)!;
          data.count++;
          if (data.samples.length < 3) data.samples.push(name);
          classified = true;
          break;
        }
      }
      if (!classified) {
        const data = catCounts.get('General')!;
        data.count++;
        if (data.samples.length < 3) data.samples.push(name);
      }
    }

    lines.push('### Groups by Category', '');
    lines.push('| Category | Groups | Samples |');
    lines.push('|----------|------:|:--------|');
    const sortedCats = [...catCounts.entries()].sort((a, b) => b[1].count - a[1].count);
    for (const [cat, data] of sortedCats) {
      if (data.count === 0) continue;
      lines.push(`| ${cat} | ${data.count} | ${data.samples.join(', ')} |`);
    }

    // Common words in group names
    const nameWordCounts = new Map<string, number>();
    for (const [, name] of augGroups) {
      const words = name.toLowerCase().split(/\s+/).filter((w: string) => w.length >= 3);
      for (const word of words) {
        nameWordCounts.set(word, (nameWordCounts.get(word) || 0) + 1);
      }
    }
    const topNameWords = [...nameWordCounts.entries()].sort((a, b) => b[1] - a[1]);

    lines.push('', '### Common Words in Group Names', '');
    lines.push('| Word | Count |');
    lines.push('|------|------:|');
    for (const [word, count] of topNameWords.slice(0, 15)) {
      lines.push(`| ${word} | ${count} |`);
    }

    // Full group listing (first 30)
    lines.push('', '### Sample Augmentation Groups', '');
    lines.push('| ID | Group Name |');
    lines.push('|---:|:---------|');
    const sortedGroups = [...augGroups.entries()].sort((a, b) => a[0] - b[0]);
    for (const [id, name] of sortedGroups.slice(0, 30)) {
      lines.push(`| ${id} | ${name} |`);
    }
    if (sortedGroups.length > 30) {
      lines.push(`| ... | *${sortedGroups.length - 30} more groups* |`);
    }
  }

  lines.push('', '## Summary', '');
  lines.push(`- **Slot types:** ${slotTypes.size}`);
  lines.push(`- **Augmentation groups:** ${augGroups.size}`);

  lines.push('', `*${slotTypes.size} slot types and ${augGroups.size} augmentation groups analyzed.*`);
  return lines.join('\n');
}

// ============ TOOL 242: Map POI Zone Detail ============
export async function getMapPOIZoneDetail(zoneName: string): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  // Find zone
  const query = zoneName.toLowerCase().trim();
  let matchedZone: { name: string; shortName: string } | null = null;
  for (const zone of zones.values()) {
    if (zone.name.toLowerCase() === query || zone.name.toLowerCase().includes(query)) {
      matchedZone = { name: zone.name, shortName: zone.name.toLowerCase().replace(/[^a-z0-9]/g, '') };
      break;
    }
  }
  if (!matchedZone) return `Zone "${zoneName}" not found. Use search_zones_by_name to find zone names.`;

  const pois = await loadMapPOIs(matchedZone.name);
  if (pois.length === 0) return `No map POI data available for ${matchedZone.name}.`;

  const lines = [`# Map POI Detail: ${matchedZone.name}`, '', `*${pois.length} points of interest from Brewall map data.*`, ''];

  // Classify POIs by label keywords
  const poiCategories: Record<string, string[]> = {
    'Merchant/Vendor': ['merchant', 'vendor', 'shopkeeper', 'trader', 'supplier', 'shop'],
    'Zone Line': ['zone', 'to ', 'entrance', 'exit', 'portal', 'door'],
    'Bank/Guild': ['bank', 'guild hall', 'guild'],
    'NPC/Quest': ['npc', 'quest', 'task'],
    'Camp/Spawn': ['camp', 'spawn', 'named', 'rare', 'ph'],
    'Craft/Tradeskill': ['forge', 'brew', 'oven', 'kiln', 'loom', 'pottery', 'fletching', 'jewel', 'tinkering'],
    'Temple/Shrine': ['temple', 'shrine', 'altar', 'church', 'chapel'],
    'Guard/Military': ['guard', 'soldier', 'warrior', 'captain', 'patrol'],
    'Landmark': ['tower', 'bridge', 'lake', 'cave', 'tunnel', 'mountain', 'river', 'pit'],
  };

  const categorized = new Map<string, MapPOI[]>();
  for (const cat of Object.keys(poiCategories)) {
    categorized.set(cat, []);
  }
  categorized.set('Other', []);

  for (const poi of pois) {
    const lower = poi.label.toLowerCase();
    let matched = false;
    for (const [cat, keywords] of Object.entries(poiCategories)) {
      if (keywords.some(kw => lower.includes(kw))) {
        categorized.get(cat)!.push(poi);
        matched = true;
        break;
      }
    }
    if (!matched) categorized.get('Other')!.push(poi);
  }

  // Category summary
  lines.push('## POI Categories', '');
  lines.push('| Category | POIs | % |');
  lines.push('|----------|-----:|---:|');
  const sortedCats = [...categorized.entries()].sort((a, b) => b[1].length - a[1].length);
  for (const [cat, poiList] of sortedCats) {
    if (poiList.length === 0) continue;
    const pct = Math.round(poiList.length / pois.length * 100);
    lines.push(`| ${cat} | ${poiList.length} | ${pct}% |`);
  }

  // Full POI listing by category
  for (const [cat, poiList] of sortedCats) {
    if (poiList.length === 0) continue;
    lines.push('', `## ${cat} (${poiList.length})`, '');
    lines.push('| Label | X | Y | Z |');
    lines.push('|-------|---:|---:|---:|');
    const sorted = [...poiList].sort((a, b) => a.label.localeCompare(b.label));
    for (const poi of sorted.slice(0, 30)) {
      lines.push(`| ${poi.label} | ${Math.round(poi.x)} | ${Math.round(poi.y)} | ${Math.round(poi.z)} |`);
    }
    if (sorted.length > 30) {
      lines.push(`| *...${sorted.length - 30} more* | | | |`);
    }
  }

  // Coordinate bounds
  const xs = pois.map(p => p.x);
  const ys = pois.map(p => p.y);
  const zs = pois.map(p => p.z);
  lines.push('', '## Zone Dimensions', '');
  lines.push(`- **X range:** ${Math.round(Math.min(...xs))} to ${Math.round(Math.max(...xs))} (span: ${Math.round(Math.max(...xs) - Math.min(...xs))})`);
  lines.push(`- **Y range:** ${Math.round(Math.min(...ys))} to ${Math.round(Math.max(...ys))} (span: ${Math.round(Math.max(...ys) - Math.min(...ys))})`);
  lines.push(`- **Z range:** ${Math.round(Math.min(...zs))} to ${Math.round(Math.max(...zs))} (span: ${Math.round(Math.max(...zs) - Math.min(...zs))})`);

  lines.push('', `*${pois.length} POIs analyzed for ${matchedZone.name}.*`);
  return lines.join('\n');
}

// ============ TOOL 243: Help Topic Content Analysis ============
export async function getHelpTopicContentAnalysis(): Promise<string> {
  await loadHelpTopics();
  if (!helpTopics || helpTopics.size === 0) return 'Help topic data not available.';

  const lines = ['# Help Topic Content Analysis', '', '*Analyze 75+ in-game help topics by content, length, and cross-references.*', ''];

  // Load all topic content
  interface TopicInfo {
    key: string;
    title: string;
    content: string;
    wordCount: number;
    links: string[];
  }

  const topics: TopicInfo[] = [];
  for (const [key, info] of helpTopics) {
    try {
      const filePath = join(EQ_GAME_PATH, 'Help', info.filename);
      const raw = await readFile(filePath, 'utf8');
      const content = stripHelpHtml(raw);
      const wordCount = content.split(/\s+/).filter((w: string) => w.length > 0).length;

      // Find cross-references (links to other help files)
      const linkMatches = raw.matchAll(/href="file:\/\/\/help\/([^"]+)"/gi);
      const links: string[] = [];
      for (const match of linkMatches) {
        links.push(match[1].replace('.html', ''));
      }

      topics.push({ key, title: info.title, content, wordCount, links });
    } catch {
      topics.push({ key, title: info.title, content: '', wordCount: 0, links: [] });
    }
  }

  lines.push(`**Total topics:** ${topics.length}`, '');

  // Sort by word count
  const byLength = [...topics].sort((a, b) => b.wordCount - a.wordCount);
  lines.push('## Topics by Length', '');
  lines.push('| Topic | Title | Words | Cross-refs |');
  lines.push('|-------|-------|------:|-----------:|');
  for (const t of byLength.slice(0, 20)) {
    lines.push(`| ${t.key} | ${t.title} | ${t.wordCount} | ${t.links.length} |`);
  }

  // Cross-reference analysis
  const incomingLinks = new Map<string, string[]>();
  for (const t of topics) {
    for (const link of t.links) {
      if (!incomingLinks.has(link)) incomingLinks.set(link, []);
      incomingLinks.get(link)!.push(t.key);
    }
  }

  const sortedIncoming = [...incomingLinks.entries()].sort((a, b) => b[1].length - a[1].length);
  if (sortedIncoming.length > 0) {
    lines.push('', '## Most-Referenced Topics', '');
    lines.push('| Topic | Incoming Links | Referenced From |');
    lines.push('|-------|-------------:|:---------------|');
    for (const [topic, refs] of sortedIncoming.slice(0, 15)) {
      lines.push(`| ${topic} | ${refs.length} | ${refs.slice(0, 3).join(', ')}${refs.length > 3 ? '...' : ''} |`);
    }
  }

  // Topic keyword categorization
  const topicCategories: Record<string, string[]> = {
    'Combat': ['combat', 'melee', 'attack', 'weapon', 'damage'],
    'Magic': ['spell', 'magic', 'mana', 'cast'],
    'Character': ['class', 'race', 'skill', 'level', 'experience', 'ability'],
    'Social': ['group', 'guild', 'raid', 'fellowship', 'friend', 'chat'],
    'Economy': ['trade', 'bazaar', 'merchant', 'coin', 'tribute'],
    'UI/System': ['window', 'interface', 'command', 'key', 'option', 'macro'],
    'Content': ['quest', 'zone', 'dungeon', 'achievement', 'overseer'],
    'Items': ['item', 'augment', 'equip', 'loot', 'inventory'],
  };

  const catResults = new Map<string, string[]>();
  for (const t of topics) {
    const lower = (t.title + ' ' + t.content.slice(0, 200)).toLowerCase();
    for (const [cat, keywords] of Object.entries(topicCategories)) {
      if (keywords.some(kw => lower.includes(kw))) {
        if (!catResults.has(cat)) catResults.set(cat, []);
        catResults.get(cat)!.push(t.title);
        break;
      }
    }
  }

  lines.push('', '## Topics by Category', '');
  lines.push('| Category | Topics | Examples |');
  lines.push('|----------|------:|:--------|');
  const sortedCatResults = [...catResults.entries()].sort((a, b) => b[1].length - a[1].length);
  for (const [cat, topicList] of sortedCatResults) {
    lines.push(`| ${cat} | ${topicList.length} | ${topicList.slice(0, 3).join(', ')} |`);
  }

  // Statistics
  const totalWords = topics.reduce((sum, t) => sum + t.wordCount, 0);
  const totalLinks = topics.reduce((sum, t) => sum + t.links.length, 0);
  lines.push('', '## Statistics', '');
  lines.push(`- **Total topics:** ${topics.length}`);
  lines.push(`- **Total words:** ${totalWords.toLocaleString()}`);
  lines.push(`- **Average words/topic:** ${Math.round(totalWords / topics.length)}`);
  lines.push(`- **Total cross-references:** ${totalLinks}`);
  lines.push(`- **Topics with links:** ${topics.filter(t => t.links.length > 0).length}`);
  lines.push(`- **Longest topic:** ${byLength[0]?.title || '-'} (${byLength[0]?.wordCount || 0} words)`);

  lines.push('', `*${topics.length} help topics analyzed.*`);
  return lines.join('\n');
}

// ============ TOOL 244: Spell Level Milestone Guide ============
export async function getSpellLevelMilestoneGuide(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  // Resolve class
  const classNameUpper = className.toUpperCase().trim();
  let classId = 0;
  for (const [id, short] of Object.entries(CLASS_SHORT)) {
    if (short === classNameUpper) { classId = parseInt(id); break; }
  }
  if (!classId) {
    for (const [id, name] of Object.entries(CLASS_IDS)) {
      if (name.toUpperCase() === classNameUpper) { classId = parseInt(id); break; }
    }
  }
  if (!classId) return `Unknown class: "${className}". Use 3-letter code (WAR, CLR) or full name (Warrior, Cleric).`;

  const fullName = CLASS_IDS[classId];
  const lines = [`# Spell Level Milestone Guide: ${fullName} (${CLASS_SHORT[classId]})`, '', '*Key spell milestones — first spell of each important type by level.*', ''];

  // Milestone types: SPA-based and category-based
  const milestoneTypes: { name: string; check: (spell: { spaIds: Set<number>; beneficial: boolean; catName: string; base1Map: Map<number, number>; targetType: number }) => boolean }[] = [
    { name: 'First Heal', check: (s) => s.spaIds.has(0) && s.beneficial && s.base1Map.get(0)! > 0 },
    { name: 'First Nuke (DD)', check: (s) => s.spaIds.has(0) && !s.beneficial && (s.base1Map.get(0) || 0) < 0 },
    { name: 'First DoT', check: (s) => s.spaIds.has(0) && !s.beneficial && (s.base1Map.get(0) || 0) < 0 && s.catName.toLowerCase().includes('dot') },
    { name: 'First Root', check: (s) => s.spaIds.has(99) },
    { name: 'First Snare', check: (s) => s.spaIds.has(3) && !s.beneficial },
    { name: 'First Stun', check: (s) => s.spaIds.has(21) },
    { name: 'First Mez', check: (s) => s.spaIds.has(31) || s.spaIds.has(74) },
    { name: 'First Charm', check: (s) => s.spaIds.has(22) },
    { name: 'First Fear', check: (s) => s.spaIds.has(23) },
    { name: 'First Haste', check: (s) => s.spaIds.has(11) && s.beneficial },
    { name: 'First Slow', check: (s) => s.spaIds.has(11) && !s.beneficial },
    { name: 'First Invisibility', check: (s) => s.spaIds.has(12) },
    { name: 'First Levitate', check: (s) => s.spaIds.has(57) },
    { name: 'First Teleport', check: (s) => s.spaIds.has(82) || s.spaIds.has(100) || s.spaIds.has(43) },
    { name: 'First Summon Pet', check: (s) => s.spaIds.has(33) },
    { name: 'First Resurrection', check: (s) => s.spaIds.has(80) },
    { name: 'First Damage Shield', check: (s) => s.spaIds.has(87) && s.beneficial },
    { name: 'First Rune', check: (s) => s.spaIds.has(55) || s.spaIds.has(54) },
    { name: 'First Gate', check: (s) => s.spaIds.has(26) || s.spaIds.has(71) },
    { name: 'First Group Heal', check: (s) => s.spaIds.has(0) && s.beneficial && (s.base1Map.get(0) || 0) > 0 && [3, 41].includes(s.targetType) },
    { name: 'First AE Nuke', check: (s) => s.spaIds.has(0) && !s.beneficial && (s.base1Map.get(0) || 0) < 0 && [2, 4, 8, 40, 42, 44, 46].includes(s.targetType) },
    { name: 'First AC Buff', check: (s) => s.spaIds.has(1) && s.beneficial },
    { name: 'First Bind Affinity', check: (s) => s.spaIds.has(25) },
  ];

  // Find first spell of each type
  const milestones: { name: string; level: number; spellName: string }[] = [];
  const found = new Set<string>();

  // Collect all class spells sorted by level
  interface MilestoneSpell {
    name: string;
    level: number;
    spaIds: Set<number>;
    beneficial: boolean;
    catName: string;
    base1Map: Map<number, number>;
    targetType: number;
  }

  const classSpells: MilestoneSpell[] = [];

  for (const spell of spells.values()) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + classId - 1]) || 255;
    if (lv < 1 || lv > 254) continue;

    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const catName = catId === 0 ? 'Uncategorized' : (spellCategories?.get(catId) || `Cat ${catId}`);
    const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;

    // Parse effects
    let slotsField = -1;
    for (let i = spell.fields.length - 1; i >= 0; i--) {
      if (spell.fields[i] && spell.fields[i].includes('|')) {
        slotsField = i;
        break;
      }
    }
    if (slotsField < 0) continue;

    const spaIds = new Set<number>();
    const base1Map = new Map<number, number>();
    const slots = spell.fields[slotsField].split('$');
    for (const slot of slots) {
      const parts = slot.split('|');
      if (parts.length >= 3) {
        const spa = parseInt(parts[1]);
        const base1 = parseInt(parts[2]) || 0;
        spaIds.add(spa);
        if (!base1Map.has(spa)) base1Map.set(spa, base1);
      }
    }

    classSpells.push({ name: spell.name, level: lv, spaIds, beneficial, catName, base1Map, targetType });
  }

  classSpells.sort((a, b) => a.level - b.level);

  for (const spell of classSpells) {
    for (const milestone of milestoneTypes) {
      if (found.has(milestone.name)) continue;
      try {
        if (milestone.check(spell)) {
          milestones.push({ name: milestone.name, level: spell.level, spellName: spell.name });
          found.add(milestone.name);
        }
      } catch { /* skip check errors */ }
    }
  }

  milestones.sort((a, b) => a.level - b.level);

  // Milestone timeline
  lines.push('## Spell Milestones', '');
  lines.push('| Level | Milestone | Spell |');
  lines.push('|------:|:----------|:------|');
  for (const m of milestones) {
    lines.push(`| ${m.level} | ${m.name} | ${m.spellName} |`);
  }

  // Missing milestones (class doesn't have these)
  const missing = milestoneTypes.filter(m => !found.has(m.name));
  if (missing.length > 0) {
    lines.push('', '## Not Available for This Class', '');
    for (const m of missing) {
      lines.push(`- ${m.name}`);
    }
  }

  // Level bracket summary
  lines.push('', '## Milestones by Level Bracket', '');
  const brackets = [
    { name: '1-10', min: 1, max: 10 },
    { name: '11-20', min: 11, max: 20 },
    { name: '21-40', min: 21, max: 40 },
    { name: '41-60', min: 41, max: 60 },
    { name: '61-75', min: 61, max: 75 },
    { name: '76-100', min: 76, max: 100 },
    { name: '101-125', min: 101, max: 125 },
    { name: '126+', min: 126, max: 999 },
  ];

  for (const bracket of brackets) {
    const bracketMilestones = milestones.filter(m => m.level >= bracket.min && m.level <= bracket.max);
    if (bracketMilestones.length > 0) {
      lines.push(`- **Level ${bracket.name}:** ${bracketMilestones.map(m => m.name).join(', ')}`);
    }
  }

  lines.push('', `*${milestones.length} milestones found for ${fullName} out of ${milestoneTypes.length} tracked.*`);
  return lines.join('\n');
}

// ============ TOOL 245: Cross-System Name Overlap ============
export async function getCrossSystemNameOverlap(): Promise<string> {
  await loadSpells();
  await loadFactions();
  await loadZones();
  await loadAchievements();
  await loadAAAbilities();
  await loadLore();
  await loadOverseerMinions();
  if (!spells) return 'Data not available.';

  const lines = ['# Cross-System Name Overlap Analysis', '', '*Find names that appear across multiple game data systems to discover lore connections.*', ''];

  // Build name sets per system
  const systems: { name: string; names: Set<string> }[] = [];

  // Zones
  if (zones && zones.size > 0) {
    const zoneNames = new Set<string>();
    for (const zone of zones.values()) {
      for (const word of zone.name.split(/[\s,()]+/).filter((w: string) => w.length >= 4)) {
        zoneNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'Zones', names: zoneNames });
  }

  // Factions
  if (factions && factions.size > 0) {
    const factionNames = new Set<string>();
    for (const faction of factions.values()) {
      for (const word of faction.name.split(/[\s,()]+/).filter((w: string) => w.length >= 4)) {
        factionNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'Factions', names: factionNames });
  }

  // Achievements
  if (achievements && achievements.size > 0) {
    const achNames = new Set<string>();
    for (const ach of achievements.values()) {
      for (const word of ach.name.split(/[\s,()]+/).filter((w: string) => w.length >= 4)) {
        achNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'Achievements', names: achNames });
  }

  // AA
  if (aaAbilities && aaAbilities.size > 0) {
    const aaNames = new Set<string>();
    for (const aa of aaAbilities.values()) {
      for (const word of aa.name.split(/[\s,()]+/).filter((w: string) => w.length >= 4)) {
        aaNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'AAs', names: aaNames });
  }

  // Lore
  if (loreEntries && loreEntries.length > 0) {
    const loreNames = new Set<string>();
    for (const entry of loreEntries) {
      // Extract capitalized proper nouns from titles
      for (const word of entry.title.split(/[\s,()]+/).filter((w: string) => w.length >= 4)) {
        loreNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'Lore', names: loreNames });
  }

  // Overseer agents
  if (overseerMinions && overseerMinions.size > 0) {
    const agentNames = new Set<string>();
    for (const agent of overseerMinions.values()) {
      const name = agent.shortName || agent.fullName;
      for (const word of name.split(/[\s,()]+/).filter((w: string) => w.length >= 4)) {
        agentNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'Overseer Agents', names: agentNames });
  }

  // Spell categories as names
  if (spellCategories && spellCategories.size > 0) {
    const catNames = new Set<string>();
    for (const cat of spellCategories.values()) {
      for (const word of cat.split(/[\s:,()]+/).filter((w: string) => w.length >= 4)) {
        catNames.add(word.toLowerCase());
      }
    }
    systems.push({ name: 'Spell Categories', names: catNames });
  }

  // Find words in 3+ systems
  const stopWords = new Set(['that', 'this', 'with', 'from', 'they', 'were', 'have', 'their', 'been', 'would', 'could', 'which', 'when', 'what', 'into', 'over', 'more', 'only', 'those', 'also', 'other', 'many', 'some', 'each', 'first', 'second', 'third', 'last', 'next', 'same', 'like', 'just', 'will', 'about', 'dark', 'high', 'long', 'great', 'lost', 'lands', 'power', 'ancient']);

  const wordSystems = new Map<string, Set<string>>();
  for (const sys of systems) {
    for (const word of sys.names) {
      if (stopWords.has(word)) continue;
      if (!wordSystems.has(word)) wordSystems.set(word, new Set());
      wordSystems.get(word)!.add(sys.name);
    }
  }

  const multiSystem = [...wordSystems.entries()]
    .filter(([, sysSet]) => sysSet.size >= 3)
    .sort((a, b) => b[1].size - a[1].size);

  lines.push('## Names in 3+ Systems', '');
  lines.push('| Name | Systems | Which Systems |');
  lines.push('|------|--------:|:-------------|');
  for (const [word, sysSet] of multiSystem.slice(0, 40)) {
    lines.push(`| ${word} | ${sysSet.size} | ${[...sysSet].join(', ')} |`);
  }

  // System overlap matrix
  lines.push('', '## System Overlap Matrix', '');
  lines.push('| System A | System B | Shared Words |');
  lines.push('|----------|----------|------------:|');
  for (let i = 0; i < systems.length; i++) {
    for (let j = i + 1; j < systems.length; j++) {
      let overlap = 0;
      for (const word of systems[i].names) {
        if (systems[j].names.has(word) && !stopWords.has(word)) overlap++;
      }
      if (overlap > 0) {
        lines.push(`| ${systems[i].name} | ${systems[j].name} | ${overlap} |`);
      }
    }
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Systems analyzed:** ${systems.length}`);
  for (const sys of systems) {
    lines.push(`  - ${sys.name}: ${sys.names.size} unique words`);
  }
  lines.push(`- **Words in 3+ systems:** ${multiSystem.length}`);
  lines.push(`- **Most connected word:** ${multiSystem[0]?.[0] || '-'} (${multiSystem[0]?.[1].size || 0} systems)`);

  lines.push('', `*${systems.length} game systems cross-referenced.*`);
  return lines.join('\n');
}

// Tool 246: Spell duration analysis
export async function getSpellDurationAnalysis(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines: string[] = ['# Spell Duration Analysis', '', '*Analyze duration formulas, distributions, and patterns across all spells.*'];

  // Count by duration formula
  const formulaCounts = new Map<number, number>();
  const categoryDurations = new Map<string, number[]>();
  const durationBuckets = new Map<string, number>();
  let instantCount = 0;
  let permanentCount = 0;
  let timedCount = 0;
  const longestSpells: { name: string; category: string; ticks: number; formula: number; value: number }[] = [];

  for (const spell of spells.values()) {
    const formula = parseInt(spell.fields[SF.DURATION_FORMULA]) || 0;
    const value = parseInt(spell.fields[SF.DURATION_VALUE]) || 0;
    formulaCounts.set(formula, (formulaCounts.get(formula) || 0) + 1);

    const ticks = calculateDurationTicks(formula, value);
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(catId) || 'Unknown';

    if (ticks <= 0) {
      instantCount++;
    } else if (formula === 50 || ticks >= 36000) {
      permanentCount++;
    } else {
      timedCount++;
      const secs = ticks * 6;
      if (!categoryDurations.has(category)) categoryDurations.set(category, []);
      categoryDurations.get(category)!.push(secs);

      // Bucket
      let bucket: string;
      if (secs <= 6) bucket = '≤6s (1 tick)';
      else if (secs <= 18) bucket = '7-18s';
      else if (secs <= 60) bucket = '19-60s';
      else if (secs <= 300) bucket = '1-5min';
      else if (secs <= 900) bucket = '5-15min';
      else if (secs <= 1800) bucket = '15-30min';
      else if (secs <= 3600) bucket = '30-60min';
      else bucket = '60min+';
      durationBuckets.set(bucket, (durationBuckets.get(bucket) || 0) + 1);

      longestSpells.push({ name: spell.fields[SF.NAME], category, ticks, formula, value });
    }
  }

  // Duration type breakdown
  const total = instantCount + permanentCount + timedCount;
  lines.push('', '## Duration Type Breakdown', '');
  lines.push('| Type | Count | % |');
  lines.push('|------|------:|---:|');
  lines.push(`| Instant/No Duration | ${instantCount.toLocaleString()} | ${((instantCount / total) * 100).toFixed(1)}% |`);
  lines.push(`| Timed | ${timedCount.toLocaleString()} | ${((timedCount / total) * 100).toFixed(1)}% |`);
  lines.push(`| Permanent | ${permanentCount.toLocaleString()} | ${((permanentCount / total) * 100).toFixed(1)}% |`);

  // Duration formulas
  lines.push('', '## Duration Formulas Used', '');
  lines.push('| Formula | Count | Description |');
  lines.push('|--------:|------:|:-----------|');
  const formulaDescs: Record<number, string> = {
    0: 'Instant/None', 1: 'value ticks (linear)', 2: '(value/2)+5 ticks',
    3: 'value*30 ticks', 4: 'value*4.5 ticks', 5: 'value ticks',
    6: '(value+1)/2 ticks', 7: 'value ticks', 8: 'value+10 ticks',
    9: 'value*2+10 ticks', 10: 'value*3+10 ticks', 11: '(value+3)*30 ticks',
    12: 'value/2 ticks', 15: 'value ticks', 50: 'Permanent', 3600: 'Permanent'
  };
  const sortedFormulas = [...formulaCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [f, count] of sortedFormulas.slice(0, 20)) {
    lines.push(`| ${f} | ${count.toLocaleString()} | ${formulaDescs[f] || 'Other'} |`);
  }

  // Duration distribution buckets
  const bucketOrder = ['≤6s (1 tick)', '7-18s', '19-60s', '1-5min', '5-15min', '15-30min', '30-60min', '60min+'];
  lines.push('', '## Duration Distribution (Timed Spells)', '');
  lines.push('| Duration Range | Count | % |');
  lines.push('|:---------------|------:|---:|');
  for (const bucket of bucketOrder) {
    const count = durationBuckets.get(bucket) || 0;
    if (count > 0) {
      lines.push(`| ${bucket} | ${count.toLocaleString()} | ${((count / timedCount) * 100).toFixed(1)}% |`);
    }
  }

  // Average duration by category (top 20)
  lines.push('', '## Average Duration by Spell Category (Top 20)', '');
  lines.push('| Category | Avg Duration | Spells | Min | Max |');
  lines.push('|:---------|:-------------|------:|:----|:----|');
  const catAvgs = [...categoryDurations.entries()]
    .filter(([, durations]) => durations.length >= 5)
    .map(([cat, durations]) => {
      durations.sort((a, b) => a - b);
      const avg = durations.reduce((s, d) => s + d, 0) / durations.length;
      return { cat, avg, count: durations.length, min: durations[0], max: durations[durations.length - 1] };
    })
    .sort((a, b) => b.avg - a.avg);
  for (const { cat, avg, count, min, max } of catAvgs.slice(0, 20)) {
    const fmtTime = (s: number) => s >= 3600 ? `${(s / 3600).toFixed(1)}h` : s >= 60 ? `${(s / 60).toFixed(1)}m` : `${s}s`;
    lines.push(`| ${cat} | ${fmtTime(avg)} | ${count} | ${fmtTime(min)} | ${fmtTime(max)} |`);
  }

  // Longest spells
  longestSpells.sort((a, b) => b.ticks - a.ticks);
  lines.push('', '## Longest Timed Spells', '');
  lines.push('| Spell | Category | Duration | Formula |');
  lines.push('|:------|:---------|:---------|--------:|');
  for (const s of longestSpells.slice(0, 20)) {
    const secs = s.ticks * 6;
    const fmtTime = secs >= 3600 ? `${(secs / 3600).toFixed(1)}h` : secs >= 60 ? `${(secs / 60).toFixed(1)}m` : `${secs}s`;
    lines.push(`| ${s.name} | ${s.category} | ${fmtTime} | ${s.formula} |`);
  }

  lines.push('', '## Summary', '');
  lines.push(`- **Total spells:** ${total.toLocaleString()}`);
  lines.push(`- **Instant/None:** ${instantCount.toLocaleString()}`);
  lines.push(`- **Timed:** ${timedCount.toLocaleString()}`);
  lines.push(`- **Permanent:** ${permanentCount.toLocaleString()}`);
  lines.push(`- **Duration formulas used:** ${formulaCounts.size}`);
  lines.push(`- **Categories with timed spells:** ${categoryDurations.size}`);

  lines.push('', `*${total.toLocaleString()} spells analyzed for duration patterns.*`);
  return lines.join('\n');
}

// Tool 247: AA ability rank analysis
export async function getAAAbilityRankAnalysis(): Promise<string> {
  await loadAAAbilities();
  if (!aaAbilities || aaAbilities.size === 0) return 'AA ability data not available.';

  const lines: string[] = ['# AA Ability Rank Analysis', '', '*Analyze AA naming patterns, rank progressions, and keyword themes.*'];

  // Parse rank suffixes
  const rankPattern = /^(.*?)\s+((?:Rk\.\s*)?(?:I{1,3}V?|IV|VI{0,3}|IX|X{0,3}|[0-9]+))$/;
  const baseCounts = new Map<string, number>();
  const maxRanks = new Map<string, number>();
  let rankedCount = 0;
  let unrankedCount = 0;
  const rankDistribution = new Map<string, number>();
  const wordFreq = new Map<string, number>();
  const descKeywords = new Map<string, number>();

  // Roman numeral converter
  const romanToInt = (s: string): number => {
    const rk = s.replace(/^Rk\.?\s*/, '');
    const romanMap: Record<string, number> = { I: 1, V: 5, X: 10 };
    let val = 0;
    for (let i = 0; i < rk.length; i++) {
      const curr = romanMap[rk[i]] || 0;
      const next = romanMap[rk[i + 1]] || 0;
      val += curr < next ? -curr : curr;
    }
    return val || parseInt(rk) || 1;
  };

  for (const aa of aaAbilities.values()) {
    const match = aa.name.match(rankPattern);
    if (match) {
      rankedCount++;
      const base = match[1].trim();
      const rankStr = match[2];
      const rankNum = romanToInt(rankStr);
      baseCounts.set(base, (baseCounts.get(base) || 0) + 1);
      const prev = maxRanks.get(base) || 0;
      if (rankNum > prev) maxRanks.set(base, rankNum);
      rankDistribution.set(rankStr, (rankDistribution.get(rankStr) || 0) + 1);
    } else {
      unrankedCount++;
      baseCounts.set(aa.name, (baseCounts.get(aa.name) || 0) + 1);
    }

    // Word frequency in names
    const words = aa.name.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter((w: string) => w.length >= 3);
    for (const w of words) {
      wordFreq.set(w, (wordFreq.get(w) || 0) + 1);
    }

    // Description keyword analysis
    if (aa.description) {
      const descWords = aa.description.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter((w: string) => w.length >= 5);
      for (const w of descWords) {
        descKeywords.set(w, (descKeywords.get(w) || 0) + 1);
      }
    }
  }

  // Ranked vs unranked
  lines.push('', '## Rank Distribution', '');
  lines.push(`- **Ranked AAs:** ${rankedCount.toLocaleString()} (${((rankedCount / aaAbilities.size) * 100).toFixed(1)}%)`);
  lines.push(`- **Unranked AAs:** ${unrankedCount.toLocaleString()} (${((unrankedCount / aaAbilities.size) * 100).toFixed(1)}%)`);
  lines.push(`- **Unique base abilities:** ${maxRanks.size}`);

  // Rank suffix distribution
  lines.push('', '## Rank Suffix Distribution', '');
  lines.push('| Rank | Count |');
  lines.push('|:-----|------:|');
  const sortedRanks = [...rankDistribution.entries()].sort((a, b) => b[1] - a[1]);
  for (const [rank, count] of sortedRanks.slice(0, 20)) {
    lines.push(`| ${rank} | ${count.toLocaleString()} |`);
  }

  // Deepest rank progressions
  lines.push('', '## Deepest Rank Progressions', '');
  lines.push('| Ability | Max Rank | Versions |');
  lines.push('|:--------|:---------|--------:|');
  const deepest = [...maxRanks.entries()].sort((a, b) => b[1] - a[1]);
  for (const [base, maxRank] of deepest.slice(0, 25)) {
    const versions = baseCounts.get(base) || 0;
    lines.push(`| ${base} | ${maxRank} | ${versions} |`);
  }

  // Most common name words
  const stopWords = new Set(['the', 'of', 'and', 'to', 'in', 'for', 'rk', 'ii', 'iii', 'iv', 'vi', 'vii', 'viii', 'ix']);
  lines.push('', '## Most Common Words in AA Names', '');
  lines.push('| Word | Count |');
  lines.push('|:-----|------:|');
  const sortedWords = [...wordFreq.entries()].filter(([w]) => !stopWords.has(w)).sort((a, b) => b[1] - a[1]);
  for (const [word, count] of sortedWords.slice(0, 25)) {
    lines.push(`| ${word} | ${count.toLocaleString()} |`);
  }

  // Description themes
  const themeKeywords: Record<string, string[]> = {
    'Offense': ['damage', 'attack', 'critical', 'strike', 'melee', 'nuke'],
    'Defense': ['defense', 'resist', 'absorb', 'avoid', 'shield', 'block', 'parry', 'dodge'],
    'Healing': ['heal', 'health', 'mend', 'cure', 'restoration'],
    'Mana/Resources': ['mana', 'endurance', 'regenerate', 'conservation'],
    'Duration/Recast': ['duration', 'recast', 'cooldown', 'timer', 'refresh'],
    'Chance/Probability': ['chance', 'probability', 'trigger', 'proc'],
  };
  lines.push('', '## AA Description Themes', '');
  lines.push('| Theme | AAs Mentioning |');
  lines.push('|:------|---------------:|');
  const themeCounts: [string, number][] = [];
  for (const [theme, keywords] of Object.entries(themeKeywords)) {
    let count = 0;
    for (const aa of aaAbilities.values()) {
      if (!aa.description) continue;
      const desc = aa.description.toLowerCase();
      if (keywords.some(k => desc.includes(k))) count++;
    }
    themeCounts.push([theme, count]);
  }
  themeCounts.sort((a, b) => b[1] - a[1]);
  for (const [theme, count] of themeCounts) {
    lines.push(`| ${theme} | ${count.toLocaleString()} |`);
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Total AAs:** ${aaAbilities.size.toLocaleString()}`);
  lines.push(`- **Unique base abilities:** ${maxRanks.size}`);
  lines.push(`- **Highest rank found:** ${Math.max(...maxRanks.values())}`);
  lines.push(`- **Most common word:** ${sortedWords[0]?.[0] || '-'} (${sortedWords[0]?.[1] || 0})`);

  lines.push('', `*${aaAbilities.size.toLocaleString()} AA abilities analyzed.*`);
  return lines.join('\n');
}

// Tool 248: Spell recast timer analysis
export async function getSpellRecastTimerAnalysis(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells || spells.size === 0) return 'Spell data not available.';

  const lines: string[] = ['# Spell Recast Timer Analysis', '', '*Analyze recast timers, shared timer groups, and cooldown patterns.*'];

  const timerGroups = new Map<number, { name: string; recast: number; category: string; level: number }[]>();
  const recastBuckets = new Map<string, number>();
  const categoryRecasts = new Map<string, number[]>();
  let noRecastCount = 0;
  let hasRecastCount = 0;
  const longestRecasts: { name: string; recastMs: number; category: string; timerId: number }[] = [];

  for (const spell of spells.values()) {
    const recastMs = parseInt(spell.fields[SF.RECAST_TIME]) || 0;
    const timerId = parseInt(spell.fields[SF.TIMER_ID]) || 0;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const category = spellCategories?.get(catId) || 'Unknown';
    const name = spell.fields[SF.NAME];

    // Find min class level
    let minLevel = 255;
    for (let c = 0; c < 16; c++) {
      const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + c]) || 255;
      if (lv > 0 && lv < minLevel) minLevel = lv;
    }

    if (recastMs <= 0) {
      noRecastCount++;
    } else {
      hasRecastCount++;
      const recastSec = recastMs / 1000;

      // Timer group tracking
      if (timerId > 0) {
        if (!timerGroups.has(timerId)) timerGroups.set(timerId, []);
        timerGroups.get(timerId)!.push({ name, recast: recastSec, category, level: minLevel });
      }

      // Bucket
      let bucket: string;
      if (recastSec <= 6) bucket = '≤6s';
      else if (recastSec <= 15) bucket = '7-15s';
      else if (recastSec <= 30) bucket = '16-30s';
      else if (recastSec <= 60) bucket = '31-60s';
      else if (recastSec <= 300) bucket = '1-5min';
      else if (recastSec <= 900) bucket = '5-15min';
      else if (recastSec <= 1800) bucket = '15-30min';
      else bucket = '30min+';
      recastBuckets.set(bucket, (recastBuckets.get(bucket) || 0) + 1);

      // Category tracking
      if (!categoryRecasts.has(category)) categoryRecasts.set(category, []);
      categoryRecasts.get(category)!.push(recastSec);

      longestRecasts.push({ name, recastMs, category, timerId });
    }
  }

  // Recast vs no-recast
  const total = noRecastCount + hasRecastCount;
  lines.push('', '## Recast Overview', '');
  lines.push(`- **Spells with recast timer:** ${hasRecastCount.toLocaleString()} (${((hasRecastCount / total) * 100).toFixed(1)}%)`);
  lines.push(`- **Spells without recast:** ${noRecastCount.toLocaleString()} (${((noRecastCount / total) * 100).toFixed(1)}%)`);
  lines.push(`- **Shared timer groups:** ${timerGroups.size}`);

  // Recast distribution
  const bucketOrder = ['≤6s', '7-15s', '16-30s', '31-60s', '1-5min', '5-15min', '15-30min', '30min+'];
  lines.push('', '## Recast Timer Distribution', '');
  lines.push('| Range | Count | % |');
  lines.push('|:------|------:|---:|');
  for (const bucket of bucketOrder) {
    const count = recastBuckets.get(bucket) || 0;
    if (count > 0) {
      lines.push(`| ${bucket} | ${count.toLocaleString()} | ${((count / hasRecastCount) * 100).toFixed(1)}% |`);
    }
  }

  // Largest shared timer groups
  lines.push('', '## Largest Shared Timer Groups', '');
  lines.push('| Timer ID | Spells | Avg Recast | Sample Spells |');
  lines.push('|---------:|-------:|:-----------|:-------------|');
  const sortedGroups = [...timerGroups.entries()].sort((a, b) => b[1].length - a[1].length);
  for (const [timerId, group] of sortedGroups.slice(0, 25)) {
    const avgRecast = group.reduce((s, g) => s + g.recast, 0) / group.length;
    const fmtTime = avgRecast >= 60 ? `${(avgRecast / 60).toFixed(1)}m` : `${avgRecast.toFixed(1)}s`;
    const samples = group.slice(0, 3).map(g => g.name).join(', ');
    lines.push(`| ${timerId} | ${group.length} | ${fmtTime} | ${samples} |`);
  }

  // Average recast by category
  lines.push('', '## Average Recast by Spell Category', '');
  lines.push('| Category | Avg Recast | Spells | Max Recast |');
  lines.push('|:---------|:-----------|------:|:-----------|');
  const catAvgs = [...categoryRecasts.entries()]
    .filter(([, durations]) => durations.length >= 3)
    .map(([cat, durations]) => {
      const avg = durations.reduce((s, d) => s + d, 0) / durations.length;
      const max = Math.max(...durations);
      return { cat, avg, count: durations.length, max };
    })
    .sort((a, b) => b.avg - a.avg);
  for (const { cat, avg, count, max } of catAvgs.slice(0, 20)) {
    const fmtTime = (s: number) => s >= 3600 ? `${(s / 3600).toFixed(1)}h` : s >= 60 ? `${(s / 60).toFixed(1)}m` : `${s.toFixed(1)}s`;
    lines.push(`| ${cat} | ${fmtTime(avg)} | ${count} | ${fmtTime(max)} |`);
  }

  // Longest recasts
  longestRecasts.sort((a, b) => b.recastMs - a.recastMs);
  lines.push('', '## Longest Recast Timers', '');
  lines.push('| Spell | Category | Recast | Timer ID |');
  lines.push('|:------|:---------|:-------|--------:|');
  for (const s of longestRecasts.slice(0, 20)) {
    const secs = s.recastMs / 1000;
    const fmtTime = secs >= 3600 ? `${(secs / 3600).toFixed(1)}h` : secs >= 60 ? `${(secs / 60).toFixed(1)}m` : `${secs.toFixed(1)}s`;
    lines.push(`| ${s.name} | ${s.category} | ${fmtTime} | ${s.timerId || '-'} |`);
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Total spells:** ${total.toLocaleString()}`);
  lines.push(`- **With recast:** ${hasRecastCount.toLocaleString()}`);
  lines.push(`- **Shared timer groups:** ${timerGroups.size}`);
  lines.push(`- **Largest timer group:** Timer ${sortedGroups[0]?.[0] || '-'} (${sortedGroups[0]?.[1].length || 0} spells)`);

  lines.push('', `*${total.toLocaleString()} spells analyzed for recast patterns.*`);
  return lines.join('\n');
}

// Tool 249: Skill cap progression analysis
export async function getSkillCapProgressionAnalysis(className: string): Promise<string> {
  await loadSkillCaps();
  if (!skillCaps || skillCaps.length === 0) return 'Skill cap data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) =>
    name.toLowerCase() === className.toLowerCase()
  )?.[0];
  if (!classId) {
    const validClasses = Object.values(CLASS_IDS).join(', ');
    return `Unknown class "${className}". Valid classes: ${validClasses}`;
  }
  const cid = parseInt(classId);
  const classShort = CLASS_SHORT[cid] || className;
  const classFullName = CLASS_IDS[cid];

  const lines: string[] = [`# Skill Cap Progression: ${classFullName} (${classShort})`, '', '*Skill cap growth, available skills, and max caps.*'];

  // Filter class skills
  const classSkills = skillCaps.filter(e => e.classId === cid);
  if (classSkills.length === 0) return `No skill cap data found for ${classFullName}.`;

  // Group by skill
  const bySkill = new Map<number, { level: number; cap: number }[]>();
  for (const entry of classSkills) {
    if (!bySkill.has(entry.skillId)) bySkill.set(entry.skillId, []);
    bySkill.get(entry.skillId)!.push({ level: entry.level, cap: entry.cap });
  }

  // Categorize skills
  const combatSkills = [0, 1, 2, 3, 7, 8, 10, 11, 15, 16, 19, 20, 21, 22, 23, 26, 28, 30, 33, 34, 36, 37, 38, 51, 52, 73, 74, 76, 77];
  const casterSkills = [4, 5, 13, 14, 18, 24, 31, 43, 44, 45, 46, 47];
  const utilitySkills = [6, 9, 17, 25, 27, 29, 35, 39, 40, 42, 48, 50, 53, 55, 62, 66, 67, 71, 75];
  const tradeskills = [56, 57, 58, 59, 60, 61, 63, 64, 65, 68, 69];
  const instrumentSkills = [12, 41, 49, 54, 70];

  const categorize = (skillId: number): string => {
    if (combatSkills.includes(skillId)) return 'Combat';
    if (casterSkills.includes(skillId)) return 'Casting';
    if (utilitySkills.includes(skillId)) return 'Utility';
    if (tradeskills.includes(skillId)) return 'Tradeskill';
    if (instrumentSkills.includes(skillId)) return 'Instrument';
    return 'Other';
  };

  // Max cap per skill
  const skillMaxCaps: { skillId: number; name: string; maxCap: number; category: string; startLevel: number }[] = [];
  for (const [skillId, entries] of bySkill) {
    entries.sort((a, b) => a.level - b.level);
    const maxCap = Math.max(...entries.map(e => e.cap));
    const startLevel = entries.find(e => e.cap > 0)?.level || entries[0].level;
    skillMaxCaps.push({
      skillId,
      name: SKILL_NAMES[skillId] || `Skill ${skillId}`,
      maxCap,
      category: categorize(skillId),
      startLevel
    });
  }
  skillMaxCaps.sort((a, b) => a.category.localeCompare(b.category) || b.maxCap - a.maxCap);

  // Skills by category
  const catGroups = new Map<string, typeof skillMaxCaps>();
  for (const s of skillMaxCaps) {
    if (!catGroups.has(s.category)) catGroups.set(s.category, []);
    catGroups.get(s.category)!.push(s);
  }

  lines.push('', '## Category Summary', '');
  lines.push('| Category | Skills | Avg Max Cap | Highest |');
  lines.push('|:---------|-------:|------------:|:--------|');
  for (const [cat, skills] of catGroups) {
    const avg = skills.reduce((s, sk) => s + sk.maxCap, 0) / skills.length;
    const best = skills.reduce((a, b) => a.maxCap > b.maxCap ? a : b);
    lines.push(`| ${cat} | ${skills.length} | ${avg.toFixed(0)} | ${best.name} (${best.maxCap}) |`);
  }

  // Full skill list
  lines.push('', '## All Skills', '');
  lines.push('| Skill | Category | Start Level | Max Cap |');
  lines.push('|:------|:---------|------------:|--------:|');
  for (const s of skillMaxCaps) {
    lines.push(`| ${s.name} | ${s.category} | ${s.startLevel} | ${s.maxCap} |`);
  }

  // Growth milestones for top 5 combat skills
  const topCombat = skillMaxCaps.filter(s => s.category === 'Combat').slice(0, 5);
  if (topCombat.length > 0) {
    lines.push('', '## Top Combat Skill Growth', '');
    const levels = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120];
    const header = ['Level', ...topCombat.map(s => s.name)];
    lines.push(`| ${header.join(' | ')} |`);
    lines.push(`|${header.map(() => '------:').join('|')}|`);
    for (const lv of levels) {
      const row = [String(lv)];
      for (const s of topCombat) {
        const entries = bySkill.get(s.skillId) || [];
        const capAtLevel = entries.filter(e => e.level <= lv).reduce((max, e) => Math.max(max, e.cap), 0);
        row.push(String(capAtLevel));
      }
      lines.push(`| ${row.join(' | ')} |`);
    }
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Class:** ${classFullName}`);
  lines.push(`- **Total skills:** ${bySkill.size}`);
  lines.push(`- **Combat skills:** ${catGroups.get('Combat')?.length || 0}`);
  lines.push(`- **Casting skills:** ${catGroups.get('Casting')?.length || 0}`);
  lines.push(`- **Highest skill cap:** ${Math.max(...skillMaxCaps.map(s => s.maxCap))}`);

  lines.push('', `*${bySkill.size} skills analyzed for ${classFullName}.*`);
  return lines.join('\n');
}

// Tool 250: Base stat growth curve analysis
export async function getBaseStatGrowthCurveAnalysis(className: string): Promise<string> {
  await loadBaseStats();
  if (!baseStats || baseStats.length === 0) return 'Base stat data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) =>
    name.toLowerCase() === className.toLowerCase()
  )?.[0];
  if (!classId) {
    const validClasses = Object.values(CLASS_IDS).join(', ');
    return `Unknown class "${className}". Valid classes: ${validClasses}`;
  }
  const cid = parseInt(classId);
  const classShort = CLASS_SHORT[cid] || className;
  const classFullName = CLASS_IDS[cid];

  const lines: string[] = [`# Base Stat Growth Curves: ${classFullName} (${classShort})`, '', '*HP, Mana, Endurance, and Regen growth by level.*'];

  // Filter class stats
  const classStats = baseStats.filter(e => e.classId === cid);
  if (classStats.length === 0) return `No base stat data found for ${classFullName}.`;

  classStats.sort((a, b) => a.level - b.level);

  // Milestone levels
  const milestones = [1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125];
  const getStatAtLevel = (level: number): BaseStatEntry | undefined =>
    classStats.find(e => e.level === level) || classStats.filter(e => e.level <= level).pop();

  lines.push('', '## Pool Growth', '');
  lines.push('| Level | HP | Mana | Endurance |');
  lines.push('|------:|---:|-----:|----------:|');
  for (const lv of milestones) {
    const stat = getStatAtLevel(lv);
    if (stat) {
      lines.push(`| ${lv} | ${stat.hp.toLocaleString()} | ${stat.mana.toLocaleString()} | ${stat.endurance.toLocaleString()} |`);
    }
  }

  // Regen growth
  lines.push('', '## Regen Growth', '');
  lines.push('| Level | HP Regen | Mana Regen | End Regen |');
  lines.push('|------:|---------:|-----------:|----------:|');
  for (const lv of milestones) {
    const stat = getStatAtLevel(lv);
    if (stat) {
      lines.push(`| ${lv} | ${stat.hpRegen} | ${stat.manaRegen} | ${stat.enduranceRegen} |`);
    }
  }

  // Growth rates (deltas between milestones)
  lines.push('', '## Growth Rates (Per 10 Levels)', '');
  lines.push('| Range | HP Growth | Mana Growth | End Growth |');
  lines.push('|:------|----------:|------------:|-----------:|');
  const growthLevels = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120];
  for (let i = 1; i < growthLevels.length; i++) {
    const prev = getStatAtLevel(growthLevels[i - 1]);
    const curr = getStatAtLevel(growthLevels[i]);
    if (prev && curr) {
      const hpGrowth = curr.hp - prev.hp;
      const manaGrowth = curr.mana - prev.mana;
      const endGrowth = curr.endurance - prev.endurance;
      lines.push(`| ${growthLevels[i - 1]}-${growthLevels[i]} | +${hpGrowth.toLocaleString()} | +${manaGrowth.toLocaleString()} | +${endGrowth.toLocaleString()} |`);
    }
  }

  // Class comparison at level 100
  lines.push('', '## Class Comparison at Level 100', '');
  lines.push('| Class | HP | Mana | Endurance | HP Regen |');
  lines.push('|:------|---:|-----:|----------:|---------:|');
  const allClasses: { classId: number; name: string; hp: number; mana: number; end: number; hpRegen: number }[] = [];
  for (let c = 1; c <= 16; c++) {
    const stat = baseStats.find(e => e.classId === c && e.level === 100);
    if (stat) {
      allClasses.push({ classId: c, name: CLASS_IDS[c] || `Class ${c}`, hp: stat.hp, mana: stat.mana, end: stat.endurance, hpRegen: stat.hpRegen });
    }
  }
  allClasses.sort((a, b) => b.hp - a.hp);
  for (const c of allClasses) {
    const marker = c.classId === cid ? ' **' : '';
    lines.push(`| ${c.name}${marker} | ${c.hp.toLocaleString()} | ${c.mana.toLocaleString()} | ${c.end.toLocaleString()} | ${c.hpRegen} |`);
  }

  // Peak stats
  const maxStat = classStats[classStats.length - 1];
  lines.push('', '## Summary', '');
  lines.push(`- **Class:** ${classFullName}`);
  lines.push(`- **Level range:** ${classStats[0].level}-${maxStat.level}`);
  lines.push(`- **Max HP:** ${maxStat.hp.toLocaleString()} (level ${maxStat.level})`);
  lines.push(`- **Max Mana:** ${maxStat.mana.toLocaleString()}`);
  lines.push(`- **Max Endurance:** ${maxStat.endurance.toLocaleString()}`);
  lines.push(`- **HP/Mana ratio:** ${maxStat.mana > 0 ? (maxStat.hp / maxStat.mana).toFixed(2) : 'N/A'}`);

  lines.push('', `*${classStats.length} level entries analyzed for ${classFullName}.*`);
  return lines.join('\n');
}

// Tool 251: Overseer quest difficulty analysis
export async function getOverseerQuestDifficultyAnalysis(): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerMinions();
  await loadOverseerEnhancements();
  if (!overseerQuests || overseerQuests.size === 0) return 'Overseer quest data not available.';

  const lines: string[] = ['# Overseer Quest Difficulty Analysis', '', '*Analyze quest difficulty distributions, duration patterns, slot requirements, and category breakdowns.*'];

  const difficultyDist = new Map<number, number>();
  const durationDist = new Map<number, number>();
  const categoryDist = new Map<string, number>();
  const slotsPerDifficulty = new Map<number, { required: number[]; optional: number[] }>();
  const jobDemand = new Map<number, number>();
  const questsByDifficulty: { name: string; difficulty: number; duration: number; category: string; slots: number }[] = [];

  for (const quest of overseerQuests.values()) {
    const diff = quest.difficulty;
    difficultyDist.set(diff, (difficultyDist.get(diff) || 0) + 1);
    durationDist.set(quest.duration, (durationDist.get(quest.duration) || 0) + 1);

    const catName = overseerCategories?.get(quest.categoryId) || `Category ${quest.categoryId}`;
    categoryDist.set(catName, (categoryDist.get(catName) || 0) + 1);

    if (!slotsPerDifficulty.has(diff)) slotsPerDifficulty.set(diff, { required: [], optional: [] });
    slotsPerDifficulty.get(diff)!.required.push(quest.requiredSlots);
    slotsPerDifficulty.get(diff)!.optional.push(quest.optionalSlots);

    for (const slot of quest.slotDetails) {
      jobDemand.set(slot.jobTypeId, (jobDemand.get(slot.jobTypeId) || 0) + 1);
    }

    questsByDifficulty.push({
      name: quest.name,
      difficulty: diff,
      duration: quest.duration,
      category: catName,
      slots: quest.requiredSlots + quest.optionalSlots
    });
  }

  // Difficulty distribution
  lines.push('', '## Difficulty Distribution', '');
  lines.push('| Difficulty | Name | Quests | % |');
  lines.push('|-----------:|:-----|-------:|---:|');
  const sortedDiffs = [...difficultyDist.entries()].sort((a, b) => a[0] - b[0]);
  for (const [diff, count] of sortedDiffs) {
    const name = overseerDifficulties?.get(diff) || `Level ${diff}`;
    lines.push(`| ${diff} | ${name} | ${count} | ${((count / overseerQuests.size) * 100).toFixed(1)}% |`);
  }

  // Duration distribution
  lines.push('', '## Duration Distribution', '');
  lines.push('| Duration | Quests | % |');
  lines.push('|:---------|-------:|---:|');
  const sortedDurations = [...durationDist.entries()].sort((a, b) => a[0] - b[0]);
  for (const [dur, count] of sortedDurations) {
    lines.push(`| ${dur}h | ${count} | ${((count / overseerQuests.size) * 100).toFixed(1)}% |`);
  }

  // Category breakdown
  lines.push('', '## Quest Categories', '');
  lines.push('| Category | Quests | % |');
  lines.push('|:---------|-------:|---:|');
  const sortedCats = [...categoryDist.entries()].sort((a, b) => b[1] - a[1]);
  for (const [cat, count] of sortedCats) {
    lines.push(`| ${cat} | ${count} | ${((count / overseerQuests.size) * 100).toFixed(1)}% |`);
  }

  // Slots by difficulty
  lines.push('', '## Average Slots by Difficulty', '');
  lines.push('| Difficulty | Avg Required | Avg Optional | Avg Total |');
  lines.push('|-----------:|-------------:|-------------:|----------:|');
  for (const [diff] of sortedDiffs) {
    const data = slotsPerDifficulty.get(diff)!;
    const avgReq = data.required.reduce((s, v) => s + v, 0) / data.required.length;
    const avgOpt = data.optional.reduce((s, v) => s + v, 0) / data.optional.length;
    lines.push(`| ${diff} | ${avgReq.toFixed(1)} | ${avgOpt.toFixed(1)} | ${(avgReq + avgOpt).toFixed(1)} |`);
  }

  // Most demanded job types
  lines.push('', '## Most Demanded Job Types', '');
  lines.push('| Job Type | Demand (Slots) |');
  lines.push('|:---------|---------------:|');
  const sortedJobs = [...jobDemand.entries()].sort((a, b) => b[1] - a[1]);
  for (const [jobId, count] of sortedJobs.slice(0, 20)) {
    const jobName = overseerJobNames?.get(jobId) || `Job ${jobId}`;
    lines.push(`| ${jobName} | ${count} |`);
  }

  // Highest slot quests
  questsByDifficulty.sort((a, b) => b.slots - a.slots);
  lines.push('', '## Quests with Most Slots', '');
  lines.push('| Quest | Category | Difficulty | Slots | Duration |');
  lines.push('|:------|:---------|----------:|------:|:---------|');
  for (const q of questsByDifficulty.slice(0, 15)) {
    lines.push(`| ${q.name} | ${q.category} | ${q.difficulty} | ${q.slots} | ${q.duration}h |`);
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Total quests:** ${overseerQuests.size}`);
  lines.push(`- **Difficulty levels:** ${difficultyDist.size}`);
  lines.push(`- **Categories:** ${categoryDist.size}`);
  lines.push(`- **Unique durations:** ${durationDist.size}`);
  lines.push(`- **Job types demanded:** ${jobDemand.size}`);

  lines.push('', `*${overseerQuests.size} overseer quests analyzed.*`);
  return lines.join('\n');
}

// ============ DATA SNAPSHOT / DIFF SYSTEM ============

interface DataSnapshotSystem {
  count: number;
  names: Record<string, string>; // id → name
}

interface DataSnapshot {
  version: number;
  timestamp: string;
  eqPath: string;
  files: Record<string, { size: number; mtime: string }>;
  systems: Record<string, DataSnapshotSystem>;
}

const SNAPSHOT_FILE = '.eq-mcp-snapshot.json';
const SNAPSHOT_VERSION = 1;

// Tracked game files (relative to EQ install dir)
const TRACKED_FILES = [
  'spells_us.txt',
  'spells_us_str.txt',
  'dbstr_us.txt',
  'eqstr_us.txt',
  join('Resources', 'ZoneNames.txt'),
  join('Resources', 'skillcaps.txt'),
  join('Resources', 'basedata.txt'),
  join('Resources', 'ACMitigation.txt'),
  join('Resources', 'SpellStackingGroups.txt'),
  join('Resources', 'playercustomization.txt'),
  join('Resources', 'Achievements', 'AchievementsClient.txt'),
  join('Resources', 'Achievements', 'AchievementCategories.txt'),
  join('Resources', 'Faction', 'FactionBaseData.txt'),
  join('Resources', 'OvrMiniClient.txt'),
  join('Resources', 'OvrQstClient.txt'),
];

function snapshotPath(): string {
  return gamePath(SNAPSHOT_FILE);
}

async function getFileMetadata(relativePath: string): Promise<{ size: number; mtime: string } | null> {
  try {
    const fullPath = gamePath(relativePath);
    const s = await stat(fullPath);
    return { size: s.size, mtime: s.mtime.toISOString() };
  } catch {
    return null;
  }
}

function simpleHash(data: string): string {
  return createHash('md5').update(data).digest('hex').slice(0, 12);
}

async function gatherCurrentState(): Promise<{ files: Record<string, { size: number; mtime: string }>; systems: Record<string, DataSnapshotSystem> }> {
  // Gather file metadata
  const files: Record<string, { size: number; mtime: string }> = {};
  for (const f of TRACKED_FILES) {
    const meta = await getFileMetadata(f);
    if (meta) files[f] = meta;
  }

  // Load all data systems
  await loadSpells();
  await loadZones();
  await loadFactions();
  await loadAchievements();
  await loadAchievementCategories();
  await loadAAAbilities();
  await loadOverseerMinions();
  await loadOverseerQuests();
  await loadMercenaries();
  await loadSkillCaps();
  await loadBaseStats();
  await loadGameStrings();
  await loadGameEvents();
  await loadTributes();
  await loadLore();
  await loadCombatAbilities();
  await loadSpellDescriptions();
  await loadPlayerCustomization();

  const systems: Record<string, DataSnapshotSystem> = {};

  // Spells
  if (spells && spells.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, spell] of spells) names[String(id)] = spell.fields[SF.NAME];
    systems['spells'] = { count: spells.size, names };
  }

  // Zones
  if (zones && zones.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, zone] of zones) names[String(id)] = zone.name;
    systems['zones'] = { count: zones.size, names };
  }

  // Factions
  if (factions && factions.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, faction] of factions) names[String(id)] = faction.name;
    systems['factions'] = { count: factions.size, names };
  }

  // Achievements
  if (achievements && achievements.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, ach] of achievements) names[String(id)] = ach.name;
    systems['achievements'] = { count: achievements.size, names };
  }

  // AA Abilities
  if (aaAbilities && aaAbilities.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, aa] of aaAbilities) names[String(id)] = aa.name;
    systems['aaAbilities'] = { count: aaAbilities.size, names };
  }

  // Overseer Minions
  if (overseerMinions && overseerMinions.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, m] of overseerMinions) names[String(id)] = m.fullName || m.shortName;
    systems['overseerMinions'] = { count: overseerMinions.size, names };
  }

  // Overseer Quests
  if (overseerQuests && overseerQuests.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, q] of overseerQuests) names[String(id)] = q.name;
    systems['overseerQuests'] = { count: overseerQuests.size, names };
  }

  // Mercenaries
  if (mercenaries && mercenaries.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, m] of mercenaries) names[String(id)] = m.description || `Merc ${id}`;
    systems['mercenaries'] = { count: mercenaries.size, names };
  }

  // Game Strings
  if (gameStrings && gameStrings.size > 0) {
    systems['gameStrings'] = { count: gameStrings.size, names: {} }; // Too large for name map
  }

  // Tributes
  if (tributes && tributes.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, t] of tributes) names[String(id)] = t.name;
    systems['tributes'] = { count: tributes.size, names };
  }

  // Lore
  if (loreEntries) {
    const names: Record<string, string> = {};
    loreEntries.forEach((e, i) => { names[String(i)] = e.title; });
    systems['lore'] = { count: loreEntries.length, names };
  }

  // Combat Abilities
  if (combatAbilities && combatAbilities.size > 0) {
    const names: Record<string, string> = {};
    for (const [id, name] of combatAbilities) names[String(id)] = name;
    systems['combatAbilities'] = { count: combatAbilities.size, names };
  }

  // Spell Categories
  if (spellCategories && spellCategories.size > 0) {
    systems['spellCategories'] = { count: spellCategories.size, names: {} };
  }

  // Player Customization
  if (playerCustomization && playerCustomization.length > 0) {
    systems['playerCustomization'] = { count: playerCustomization.length, names: {} };
  }

  return { files, systems };
}

async function loadSnapshot(): Promise<DataSnapshot | null> {
  try {
    const data = await readFile(snapshotPath(), 'utf-8');
    return JSON.parse(data) as DataSnapshot;
  } catch {
    return null;
  }
}

// Tool 252: Save data snapshot
export async function saveDataSnapshot(): Promise<string> {
  if (!isGameDataAvailable()) return 'EQ game data not available.';

  const { files, systems } = await gatherCurrentState();

  const snapshot: DataSnapshot = {
    version: SNAPSHOT_VERSION,
    timestamp: new Date().toISOString(),
    eqPath: EQ_GAME_PATH,
    files,
    systems,
  };

  const json = JSON.stringify(snapshot, null, 2);
  await writeFile(snapshotPath(), json, 'utf-8');

  const lines: string[] = ['# Data Snapshot Saved', ''];
  lines.push(`**Timestamp:** ${snapshot.timestamp}`);
  lines.push(`**Location:** ${snapshotPath()}`);
  lines.push(`**Size:** ${(json.length / 1024).toFixed(1)} KB`);
  lines.push('', '## Captured Systems', '');
  lines.push('| System | Entries |');
  lines.push('|:-------|-------:|');
  for (const [name, sys] of Object.entries(systems).sort((a, b) => b[1].count - a[1].count)) {
    lines.push(`| ${name} | ${sys.count.toLocaleString()} |`);
  }
  lines.push('', '## Tracked Files', '');
  lines.push('| File | Size |');
  lines.push('|:-----|-----:|');
  for (const [name, meta] of Object.entries(files)) {
    lines.push(`| ${name} | ${(meta.size / 1024).toFixed(0)} KB |`);
  }
  lines.push('', '*Snapshot saved. Run `get_data_update_summary` after a patch to see what changed.*');
  return lines.join('\n');
}

// Tool 253: Get data update summary
export async function getDataUpdateSummary(): Promise<string> {
  if (!isGameDataAvailable()) return 'EQ game data not available.';

  const saved = await loadSnapshot();
  if (!saved) {
    return 'No saved snapshot found. Run `save_data_snapshot` first to create a baseline, then run this tool after a game update to see what changed.';
  }

  const { files: currentFiles, systems: currentSystems } = await gatherCurrentState();

  const lines: string[] = ['# Data Update Summary', ''];
  lines.push(`**Baseline snapshot:** ${saved.timestamp}`);
  lines.push(`**Current check:** ${new Date().toISOString()}`);

  // File changes
  lines.push('', '## File Changes', '');
  lines.push('| File | Status | Old Size | New Size | Delta |');
  lines.push('|:-----|:-------|--------:|---------:|------:|');
  let fileChanges = 0;
  const allFiles = new Set([...Object.keys(saved.files), ...Object.keys(currentFiles)]);
  for (const f of [...allFiles].sort()) {
    const old = saved.files[f];
    const cur = currentFiles[f];
    if (!old && cur) {
      lines.push(`| ${f} | **NEW** | - | ${(cur.size / 1024).toFixed(0)} KB | - |`);
      fileChanges++;
    } else if (old && !cur) {
      lines.push(`| ${f} | **REMOVED** | ${(old.size / 1024).toFixed(0)} KB | - | - |`);
      fileChanges++;
    } else if (old && cur && (old.size !== cur.size || old.mtime !== cur.mtime)) {
      const delta = cur.size - old.size;
      const sign = delta >= 0 ? '+' : '';
      lines.push(`| ${f} | **CHANGED** | ${(old.size / 1024).toFixed(0)} KB | ${(cur.size / 1024).toFixed(0)} KB | ${sign}${(delta / 1024).toFixed(1)} KB |`);
      fileChanges++;
    } else {
      lines.push(`| ${f} | unchanged | ${(old!.size / 1024).toFixed(0)} KB | ${(cur!.size / 1024).toFixed(0)} KB | 0 |`);
    }
  }

  // System changes
  lines.push('', '## System Entry Changes', '');
  lines.push('| System | Old Count | New Count | Added | Removed | Changed |');
  lines.push('|:-------|----------:|----------:|------:|--------:|--------:|');
  let totalAdded = 0, totalRemoved = 0, totalChanged = 0;
  const allSystems = new Set([...Object.keys(saved.systems), ...Object.keys(currentSystems)]);
  for (const sys of [...allSystems].sort()) {
    const old = saved.systems[sys];
    const cur = currentSystems[sys];
    if (!old && cur) {
      lines.push(`| ${sys} | - | ${cur.count.toLocaleString()} | ${cur.count} | 0 | 0 |`);
      totalAdded += cur.count;
    } else if (old && !cur) {
      lines.push(`| ${sys} | ${old.count.toLocaleString()} | - | 0 | ${old.count} | 0 |`);
      totalRemoved += old.count;
    } else if (old && cur) {
      const oldIds = new Set(Object.keys(old.names));
      const curIds = new Set(Object.keys(cur.names));
      let added = 0, removed = 0, changed = 0;
      for (const id of curIds) {
        if (!oldIds.has(id)) added++;
        else if (old.names[id] !== cur.names[id]) changed++;
      }
      for (const id of oldIds) {
        if (!curIds.has(id)) removed++;
      }
      // For systems without name maps, just compare counts
      if (oldIds.size === 0 && curIds.size === 0) {
        added = Math.max(0, cur.count - old.count);
        removed = Math.max(0, old.count - cur.count);
      }
      totalAdded += added;
      totalRemoved += removed;
      totalChanged += changed;
      const status = (added + removed + changed > 0) ? '**' : '';
      lines.push(`| ${status}${sys}${status} | ${old.count.toLocaleString()} | ${cur.count.toLocaleString()} | ${added} | ${removed} | ${changed} |`);
    }
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Files changed:** ${fileChanges} of ${allFiles.size}`);
  lines.push(`- **Entries added:** ${totalAdded.toLocaleString()}`);
  lines.push(`- **Entries removed:** ${totalRemoved.toLocaleString()}`);
  lines.push(`- **Entries modified:** ${totalChanged.toLocaleString()}`);
  if (fileChanges === 0 && totalAdded === 0 && totalRemoved === 0 && totalChanged === 0) {
    lines.push('', '**No changes detected since last snapshot.**');
  } else {
    lines.push('', '*Use `get_data_update_detail` with a system name (e.g., "spells", "zones") to see specific changes.*');
  }

  return lines.join('\n');
}

// Tool 254: Get data update detail for a specific system
export async function getDataUpdateDetail(systemName: string): Promise<string> {
  if (!isGameDataAvailable()) return 'EQ game data not available.';

  const saved = await loadSnapshot();
  if (!saved) {
    return 'No saved snapshot found. Run `save_data_snapshot` first.';
  }

  const { systems: currentSystems } = await gatherCurrentState();

  const sysKey = Object.keys(saved.systems).find(k => k.toLowerCase() === systemName.toLowerCase())
    || Object.keys(currentSystems).find(k => k.toLowerCase() === systemName.toLowerCase());

  if (!sysKey) {
    const available = [...new Set([...Object.keys(saved.systems), ...Object.keys(currentSystems)])].sort();
    return `Unknown system "${systemName}". Available: ${available.join(', ')}`;
  }

  const old = saved.systems[sysKey];
  const cur = currentSystems[sysKey];

  const lines: string[] = [`# Data Update Detail: ${sysKey}`, ''];
  lines.push(`**Baseline:** ${saved.timestamp}`);
  lines.push(`**Current:** ${new Date().toISOString()}`);

  if (!old) {
    lines.push('', `**System "${sysKey}" is entirely new (not in baseline snapshot).**`);
    lines.push(`- **New entries:** ${cur?.count || 0}`);
    return lines.join('\n');
  }
  if (!cur) {
    lines.push('', `**System "${sysKey}" no longer exists in current data.**`);
    lines.push(`- **Removed entries:** ${old.count}`);
    return lines.join('\n');
  }

  lines.push(`**Old count:** ${old.count.toLocaleString()}`);
  lines.push(`**New count:** ${cur.count.toLocaleString()}`);

  const oldIds = new Set(Object.keys(old.names));
  const curIds = new Set(Object.keys(cur.names));

  if (oldIds.size === 0 && curIds.size === 0) {
    const delta = cur.count - old.count;
    lines.push('', `*Name-level detail not available for this system. Count delta: ${delta >= 0 ? '+' : ''}${delta}*`);
    return lines.join('\n');
  }

  // Added entries
  const added: [string, string][] = [];
  for (const id of curIds) {
    if (!oldIds.has(id)) added.push([id, cur.names[id]]);
  }

  // Removed entries
  const removed: [string, string][] = [];
  for (const id of oldIds) {
    if (!curIds.has(id)) removed.push([id, old.names[id]]);
  }

  // Changed entries (renamed)
  const changed: [string, string, string][] = [];
  for (const id of curIds) {
    if (oldIds.has(id) && old.names[id] !== cur.names[id]) {
      changed.push([id, old.names[id], cur.names[id]]);
    }
  }

  if (added.length > 0) {
    lines.push('', `## Added (${added.length})`, '');
    lines.push('| ID | Name |');
    lines.push('|---:|:-----|');
    for (const [id, name] of added.slice(0, 100)) {
      lines.push(`| ${id} | ${name} |`);
    }
    if (added.length > 100) lines.push(`| ... | *${added.length - 100} more* |`);
  }

  if (removed.length > 0) {
    lines.push('', `## Removed (${removed.length})`, '');
    lines.push('| ID | Name |');
    lines.push('|---:|:-----|');
    for (const [id, name] of removed.slice(0, 100)) {
      lines.push(`| ${id} | ${name} |`);
    }
    if (removed.length > 100) lines.push(`| ... | *${removed.length - 100} more* |`);
  }

  if (changed.length > 0) {
    lines.push('', `## Modified (${changed.length})`, '');
    lines.push('| ID | Old Name | New Name |');
    lines.push('|---:|:---------|:---------|');
    for (const [id, oldName, newName] of changed.slice(0, 100)) {
      lines.push(`| ${id} | ${oldName} | ${newName} |`);
    }
    if (changed.length > 100) lines.push(`| ... | *${changed.length - 100} more* | |`);
  }

  if (added.length === 0 && removed.length === 0 && changed.length === 0) {
    lines.push('', '**No changes detected for this system.**');
  }

  // Summary
  lines.push('', '## Summary', '');
  lines.push(`- **Added:** ${added.length}`);
  lines.push(`- **Removed:** ${removed.length}`);
  lines.push(`- **Modified:** ${changed.length}`);
  lines.push(`- **Unchanged:** ${curIds.size - added.length - changed.length}`);

  return lines.join('\n');
}

// ============ PLAYER CUSTOMIZATION PARSER ============

interface PlayerCustomizationEntry {
  raceId: number;
  sex: number; // 0=male, 1=female
  classes: number[];
  colors: number[];
  numFaces: number;
  numHairStyles: number;
  numEyes: number;
  numBeards: number;
  numTattoos: number;
  numFacialAttachments: number;
}

let playerCustomization: PlayerCustomizationEntry[] | null = null;

async function loadPlayerCustomization(): Promise<void> {
  if (playerCustomization !== null) return;
  if (!isGameDataAvailable()) {
    playerCustomization = [];
    return;
  }

  console.error('[LocalData] Loading playercustomization.txt...');
  try {
    const data = await readGameFile(join('Resources', 'playercustomization.txt'));
    playerCustomization = [];
    for (const line of data.split('\n')) {
      if (line.startsWith('#') || !line.trim()) continue;
      const f = line.split('^');
      if (f.length < 13) continue;
      const raceId = parseInt(f[0]);
      if (isNaN(raceId)) continue;
      const classesList = f[4] ? f[4].split(',').map(Number).filter(n => !isNaN(n) && n > 0) : [];
      const colorsList = f[5] ? f[5].split(',').map(Number).filter(n => !isNaN(n)) : [];
      playerCustomization.push({
        raceId,
        sex: parseInt(f[12]) || 0,
        classes: classesList,
        colors: colorsList,
        numFaces: parseInt(f[6]) || 0,
        numHairStyles: parseInt(f[7]) || 0,
        numEyes: parseInt(f[8]) || 0,
        numBeards: parseInt(f[9]) || 0,
        numTattoos: parseInt(f[10]) || 0,
        numFacialAttachments: parseInt(f[11]) || 0,
      });
    }
    console.error(`[LocalData] Loaded ${playerCustomization.length} player customization entries`);
  } catch {
    playerCustomization = [];
  }
}

// Tool 255: Player customization overview
export async function getPlayerCustomizationOverview(): Promise<string> {
  await loadPlayerCustomization();
  if (!playerCustomization || playerCustomization.length === 0) return 'Player customization data not available.';

  const lines: string[] = ['# Player Customization Overview', '', '*Character creation appearance options by race and sex.*'];

  lines.push('', '## Appearance Options by Race', '');
  lines.push('| Race | Sex | Faces | Hair | Eyes | Beards | Tattoos | Facial | Colors |');
  lines.push('|:-----|:----|------:|-----:|-----:|-------:|--------:|-------:|-------:|');

  for (const entry of playerCustomization) {
    const raceName = RACE_IDS[entry.raceId] || `Race ${entry.raceId}`;
    const sex = entry.sex === 0 ? 'Male' : 'Female';
    const total = entry.numFaces + entry.numHairStyles + entry.numEyes + entry.numBeards + entry.numTattoos + entry.numFacialAttachments;
    if (total === 0) continue; // Skip empty entries
    lines.push(`| ${raceName} | ${sex} | ${entry.numFaces} | ${entry.numHairStyles} | ${entry.numEyes} | ${entry.numBeards} | ${entry.numTattoos} | ${entry.numFacialAttachments} | ${entry.colors.length} |`);
  }

  // Summary stats
  const withOptions = playerCustomization.filter(e => e.numFaces + e.numHairStyles + e.numEyes > 0);
  const totalFaces = withOptions.reduce((s, e) => s + e.numFaces, 0);
  const totalHair = withOptions.reduce((s, e) => s + e.numHairStyles, 0);
  const totalEyes = withOptions.reduce((s, e) => s + e.numEyes, 0);

  lines.push('', '## Summary', '');
  lines.push(`- **Races with customization:** ${withOptions.length}`);
  lines.push(`- **Total face options:** ${totalFaces}`);
  lines.push(`- **Total hair styles:** ${totalHair}`);
  lines.push(`- **Total eye options:** ${totalEyes}`);

  lines.push('', `*${playerCustomization.length} customization entries analyzed.*`);
  return lines.join('\n');
}

// Tool 256: Race appearance options
export async function getRaceAppearanceOptions(raceName: string): Promise<string> {
  await loadPlayerCustomization();
  if (!playerCustomization || playerCustomization.length === 0) return 'Player customization data not available.';

  const raceEntry = Object.entries(RACE_IDS).find(([, name]) =>
    name.toLowerCase() === raceName.toLowerCase()
  );
  if (!raceEntry) {
    const validRaces = Object.values(RACE_IDS).join(', ');
    return `Unknown race "${raceName}". Valid races: ${validRaces}`;
  }
  const raceId = parseInt(raceEntry[0]);
  const raceFullName = raceEntry[1];

  const entries = playerCustomization.filter(e => e.raceId === raceId);
  if (entries.length === 0) return `No customization data found for ${raceFullName}.`;

  const lines: string[] = [`# Race Appearance: ${raceFullName}`, '', `*Character creation appearance options for ${raceFullName}.*`];

  for (const entry of entries) {
    const sex = entry.sex === 0 ? 'Male' : 'Female';
    lines.push('', `## ${sex}`, '');
    lines.push(`- **Faces:** ${entry.numFaces}`);
    lines.push(`- **Hair styles:** ${entry.numHairStyles}`);
    lines.push(`- **Eye options:** ${entry.numEyes}`);
    lines.push(`- **Beards:** ${entry.numBeards}`);
    lines.push(`- **Tattoos:** ${entry.numTattoos}`);
    lines.push(`- **Facial attachments:** ${entry.numFacialAttachments}`);
    lines.push(`- **Color palette:** ${entry.colors.length} colors`);
    if (entry.classes.length > 0) {
      const classNames = entry.classes.map(c => CLASS_IDS[c] || `Class ${c}`).join(', ');
      lines.push(`- **Available classes:** ${classNames}`);
    }
  }

  return lines.join('\n');
}

// Tool 257: Combat ability class analysis
export async function getCombatAbilityClassAnalysis(): Promise<string> {
  await loadCombatAbilities();
  await loadSpells();
  if (!combatAbilities || combatAbilities.size === 0) return 'Combat ability data not available.';

  const lines: string[] = ['# Combat Ability / Discipline Analysis', '', '*Analyze combat abilities (disciplines) and their relationship to classes.*'];

  // Combat abilities are tracked by name in the dbstr system
  // Cross-reference with spells that share names (disciplines are often spell-based)
  const abilityNames = [...combatAbilities.values()];
  const nameWords = new Map<string, number>();
  const prefixes = new Map<string, number>();

  for (const name of abilityNames) {
    const words = name.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/).filter((w: string) => w.length >= 3);
    for (const w of words) nameWords.set(w, (nameWords.get(w) || 0) + 1);

    // First word as prefix
    const firstWord = name.split(/\s+/)[0];
    if (firstWord) prefixes.set(firstWord, (prefixes.get(firstWord) || 0) + 1);
  }

  // Match abilities to spells by name
  let matchedToSpells = 0;
  const classAbilityCounts = new Map<number, number>();
  if (spells && spells.size > 0) {
    const spellNameMap = new Map<string, LocalSpell>();
    for (const spell of spells.values()) {
      spellNameMap.set(spell.fields[SF.NAME].toLowerCase(), spell);
    }

    for (const name of abilityNames) {
      const spell = spellNameMap.get(name.toLowerCase());
      if (spell) {
        matchedToSpells++;
        for (let c = 0; c < 16; c++) {
          const lv = parseInt(spell.fields[SF.CLASS_LEVEL_START + c]) || 255;
          if (lv > 0 && lv < 255) {
            classAbilityCounts.set(c + 1, (classAbilityCounts.get(c + 1) || 0) + 1);
          }
        }
      }
    }
  }

  lines.push(`**Total combat abilities:** ${combatAbilities.size}`);
  lines.push(`**Matched to spells:** ${matchedToSpells} (${((matchedToSpells / combatAbilities.size) * 100).toFixed(1)}%)`);

  // Abilities per class (from spell matches)
  if (classAbilityCounts.size > 0) {
    lines.push('', '## Combat Abilities by Class', '');
    lines.push('| Class | Abilities |');
    lines.push('|:------|----------:|');
    const sorted = [...classAbilityCounts.entries()].sort((a, b) => b[1] - a[1]);
    for (const [cid, count] of sorted) {
      lines.push(`| ${CLASS_IDS[cid] || `Class ${cid}`} | ${count} |`);
    }
  }

  // Most common name prefixes
  lines.push('', '## Most Common Name Prefixes', '');
  lines.push('| Prefix | Count |');
  lines.push('|:-------|------:|');
  const sortedPrefixes = [...prefixes.entries()].sort((a, b) => b[1] - a[1]);
  for (const [prefix, count] of sortedPrefixes.slice(0, 20)) {
    lines.push(`| ${prefix} | ${count} |`);
  }

  // Keyword themes
  const themes: Record<string, string[]> = {
    'Melee': ['strike', 'slash', 'kick', 'bash', 'punch', 'frenzy', 'attack', 'cleave'],
    'Defense': ['shield', 'block', 'parry', 'dodge', 'guard', 'fortify', 'deflect'],
    'Buff/Stance': ['stance', 'aura', 'focus', 'discipline', 'form', 'rage'],
    'Taunt/Aggro': ['taunt', 'provoke', 'aggro', 'hate', 'threat'],
    'Heal/Recovery': ['heal', 'mend', 'recover', 'bandage', 'salve'],
  };
  lines.push('', '## Ability Themes', '');
  lines.push('| Theme | Matching Abilities |');
  lines.push('|:------|-------------------:|');
  for (const [theme, keywords] of Object.entries(themes)) {
    let count = 0;
    for (const name of abilityNames) {
      const lower = name.toLowerCase();
      if (keywords.some(k => lower.includes(k))) count++;
    }
    lines.push(`| ${theme} | ${count} |`);
  }

  // Most common words
  const stopWords = new Set(['the', 'of', 'and', 'for', 'rk', 'iii', 'ii']);
  lines.push('', '## Most Common Words', '');
  lines.push('| Word | Count |');
  lines.push('|:-----|------:|');
  const sortedWords = [...nameWords.entries()].filter(([w]) => !stopWords.has(w)).sort((a, b) => b[1] - a[1]);
  for (const [word, count] of sortedWords.slice(0, 20)) {
    lines.push(`| ${word} | ${count} |`);
  }

  lines.push('', '## Summary', '');
  lines.push(`- **Total abilities:** ${combatAbilities.size}`);
  lines.push(`- **Spell-matched:** ${matchedToSpells}`);
  lines.push(`- **Unique prefixes:** ${prefixes.size}`);

  lines.push('', `*${combatAbilities.size} combat abilities analyzed.*`);
  return lines.join('\n');
}

// Tool 258: Spell requirement class breakdown
export async function getSpellRequirementClassBreakdown(): Promise<string> {
  await loadSpellRequirements();
  await loadSpells();
  if (!spellRequirements || spellRequirements.size === 0) return 'Spell requirement data not available.';

  const lines = ['# Spell Requirement Class Breakdown', ''];
  lines.push('*Analyzes which classes have spells with the most requirements.*', '');

  // Map requirement associations to classes
  const classReqCounts: Record<number, number> = {}; // classId -> count of spells with requirements
  const classReqEntries: Record<number, number> = {}; // classId -> total requirement entries
  const reqIdByClass: Record<number, Set<number>> = {}; // classId -> unique req IDs
  const multiClassReqs: { spellId: number; name: string; classes: number[]; reqCount: number }[] = [];

  for (const [assocId, reqs] of spellRequirements) {
    const spell = spells?.get(assocId);
    if (!spell) continue;

    const spellClasses: number[] = [];
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < 255) spellClasses.push(i);
    }

    for (const classId of spellClasses) {
      classReqCounts[classId] = (classReqCounts[classId] || 0) + 1;
      classReqEntries[classId] = (classReqEntries[classId] || 0) + reqs.length;
      if (!reqIdByClass[classId]) reqIdByClass[classId] = new Set();
      for (const r of reqs) reqIdByClass[classId].add(r.reqId);
    }

    if (spellClasses.length > 1 && reqs.length >= 3) {
      multiClassReqs.push({ spellId: assocId, name: spell.name, classes: spellClasses, reqCount: reqs.length });
    }
  }

  // Per-class summary
  lines.push('## Requirements by Class', '');
  lines.push('| Class | Spells w/ Reqs | Total Req Entries | Unique Req IDs | Avg Reqs/Spell |');
  lines.push('|:------|---------------:|------------------:|---------------:|---------------:|');
  const sorted = Object.entries(classReqCounts).sort((a, b) => b[1] - a[1]);
  for (const [cid, count] of sorted) {
    const classId = parseInt(cid);
    const entries = classReqEntries[classId] || 0;
    const uniqueReqs = reqIdByClass[classId]?.size || 0;
    const avg = (entries / count).toFixed(1);
    lines.push(`| ${CLASS_IDS[classId]} | ${count} | ${entries} | ${uniqueReqs} | ${avg} |`);
  }

  // Class-exclusive requirement IDs
  lines.push('', '## Class-Exclusive Requirement Patterns', '');
  const allReqIds = new Set<number>();
  for (const s of Object.values(reqIdByClass)) for (const id of s) allReqIds.add(id);
  const exclusiveByClass: Record<number, number[]> = {};
  for (const [cid, ids] of Object.entries(reqIdByClass)) {
    const classId = parseInt(cid);
    const exclusive = [...ids].filter(id => {
      let count = 0;
      for (const s of Object.values(reqIdByClass)) if (s.has(id)) count++;
      return count === 1;
    });
    if (exclusive.length > 0) exclusiveByClass[classId] = exclusive;
  }
  if (Object.keys(exclusiveByClass).length > 0) {
    for (const [cid, ids] of Object.entries(exclusiveByClass).sort((a, b) => b[1].length - a[1].length)) {
      lines.push(`- **${CLASS_IDS[parseInt(cid)]}:** ${ids.length} exclusive req IDs (${ids.slice(0, 5).join(', ')}${ids.length > 5 ? '...' : ''})`);
    }
  } else {
    lines.push('*No class-exclusive requirement IDs found.*');
  }

  // Multi-class spells with many requirements
  if (multiClassReqs.length > 0) {
    multiClassReqs.sort((a, b) => b.reqCount - a.reqCount);
    lines.push('', '## Multi-Class Spells with Most Requirements', '');
    lines.push('| Spell | # Classes | # Requirements |');
    lines.push('|:------|----------:|---------------:|');
    for (const s of multiClassReqs.slice(0, 15)) {
      lines.push(`| ${s.name} | ${s.classes.length} | ${s.reqCount} |`);
    }
  }

  // Requirement density by level range
  lines.push('', '## Requirement Density by Min Level', '');
  const levelBuckets: Record<string, number> = {};
  for (const [assocId, reqs] of spellRequirements) {
    const spell = spells?.get(assocId);
    if (!spell) continue;
    let minLevel = 255;
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < minLevel) minLevel = level;
    }
    if (minLevel >= 255) continue;
    const bucket = minLevel <= 10 ? '1-10' : minLevel <= 30 ? '11-30' : minLevel <= 60 ? '31-60' : minLevel <= 85 ? '61-85' : minLevel <= 100 ? '86-100' : minLevel <= 115 ? '101-115' : '116+';
    levelBuckets[bucket] = (levelBuckets[bucket] || 0) + 1;
  }
  const bucketOrder = ['1-10', '11-30', '31-60', '61-85', '86-100', '101-115', '116+'];
  for (const bucket of bucketOrder) {
    if (levelBuckets[bucket]) lines.push(`- **Level ${bucket}:** ${levelBuckets[bucket]} spells with requirements`);
  }

  lines.push('', `*${spellRequirements.size} spell-requirement associations analyzed.*`);
  return lines.join('\n');
}

// Tool 259: AC mitigation progression analysis
export async function getACMitigationProgressionAnalysis(className: string): Promise<string> {
  await loadACMitigation();
  if (!acMitigation || acMitigation.length === 0) return 'AC mitigation data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase())?.[0];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const cid = parseInt(classId);
  const entries = acMitigation.filter(e => e.classId === cid).sort((a, b) => a.level - b.level);
  if (entries.length === 0) return `No AC mitigation data found for ${CLASS_IDS[cid]}.`;

  const lines = [`# AC Mitigation Progression — ${CLASS_IDS[cid]}`, ''];
  lines.push(`*How AC soft cap and multiplier evolve from level ${entries[0].level} to ${entries[entries.length - 1].level}.*`, '');

  // Full progression table (sample every 5 levels to keep manageable)
  lines.push('## Progression by Level', '');
  lines.push('| Level | AC Soft Cap | Soft Cap Mult | Cap Change | Mult Change |');
  lines.push('|------:|-------------|---------------|------------|-------------|');
  let prevCap = 0;
  let prevMult = 0;
  for (const e of entries) {
    if (e.level % 5 === 0 || e.level === 1 || e.level === entries[entries.length - 1].level) {
      const capDelta = prevCap > 0 ? `+${(e.acCap - prevCap).toLocaleString()}` : '—';
      const multDelta = prevMult > 0 ? `${((e.softCapMultiplier - prevMult) * 100).toFixed(1)}%` : '—';
      lines.push(`| ${e.level} | ${e.acCap.toLocaleString()} | ${(e.softCapMultiplier * 100).toFixed(0)}% | ${capDelta} | ${multDelta} |`);
      prevCap = e.acCap;
      prevMult = e.softCapMultiplier;
    }
  }

  // Biggest jumps (breakpoints)
  lines.push('', '## Key Breakpoints (Biggest AC Cap Increases)', '');
  lines.push('| Level | AC Cap Before | AC Cap After | Increase | % Jump |');
  lines.push('|------:|--------------:|-------------:|---------:|-------:|');
  const jumps: { level: number; before: number; after: number; delta: number; pct: number }[] = [];
  for (let i = 1; i < entries.length; i++) {
    const delta = entries[i].acCap - entries[i - 1].acCap;
    if (delta > 0 && entries[i - 1].acCap > 0) {
      const pct = (delta / entries[i - 1].acCap) * 100;
      jumps.push({ level: entries[i].level, before: entries[i - 1].acCap, after: entries[i].acCap, delta, pct });
    }
  }
  jumps.sort((a, b) => b.delta - a.delta);
  for (const j of jumps.slice(0, 10)) {
    lines.push(`| ${j.level} | ${j.before.toLocaleString()} | ${j.after.toLocaleString()} | +${j.delta.toLocaleString()} | +${j.pct.toFixed(1)}% |`);
  }

  // Multiplier changes
  const multChanges: { level: number; before: number; after: number }[] = [];
  for (let i = 1; i < entries.length; i++) {
    if (entries[i].softCapMultiplier !== entries[i - 1].softCapMultiplier) {
      multChanges.push({ level: entries[i].level, before: entries[i - 1].softCapMultiplier, after: entries[i].softCapMultiplier });
    }
  }
  if (multChanges.length > 0) {
    lines.push('', '## Soft Cap Multiplier Changes', '');
    lines.push('| Level | Before | After | Direction |');
    lines.push('|------:|-------:|------:|-----------|');
    for (const mc of multChanges) {
      const dir = mc.after > mc.before ? 'Improved' : 'Reduced';
      lines.push(`| ${mc.level} | ${(mc.before * 100).toFixed(1)}% | ${(mc.after * 100).toFixed(1)}% | ${dir} |`);
    }
  }

  // Compare to class average at max level
  const maxLevel = entries[entries.length - 1].level;
  const allClassesAtMax = acMitigation.filter(e => e.level === maxLevel);
  if (allClassesAtMax.length > 1) {
    const avgCap = allClassesAtMax.reduce((s, e) => s + e.acCap, 0) / allClassesAtMax.length;
    const myEntry = entries[entries.length - 1];
    const rank = allClassesAtMax.filter(e => e.acCap > myEntry.acCap).length + 1;
    lines.push('', `## Level ${maxLevel} Comparison`, '');
    lines.push(`- **${CLASS_IDS[cid]} AC cap:** ${myEntry.acCap.toLocaleString()}`);
    lines.push(`- **All-class average:** ${Math.round(avgCap).toLocaleString()}`);
    lines.push(`- **Rank:** ${rank} of ${allClassesAtMax.length}`);
    lines.push(`- **vs Average:** ${myEntry.acCap > avgCap ? '+' : ''}${(((myEntry.acCap / avgCap) - 1) * 100).toFixed(1)}%`);
  }

  // Summary stats
  lines.push('', '## Summary', '');
  lines.push(`- **Level range:** ${entries[0].level}–${entries[entries.length - 1].level}`);
  lines.push(`- **AC cap range:** ${entries[0].acCap.toLocaleString()} → ${entries[entries.length - 1].acCap.toLocaleString()}`);
  lines.push(`- **Total AC cap growth:** +${(entries[entries.length - 1].acCap - entries[0].acCap).toLocaleString()}`);
  lines.push(`- **Multiplier range:** ${(entries[0].softCapMultiplier * 100).toFixed(0)}% → ${(entries[entries.length - 1].softCapMultiplier * 100).toFixed(0)}%`);
  lines.push(`- **Data points:** ${entries.length}`);

  lines.push('', `*AC mitigation progression for ${CLASS_IDS[cid]} analyzed.*`);
  return lines.join('\n');
}

// Tool 260: Spell stacking conflict analysis
export async function getSpellStackingConflictAnalysis(): Promise<string> {
  await loadSpellStacking();
  await loadSpells();
  if (!spellStacking || !spellGroupNames || spellGroupNames.size === 0) {
    return 'Spell stacking data not available.';
  }

  const lines = ['# Spell Stacking Conflict Analysis', ''];
  lines.push('*Identifies stacking groups where multiple classes contribute spells, indicating potential buff conflicts.*', '');

  // Build class → groups and group → classes maps
  const groupClasses: Map<number, Set<number>> = new Map();
  const groupSpells: Map<number, { spellId: number; name: string; classId: number }[]> = new Map();

  for (const [spellId, entries] of spellStacking) {
    const spell = spells?.get(spellId);
    if (!spell) continue;

    // Find which classes can cast this spell
    const spellClasses: number[] = [];
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < 255) spellClasses.push(i);
    }
    if (spellClasses.length === 0) continue;

    for (const entry of entries) {
      const gid = entry.stackingGroup;
      if (!groupClasses.has(gid)) groupClasses.set(gid, new Set());
      if (!groupSpells.has(gid)) groupSpells.set(gid, []);

      for (const classId of spellClasses) {
        groupClasses.get(gid)!.add(classId);
        groupSpells.get(gid)!.push({ spellId, name: spell.name, classId });
      }
    }
  }

  // Find multi-class stacking groups (conflict potential)
  const conflictGroups: { groupId: number; name: string; classCount: number; spellCount: number; classes: number[] }[] = [];
  for (const [gid, classes] of groupClasses) {
    if (classes.size >= 2) {
      const spells = groupSpells.get(gid) || [];
      const uniqueSpells = new Set(spells.map(s => s.spellId));
      conflictGroups.push({
        groupId: gid,
        name: spellGroupNames.get(gid) || `Group ${gid}`,
        classCount: classes.size,
        spellCount: uniqueSpells.size,
        classes: [...classes].sort((a, b) => a - b),
      });
    }
  }
  conflictGroups.sort((a, b) => b.classCount - a.classCount || b.spellCount - a.spellCount);

  lines.push(`- **Total stacking groups:** ${spellGroupNames.size}`);
  lines.push(`- **Multi-class groups (conflict potential):** ${conflictGroups.length}`);
  lines.push(`- **Single-class groups:** ${spellGroupNames.size - conflictGroups.length}`);

  // Top conflict groups by class count
  lines.push('', '## Most Contested Stacking Groups (Most Classes)', '');
  lines.push('| Group | Classes | Spells | Class List |');
  lines.push('|:------|--------:|-------:|:-----------|');
  for (const g of conflictGroups.slice(0, 20)) {
    const classList = g.classes.map(c => CLASS_IDS[c]).join(', ');
    lines.push(`| ${g.name} | ${g.classCount} | ${g.spellCount} | ${classList} |`);
  }

  // Class pair conflict frequency
  lines.push('', '## Class Pair Conflict Frequency', '');
  lines.push('*How many stacking groups each pair of classes shares.*', '');
  const pairConflicts: Record<string, number> = {};
  for (const g of conflictGroups) {
    for (let i = 0; i < g.classes.length; i++) {
      for (let j = i + 1; j < g.classes.length; j++) {
        const key = `${g.classes[i]}-${g.classes[j]}`;
        pairConflicts[key] = (pairConflicts[key] || 0) + 1;
      }
    }
  }
  const sortedPairs = Object.entries(pairConflicts).sort((a, b) => b[1] - a[1]);
  lines.push('| Class Pair | Shared Groups |');
  lines.push('|:-----------|-------------:|');
  for (const [key, count] of sortedPairs.slice(0, 20)) {
    const [c1, c2] = key.split('-').map(Number);
    lines.push(`| ${CLASS_IDS[c1]} + ${CLASS_IDS[c2]} | ${count} |`);
  }

  // Per-class conflict exposure
  lines.push('', '## Per-Class Conflict Exposure', '');
  lines.push('| Class | Conflict Groups | Avg Classes/Group |');
  lines.push('|:------|----------------:|------------------:|');
  const classConflictGroups: Record<number, number[]> = {};
  for (const g of conflictGroups) {
    for (const c of g.classes) {
      if (!classConflictGroups[c]) classConflictGroups[c] = [];
      classConflictGroups[c].push(g.classCount);
    }
  }
  const sortedExposure = Object.entries(classConflictGroups).sort((a, b) => b[1].length - a[1].length);
  for (const [cid, groupCounts] of sortedExposure) {
    const avg = (groupCounts.reduce((s, v) => s + v, 0) / groupCounts.length).toFixed(1);
    lines.push(`| ${CLASS_IDS[parseInt(cid)]} | ${groupCounts.length} | ${avg} |`);
  }

  // Stacking type breakdown in conflict groups
  const conflictGroupIds = new Set(conflictGroups.map(g => g.groupId));
  const conflictTypeCount: Record<number, number> = {};
  for (const [, entries] of spellStacking) {
    for (const entry of entries) {
      if (conflictGroupIds.has(entry.stackingGroup)) {
        conflictTypeCount[entry.stackingType] = (conflictTypeCount[entry.stackingType] || 0) + 1;
      }
    }
  }
  lines.push('', '## Stacking Types in Conflict Groups', '');
  for (const [type, count] of Object.entries(conflictTypeCount).sort((a, b) => b[1] - a[1])) {
    lines.push(`- **Type ${type}:** ${count} entries`);
  }

  lines.push('', `*${conflictGroups.length} multi-class stacking groups analyzed for conflict potential.*`);
  return lines.join('\n');
}

// Tool 261: Mercenary ability spell analysis
export async function getMercenaryAbilitySpellAnalysis(): Promise<string> {
  await loadMercenaryStances();
  await loadSpells();
  if (!mercenaryAbilities || mercenaryAbilities.size === 0) return 'Mercenary ability data not available.';

  const lines = ['# Mercenary Ability Spell Analysis', ''];
  lines.push('*Cross-references mercenary abilities with the spell database to identify what spells mercenaries can cast.*', '');

  // Try to match merc abilities to spells by name
  const matched: { abilityId: number; abilityName: string; spellId: number; spellName: string; beneficial: boolean; category: string }[] = [];
  const unmatched: { id: number; name: string; desc: string }[] = [];

  for (const [id, ability] of mercenaryAbilities) {
    let found = false;
    if (spells && spellNameIndex) {
      // Try exact match first
      const lowerName = ability.name.toLowerCase();
      const matches = spellNameIndex.get(lowerName);
      if (matches && matches.length > 0) {
        const spell = spells.get(matches[0])!;
        const beneficial = spell.fields[SF.BENEFICIAL] === '1';
        const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
        const cat = spellCategories?.get(catId) || 'Unknown';
        matched.push({ abilityId: id, abilityName: ability.name, spellId: matches[0], spellName: spell.name, beneficial, category: cat });
        found = true;
      }
    }
    if (!found) {
      unmatched.push({ id, name: ability.name, desc: ability.description.slice(0, 80) });
    }
  }

  lines.push(`- **Total mercenary abilities:** ${mercenaryAbilities.size}`);
  lines.push(`- **Matched to spells:** ${matched.length} (${((matched.length / mercenaryAbilities.size) * 100).toFixed(1)}%)`);
  lines.push(`- **Unmatched:** ${unmatched.length}`);

  // Matched abilities by category
  if (matched.length > 0) {
    const byCat: Record<string, typeof matched> = {};
    for (const m of matched) {
      const cat = m.category;
      if (!byCat[cat]) byCat[cat] = [];
      byCat[cat].push(m);
    }
    lines.push('', '## Matched Abilities by Spell Category', '');
    lines.push('| Category | Count | Beneficial | Detrimental |');
    lines.push('|:---------|------:|-----------:|------------:|');
    for (const [cat, entries] of Object.entries(byCat).sort((a, b) => b[1].length - a[1].length)) {
      const ben = entries.filter(e => e.beneficial).length;
      const det = entries.length - ben;
      lines.push(`| ${cat} | ${entries.length} | ${ben} | ${det} |`);
    }

    // Sample matched abilities
    lines.push('', '## Sample Matched Abilities', '');
    lines.push('| Merc Ability | Spell Match | Type | Category |');
    lines.push('|:-------------|:------------|:-----|:---------|');
    for (const m of matched.slice(0, 25)) {
      const type = m.beneficial ? 'Beneficial' : 'Detrimental';
      lines.push(`| ${m.abilityName} | ${m.spellName} | ${type} | ${m.category} |`);
    }
  }

  // Unmatched abilities analysis
  if (unmatched.length > 0) {
    lines.push('', '## Unmatched Abilities (No Spell Name Match)', '');
    lines.push('| Ability | Description |');
    lines.push('|:--------|:------------|');
    for (const u of unmatched.slice(0, 25)) {
      lines.push(`| ${u.name} | ${u.desc} |`);
    }
  }

  // Ability name word frequency
  const wordFreq: Record<string, number> = {};
  const stopWords = new Set(['the', 'of', 'and', 'a', 'to', 'in', 'for', 'is', 'on', 'rk', 'ii', 'iii']);
  for (const [, ability] of mercenaryAbilities) {
    const words = ability.name.toLowerCase().split(/\s+/).filter((w: string) => w.length > 2 && !stopWords.has(w));
    for (const word of words) wordFreq[word] = (wordFreq[word] || 0) + 1;
  }
  lines.push('', '## Most Common Words in Ability Names', '');
  lines.push('| Word | Count |');
  lines.push('|:-----|------:|');
  const sortedWords = Object.entries(wordFreq).sort((a, b) => b[1] - a[1]);
  for (const [word, count] of sortedWords.slice(0, 15)) {
    lines.push(`| ${word} | ${count} |`);
  }

  lines.push('', `*${mercenaryAbilities.size} mercenary abilities analyzed.*`);
  return lines.join('\n');
}

// Tool 262: Overseer trait synergy analysis
export async function getOverseerTraitSynergyAnalysis(): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerMinions();
  await loadOverseerEnhancements();
  if (!overseerQuests || !overseerMinions) return 'Overseer data not available.';

  const lines = ['# Overseer Trait Synergy Analysis', ''];
  lines.push('*Analyzes which traits co-occur as bonus traits in quest slots, identifying the most synergistic trait combinations.*', '');

  // Build trait pair co-occurrence from quest slot bonus traits
  const traitPairCount: Map<string, number> = new Map();
  const traitSlotCount: Map<number, number> = new Map(); // traitId -> how many slots require it as bonus
  const traitQuestCount: Map<number, number> = new Map(); // traitId -> how many quests it appears in

  for (const [, quest] of overseerQuests) {
    const questTraits = new Set<number>();
    for (const slot of quest.slotDetails) {
      for (const traitId of slot.bonusTraitIds) {
        traitSlotCount.set(traitId, (traitSlotCount.get(traitId) || 0) + 1);
        questTraits.add(traitId);
      }
      // Co-occurrence within same slot
      const sorted = [...slot.bonusTraitIds].sort((a, b) => a - b);
      for (let i = 0; i < sorted.length; i++) {
        for (let j = i + 1; j < sorted.length; j++) {
          const key = `${sorted[i]}-${sorted[j]}`;
          traitPairCount.set(key, (traitPairCount.get(key) || 0) + 1);
        }
      }
    }
    for (const tid of questTraits) {
      traitQuestCount.set(tid, (traitQuestCount.get(tid) || 0) + 1);
    }
  }

  // Trait name resolution
  const traitName = (id: number): string => overseerTraitDescs?.get(id) || `Trait ${id}`;

  lines.push(`- **Total quests analyzed:** ${overseerQuests.size}`);
  lines.push(`- **Unique bonus traits:** ${traitSlotCount.size}`);
  lines.push(`- **Trait pair combinations:** ${traitPairCount.size}`);

  // Most requested traits
  lines.push('', '## Most Requested Bonus Traits', '');
  lines.push('| Trait | Slot Appearances | Quest Count |');
  lines.push('|:------|----------------:|------------:|');
  const sortedTraits = [...traitSlotCount.entries()].sort((a, b) => b[1] - a[1]);
  for (const [tid, count] of sortedTraits.slice(0, 20)) {
    const qCount = traitQuestCount.get(tid) || 0;
    lines.push(`| ${traitName(tid)} | ${count} | ${qCount} |`);
  }

  // Most synergistic trait pairs (co-occur most in same slot)
  lines.push('', '## Most Synergistic Trait Pairs (Same Slot Co-occurrence)', '');
  lines.push('| Trait 1 | Trait 2 | Co-occurrences |');
  lines.push('|:--------|:--------|---------------:|');
  const sortedPairs = [...traitPairCount.entries()].sort((a, b) => b[1] - a[1]);
  for (const [key, count] of sortedPairs.slice(0, 20)) {
    const [t1, t2] = key.split('-').map(Number);
    lines.push(`| ${traitName(t1)} | ${traitName(t2)} | ${count} |`);
  }

  // Agents that cover the most requested traits
  lines.push('', '## Best Agents by Trait Coverage', '');
  lines.push('*Agents whose traits match the most-requested bonus traits.*', '');
  const topTraitIds = new Set(sortedTraits.slice(0, 30).map(([tid]) => tid));
  const agentScores: { name: string; matchCount: number; traits: string[] }[] = [];
  for (const [, minion] of overseerMinions) {
    const matchCount = minion.traitIds.filter(tid => topTraitIds.has(tid)).length;
    if (matchCount > 0) {
      agentScores.push({ name: minion.shortName || minion.fullName, matchCount, traits: minion.traits });
    }
  }
  agentScores.sort((a, b) => b.matchCount - a.matchCount);
  lines.push('| Agent | Top Trait Matches | Traits |');
  lines.push('|:------|------------------:|:-------|');
  for (const a of agentScores.slice(0, 15)) {
    lines.push(`| ${a.name} | ${a.matchCount} | ${a.traits.join(', ')} |`);
  }

  // Trait diversity per difficulty level
  const diffTraits: Record<number, Set<number>> = {};
  for (const [, quest] of overseerQuests) {
    if (!diffTraits[quest.difficulty]) diffTraits[quest.difficulty] = new Set();
    for (const slot of quest.slotDetails) {
      for (const tid of slot.bonusTraitIds) diffTraits[quest.difficulty].add(tid);
    }
  }
  lines.push('', '## Bonus Trait Diversity by Difficulty', '');
  for (const [diff, traits] of Object.entries(diffTraits).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    lines.push(`- **Difficulty ${diff}:** ${traits.size} unique bonus traits`);
  }

  lines.push('', `*${traitPairCount.size} trait pair combinations analyzed across ${overseerQuests.size} quests.*`);
  return lines.join('\n');
}

// Tool 263: Class spell level gap analysis
export async function getClassSpellLevelGapAnalysis(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase())?.[0];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const cid = parseInt(classId);
  const lines = [`# Spell Level Gap Analysis — ${CLASS_IDS[cid]}`, ''];
  lines.push(`*Identifies level ranges where ${CLASS_IDS[cid]} receives few or no new spells.*`, '');

  // Collect all spells for this class by level
  const spellsByLevel: Record<number, { id: number; name: string; category: string }[]> = {};
  for (const [spellId, spell] of spells) {
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
    if (level <= 0 || level >= 255) continue;
    if (!spellsByLevel[level]) spellsByLevel[level] = [];
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const cat = spellCategories?.get(catId) || 'Unknown';
    spellsByLevel[level].push({ id: spellId, name: spell.name, category: cat });
  }

  const levels = Object.keys(spellsByLevel).map(Number).sort((a, b) => a - b);
  if (levels.length === 0) return `No spells found for ${CLASS_IDS[cid]}.`;

  const totalSpells = Object.values(spellsByLevel).reduce((s, v) => s + v.length, 0);
  lines.push(`- **Total spells:** ${totalSpells}`);
  lines.push(`- **Level range:** ${levels[0]}–${levels[levels.length - 1]}`);
  lines.push(`- **Levels with spells:** ${levels.length}`);
  lines.push(`- **Average spells per level:** ${(totalSpells / levels.length).toFixed(1)}`);

  // Find gaps (consecutive levels with no spells)
  const maxLevel = levels[levels.length - 1];
  const gaps: { start: number; end: number; length: number }[] = [];
  let gapStart: number | null = null;
  for (let lvl = levels[0]; lvl <= maxLevel; lvl++) {
    if (!spellsByLevel[lvl]) {
      if (gapStart === null) gapStart = lvl;
    } else {
      if (gapStart !== null) {
        gaps.push({ start: gapStart, end: lvl - 1, length: lvl - gapStart });
        gapStart = null;
      }
    }
  }
  if (gapStart !== null) gaps.push({ start: gapStart, end: maxLevel, length: maxLevel - gapStart + 1 });
  gaps.sort((a, b) => b.length - a.length);

  lines.push('', '## Largest Level Gaps (No New Spells)', '');
  lines.push('| Gap Range | Length | Spells Before | Spells After |');
  lines.push('|:----------|-------:|--------------:|-------------:|');
  for (const g of gaps.slice(0, 15)) {
    const before = spellsByLevel[g.start - 1]?.length || 0;
    const after = spellsByLevel[g.end + 1]?.length || 0;
    lines.push(`| ${g.start}–${g.end} | ${g.length} levels | ${before} | ${after} |`);
  }

  // Spell density by level range
  lines.push('', '## Spell Density by Level Range', '');
  const ranges: [string, number, number][] = [
    ['1-10', 1, 10], ['11-20', 11, 20], ['21-30', 21, 30], ['31-40', 31, 40],
    ['41-50', 41, 50], ['51-60', 51, 60], ['61-70', 61, 70], ['71-80', 71, 80],
    ['81-90', 81, 90], ['91-100', 91, 100], ['101-110', 101, 110], ['111-120', 111, 120], ['121-130', 121, 130],
  ];
  lines.push('| Level Range | Spells | Bar |');
  lines.push('|:------------|-------:|:----|');
  let maxCount = 0;
  for (const [, lo, hi] of ranges) {
    let count = 0;
    for (let lvl = lo; lvl <= hi; lvl++) count += spellsByLevel[lvl]?.length || 0;
    if (count > maxCount) maxCount = count;
  }
  for (const [label, lo, hi] of ranges) {
    let count = 0;
    for (let lvl = lo; lvl <= hi; lvl++) count += spellsByLevel[lvl]?.length || 0;
    if (count === 0 && lo > maxLevel) continue;
    const barLen = maxCount > 0 ? Math.round((count / maxCount) * 30) : 0;
    lines.push(`| ${label} | ${count} | ${'█'.repeat(barLen)} |`);
  }

  // Busiest levels
  lines.push('', '## Busiest Levels (Most New Spells)', '');
  lines.push('| Level | New Spells | Categories |');
  lines.push('|------:|-----------:|:-----------|');
  const sortedLevels = levels.map(lvl => ({ lvl, count: spellsByLevel[lvl].length })).sort((a, b) => b.count - a.count);
  for (const { lvl, count } of sortedLevels.slice(0, 10)) {
    const cats = new Set(spellsByLevel[lvl].map(s => s.category));
    lines.push(`| ${lvl} | ${count} | ${[...cats].slice(0, 4).join(', ')} |`);
  }

  // Category distribution
  lines.push('', '## Spells by Category', '');
  const catCounts: Record<string, number> = {};
  for (const entries of Object.values(spellsByLevel)) {
    for (const e of entries) catCounts[e.category] = (catCounts[e.category] || 0) + 1;
  }
  lines.push('| Category | Count | % |');
  lines.push('|:---------|------:|--:|');
  for (const [cat, count] of Object.entries(catCounts).sort((a, b) => b[1] - a[1]).slice(0, 15)) {
    const pct = ((count / totalSpells) * 100).toFixed(1);
    lines.push(`| ${cat} | ${count} | ${pct}% |`);
  }

  lines.push('', `*${totalSpells} spells across ${levels.length} levels analyzed for ${CLASS_IDS[cid]}.*`);
  return lines.join('\n');
}

// Tool 264: Drakkin heritage class analysis
export async function getDrakkinHeritageClassAnalysis(): Promise<string> {
  await loadDrakkinHeritages();
  if (!drakkinHeritages || drakkinHeritages.length === 0) return 'Drakkin heritage data not available.';

  const lines = ['# Drakkin Heritage Class Analysis', ''];
  lines.push('*Analyzes which classes are available for each Drakkin heritage and identifies optimal heritage-class combinations.*', '');

  lines.push(`- **Total heritages:** ${drakkinHeritages.length}`);

  // Heritage to classes table
  lines.push('', '## Heritage Class Availability', '');
  lines.push('| Heritage | Available Classes | Count |');
  lines.push('|:---------|:------------------|------:|');
  for (const h of drakkinHeritages) {
    const classNames = h.classes.map(c => CLASS_IDS[c] || `Class ${c}`).sort();
    lines.push(`| ${h.name} | ${classNames.join(', ')} | ${classNames.length} |`);
  }

  // Class to heritages (inverse)
  lines.push('', '## Class Heritage Availability', '');
  lines.push('| Class | Available Heritages | Count |');
  lines.push('|:------|:---------------------|------:|');
  const classHeritages: Record<number, string[]> = {};
  for (const h of drakkinHeritages) {
    for (const c of h.classes) {
      if (!classHeritages[c]) classHeritages[c] = [];
      classHeritages[c].push(h.name);
    }
  }
  for (const [cid, heritages] of Object.entries(classHeritages).sort((a, b) => b[1].length - a[1].length)) {
    lines.push(`| ${CLASS_IDS[parseInt(cid)]} | ${heritages.join(', ')} | ${heritages.length} |`);
  }

  // Classes NOT available to Drakkin
  const allDrakkinClasses = new Set<number>();
  for (const h of drakkinHeritages) for (const c of h.classes) allDrakkinClasses.add(c);
  const missingClasses = Object.keys(CLASS_IDS).map(Number).filter(c => !allDrakkinClasses.has(c));
  if (missingClasses.length > 0) {
    lines.push('', '## Classes NOT Available to Drakkin', '');
    for (const c of missingClasses) lines.push(`- ${CLASS_IDS[c]}`);
  }

  // Heritage exclusivity analysis
  lines.push('', '## Heritage Exclusivity', '');
  const exclusiveClasses: Record<string, number[]> = {};
  const heritageList = drakkinHeritages;
  for (const h of heritageList) {
    const exclusive = h.classes.filter(c => {
      return heritageList.filter(h2 => h2.classes.includes(c)).length === 1;
    });
    if (exclusive.length > 0) exclusiveClasses[h.name] = exclusive;
  }
  if (Object.keys(exclusiveClasses).length > 0) {
    for (const [heritage, classes] of Object.entries(exclusiveClasses)) {
      lines.push(`- **${heritage}:** exclusive access to ${classes.map(c => CLASS_IDS[c]).join(', ')}`);
    }
  } else {
    lines.push('*No heritage has exclusive class access — all classes available to Drakkin are shared across multiple heritages.*');
  }

  // Class overlap matrix
  lines.push('', '## Heritage Overlap (Shared Classes)', '');
  lines.push('| Heritage Pair | Shared Classes | Shared Count |');
  lines.push('|:--------------|:---------------|-------------:|');
  for (let i = 0; i < heritageList.length; i++) {
    for (let j = i + 1; j < heritageList.length; j++) {
      const shared = heritageList[i].classes.filter(c => heritageList[j].classes.includes(c));
      if (shared.length > 0) {
        lines.push(`| ${heritageList[i].name} + ${heritageList[j].name} | ${shared.map(c => CLASS_IDS[c]).join(', ')} | ${shared.length} |`);
      }
    }
  }

  lines.push('', `*${drakkinHeritages.length} Drakkin heritages analyzed.*`);
  return lines.join('\n');
}

// Tool 265: Spell subcategory depth analysis
export async function getSpellSubcategoryDepthAnalysis(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const lines = ['# Spell Subcategory Depth Analysis', ''];
  lines.push('*Analyzes spell subcategory distribution, class specialization by subcategory, and category-subcategory hierarchies.*', '');

  // Gather category+subcategory data
  const catSubCounts: Map<string, number> = new Map(); // "catName|subName" -> count
  const subClassCounts: Map<string, Set<number>> = new Map(); // subName -> set of classIds
  const subSpellCounts: Map<string, number> = new Map(); // subName -> spell count
  const catSpellCounts: Map<string, number> = new Map(); // catName -> spell count
  const classSubCounts: Map<number, Map<string, number>> = new Map(); // classId -> subName -> count

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const subId = parseInt(spell.fields[SF.SUBCATEGORY]) || 0;
    const catName = spellCategories?.get(catId) || `Cat ${catId}`;
    const subName = spellCategories?.get(subId) || `Sub ${subId}`;

    const key = `${catName}|${subName}`;
    catSubCounts.set(key, (catSubCounts.get(key) || 0) + 1);
    subSpellCounts.set(subName, (subSpellCounts.get(subName) || 0) + 1);
    catSpellCounts.set(catName, (catSpellCounts.get(catName) || 0) + 1);

    if (!subClassCounts.has(subName)) subClassCounts.set(subName, new Set());

    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < 255) {
        subClassCounts.get(subName)!.add(i);
        if (!classSubCounts.has(i)) classSubCounts.set(i, new Map());
        const m = classSubCounts.get(i)!;
        m.set(subName, (m.get(subName) || 0) + 1);
      }
    }
  }

  lines.push(`- **Unique categories:** ${catSpellCounts.size}`);
  lines.push(`- **Unique subcategories:** ${subSpellCounts.size}`);
  lines.push(`- **Category-subcategory combinations:** ${catSubCounts.size}`);

  // Top subcategories
  lines.push('', '## Top 25 Subcategories by Spell Count', '');
  lines.push('| Subcategory | Spells | Classes |');
  lines.push('|:------------|-------:|--------:|');
  const sortedSubs = [...subSpellCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [name, count] of sortedSubs.slice(0, 25)) {
    const classCount = subClassCounts.get(name)?.size || 0;
    lines.push(`| ${name} | ${count} | ${classCount} |`);
  }

  // Class-exclusive subcategories
  lines.push('', '## Class-Exclusive Subcategories', '');
  lines.push('*Subcategories where only one class has spells.*', '');
  const exclusive: { subName: string; classId: number; count: number }[] = [];
  for (const [subName, classes] of subClassCounts) {
    if (classes.size === 1) {
      const classId = [...classes][0];
      const count = subSpellCounts.get(subName) || 0;
      if (count >= 3) exclusive.push({ subName, classId, count });
    }
  }
  exclusive.sort((a, b) => b.count - a.count);
  if (exclusive.length > 0) {
    lines.push('| Subcategory | Class | Spells |');
    lines.push('|:------------|:------|-------:|');
    for (const e of exclusive.slice(0, 20)) {
      lines.push(`| ${e.subName} | ${CLASS_IDS[e.classId]} | ${e.count} |`);
    }
  } else {
    lines.push('*No class-exclusive subcategories found with 3+ spells.*');
  }

  // Category-subcategory hierarchy (top categories)
  lines.push('', '## Category → Subcategory Hierarchy (Top 10 Categories)', '');
  const sortedCats = [...catSpellCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [catName] of sortedCats.slice(0, 10)) {
    const subs: { name: string; count: number }[] = [];
    for (const [key, count] of catSubCounts) {
      const [cat, sub] = key.split('|');
      if (cat === catName) subs.push({ name: sub, count });
    }
    subs.sort((a, b) => b.count - a.count);
    lines.push(``, `### ${catName} (${catSpellCounts.get(catName)} spells)`);
    for (const s of subs.slice(0, 8)) {
      lines.push(`- ${s.name}: ${s.count} spells`);
    }
  }

  // Per-class specialization (top subcategory per class)
  lines.push('', '## Class Specialization (Top Subcategory per Class)', '');
  lines.push('| Class | Top Subcategory | Spells in Sub | % of Class |');
  lines.push('|:------|:----------------|-------------:|----------:|');
  for (let i = 1; i <= 16; i++) {
    const m = classSubCounts.get(i);
    if (!m) continue;
    const total = [...m.values()].reduce((s, v) => s + v, 0);
    const [topSub, topCount] = [...m.entries()].sort((a, b) => b[1] - a[1])[0];
    const pct = ((topCount / total) * 100).toFixed(1);
    lines.push(`| ${CLASS_IDS[i]} | ${topSub} | ${topCount} | ${pct}% |`);
  }

  lines.push('', `*${catSubCounts.size} category-subcategory combinations analyzed.*`);
  return lines.join('\n');
}

// Tool 266: Skill cap cross-class comparison for a specific skill
export async function getSkillCapCrossClassComparison(skillName: string): Promise<string> {
  await loadSkillCaps();
  if (!skillCaps || skillCaps.length === 0) return 'Skill cap data not available.';

  // Resolve skill ID
  let targetSkillId: number | undefined;
  for (const [id, name] of Object.entries(SKILL_NAMES)) {
    if (name.toLowerCase() === skillName.toLowerCase()) {
      targetSkillId = parseInt(id);
      break;
    }
  }
  if (targetSkillId === undefined) {
    // Fuzzy match
    for (const [id, name] of Object.entries(SKILL_NAMES)) {
      if (name.toLowerCase().includes(skillName.toLowerCase())) {
        targetSkillId = parseInt(id);
        break;
      }
    }
  }
  if (targetSkillId === undefined) {
    return `Unknown skill: "${skillName}". Available skills: ${Object.values(SKILL_NAMES).join(', ')}`;
  }

  const sName = SKILL_NAMES[targetSkillId];
  const lines = [`# Skill Cap Cross-Class Comparison — ${sName}`, ''];
  lines.push(`*Compares ${sName} skill cap progression across all 16 classes.*`, '');

  // Gather data per class for this skill
  const classData: Record<number, { maxCap: number; levels: { level: number; cap: number }[] }> = {};
  for (const entry of skillCaps) {
    if (entry.skillId !== targetSkillId) continue;
    if (!classData[entry.classId]) classData[entry.classId] = { maxCap: 0, levels: [] };
    classData[entry.classId].levels.push({ level: entry.level, cap: entry.cap });
    if (entry.cap > classData[entry.classId].maxCap) classData[entry.classId].maxCap = entry.cap;
  }

  if (Object.keys(classData).length === 0) {
    return `No skill cap data found for ${sName}. This skill may not have cap data.`;
  }

  // Classes that have this skill vs don't
  const hasSkill = Object.keys(classData).map(Number).sort((a, b) => a - b);
  const noSkill = Object.keys(CLASS_IDS).map(Number).filter(c => !classData[c]);

  lines.push(`- **Classes with ${sName}:** ${hasSkill.length}`);
  lines.push(`- **Classes without ${sName}:** ${noSkill.length}`);
  if (noSkill.length > 0) {
    lines.push(`- **Cannot learn:** ${noSkill.map(c => CLASS_IDS[c]).join(', ')}`);
  }

  // Max cap comparison
  lines.push('', '## Max Skill Cap by Class', '');
  lines.push('| Rank | Class | Max Cap |');
  lines.push('|-----:|:------|--------:|');
  const sortedClasses = hasSkill.sort((a, b) => (classData[b]?.maxCap || 0) - (classData[a]?.maxCap || 0));
  for (let i = 0; i < sortedClasses.length; i++) {
    const cid = sortedClasses[i];
    lines.push(`| ${i + 1} | ${CLASS_IDS[cid]} | ${classData[cid].maxCap} |`);
  }

  // Progression at milestone levels
  const milestones = [1, 10, 20, 30, 40, 50, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130];
  lines.push('', '## Progression at Milestone Levels', '');
  const header = ['| Level |', ...sortedClasses.map(c => ` ${CLASS_IDS[c]} |`)].join('');
  const divider = ['|------:|', ...sortedClasses.map(() => '-------:|')].join('');
  lines.push(header);
  lines.push(divider);

  for (const lvl of milestones) {
    const row = [`| ${lvl} |`];
    for (const cid of sortedClasses) {
      const entry = classData[cid]?.levels.find(e => e.level === lvl);
      row.push(entry ? ` ${entry.cap} |` : ' — |');
    }
    lines.push(row.join(''));
  }

  // Growth analysis: which class gains the most between level 1 and max
  lines.push('', '## Growth Analysis', '');
  lines.push('| Class | Level 1 Cap | Max Cap | Growth | Growth % |');
  lines.push('|:------|------------:|--------:|-------:|---------:|');
  for (const cid of sortedClasses) {
    const data = classData[cid];
    const sortedLvls = data.levels.sort((a, b) => a.level - b.level);
    const first = sortedLvls[0];
    const last = sortedLvls[sortedLvls.length - 1];
    const growth = last.cap - first.cap;
    const growthPct = first.cap > 0 ? ((growth / first.cap) * 100).toFixed(0) : '∞';
    lines.push(`| ${CLASS_IDS[cid]} | ${first.cap} | ${last.cap} | +${growth} | ${growthPct}% |`);
  }

  // Tier grouping at max level
  const maxCaps = sortedClasses.map(c => classData[c].maxCap);
  const topCap = Math.max(...maxCaps);
  lines.push('', '## Proficiency Tiers', '');
  const tiers: Record<string, string[]> = { 'Master (90-100%)': [], 'Expert (70-89%)': [], 'Journeyman (50-69%)': [], 'Novice (<50%)': [] };
  for (const cid of sortedClasses) {
    const pct = (classData[cid].maxCap / topCap) * 100;
    if (pct >= 90) tiers['Master (90-100%)'].push(CLASS_IDS[cid]);
    else if (pct >= 70) tiers['Expert (70-89%)'].push(CLASS_IDS[cid]);
    else if (pct >= 50) tiers['Journeyman (50-69%)'].push(CLASS_IDS[cid]);
    else tiers['Novice (<50%)'].push(CLASS_IDS[cid]);
  }
  for (const [tier, classes] of Object.entries(tiers)) {
    if (classes.length > 0) lines.push(`- **${tier}:** ${classes.join(', ')}`);
  }

  lines.push('', `*${sName} skill cap compared across ${hasSkill.length} classes.*`);
  return lines.join('\n');
}

// Tool 267: Spell mana efficiency analysis
export async function getSpellManaEfficiencyAnalysis(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase())?.[0];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const cid = parseInt(classId);
  const lines = [`# Spell Mana Efficiency Analysis — ${CLASS_IDS[cid]}`, ''];
  lines.push(`*Analyzes mana costs and efficiency patterns for ${CLASS_IDS[cid]} spells.*`, '');

  const classSpells: { id: number; name: string; level: number; mana: number; castTime: number; beneficial: boolean; category: string }[] = [];
  for (const [spellId, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
    if (level <= 0 || level >= 255) continue;
    const mana = parseInt(spell.fields[SF.MANA]) || 0;
    if (mana <= 0) continue;
    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const cat = spellCategories?.get(catId) || 'Unknown';
    classSpells.push({ id: spellId, name: spell.name, level, mana, castTime, beneficial, category: cat });
  }

  if (classSpells.length === 0) return `No mana-cost spells found for ${CLASS_IDS[cid]}.`;

  lines.push(`- **Total spells with mana cost:** ${classSpells.length}`);
  const avgMana = classSpells.reduce((s, sp) => s + sp.mana, 0) / classSpells.length;
  lines.push(`- **Average mana cost:** ${Math.round(avgMana)}`);

  // Mana cost distribution
  lines.push('', '## Mana Cost Distribution', '');
  const buckets: Record<string, number> = {};
  for (const sp of classSpells) {
    const bucket = sp.mana <= 50 ? '1-50' : sp.mana <= 100 ? '51-100' : sp.mana <= 250 ? '101-250' :
      sp.mana <= 500 ? '251-500' : sp.mana <= 1000 ? '501-1000' : sp.mana <= 5000 ? '1001-5000' : '5001+';
    buckets[bucket] = (buckets[bucket] || 0) + 1;
  }
  const bucketOrder = ['1-50', '51-100', '101-250', '251-500', '501-1000', '1001-5000', '5001+'];
  for (const b of bucketOrder) {
    if (buckets[b]) {
      const pct = ((buckets[b] / classSpells.length) * 100).toFixed(1);
      lines.push(`- **${b} mana:** ${buckets[b]} spells (${pct}%)`);
    }
  }

  // Most expensive spells
  const byMana = [...classSpells].sort((a, b) => b.mana - a.mana);
  lines.push('', '## Most Expensive Spells (Top 15)', '');
  lines.push('| Spell | Level | Mana | Cast (s) | Category |');
  lines.push('|:------|------:|-----:|---------:|:---------|');
  for (const sp of byMana.slice(0, 15)) {
    const castSec = (sp.castTime / 1000).toFixed(1);
    lines.push(`| ${sp.name} | ${sp.level} | ${sp.mana} | ${castSec} | ${sp.category} |`);
  }

  // Cheapest spells at high levels
  const highLevel = classSpells.filter(sp => sp.level >= 100);
  if (highLevel.length > 0) {
    const cheapHigh = [...highLevel].sort((a, b) => a.mana - b.mana);
    lines.push('', '## Cheapest Spells at Level 100+ (Top 15)', '');
    lines.push('| Spell | Level | Mana | Cast (s) | Type |');
    lines.push('|:------|------:|-----:|---------:|:-----|');
    for (const sp of cheapHigh.slice(0, 15)) {
      const castSec = (sp.castTime / 1000).toFixed(1);
      const type = sp.beneficial ? 'Beneficial' : 'Detrimental';
      lines.push(`| ${sp.name} | ${sp.level} | ${sp.mana} | ${castSec} | ${type} |`);
    }
  }

  // Mana cost per level trend
  lines.push('', '## Average Mana Cost by Level Range', '');
  lines.push('| Level Range | Avg Mana | Spell Count | Max Mana |');
  lines.push('|:------------|--------:|-----------:|---------:|');
  const levelRanges: [string, number, number][] = [
    ['1-20', 1, 20], ['21-40', 21, 40], ['41-60', 41, 60], ['61-80', 61, 80],
    ['81-100', 81, 100], ['101-115', 101, 115], ['116-130', 116, 130],
  ];
  for (const [label, lo, hi] of levelRanges) {
    const inRange = classSpells.filter(sp => sp.level >= lo && sp.level <= hi);
    if (inRange.length === 0) continue;
    const avg = Math.round(inRange.reduce((s, sp) => s + sp.mana, 0) / inRange.length);
    const max = Math.max(...inRange.map(sp => sp.mana));
    lines.push(`| ${label} | ${avg} | ${inRange.length} | ${max} |`);
  }

  // Mana cost by category
  lines.push('', '## Mana Cost by Spell Category', '');
  lines.push('| Category | Spells | Avg Mana | Min | Max |');
  lines.push('|:---------|-------:|--------:|----:|----:|');
  const byCat: Record<string, { count: number; total: number; min: number; max: number }> = {};
  for (const sp of classSpells) {
    if (!byCat[sp.category]) byCat[sp.category] = { count: 0, total: 0, min: Infinity, max: 0 };
    byCat[sp.category].count++;
    byCat[sp.category].total += sp.mana;
    if (sp.mana < byCat[sp.category].min) byCat[sp.category].min = sp.mana;
    if (sp.mana > byCat[sp.category].max) byCat[sp.category].max = sp.mana;
  }
  for (const [cat, d] of Object.entries(byCat).sort((a, b) => b[1].count - a[1].count).slice(0, 15)) {
    const avg = Math.round(d.total / d.count);
    lines.push(`| ${cat} | ${d.count} | ${avg} | ${d.min} | ${d.max} |`);
  }

  // Cast time vs mana correlation
  lines.push('', '## Cast Time vs Mana (Averages)', '');
  const castBuckets: Record<string, { count: number; totalMana: number }> = {};
  for (const sp of classSpells) {
    const castSec = sp.castTime / 1000;
    const bucket = castSec <= 0.5 ? 'Instant' : castSec <= 1.5 ? '0.5-1.5s' : castSec <= 3 ? '1.5-3s' : castSec <= 6 ? '3-6s' : '6s+';
    if (!castBuckets[bucket]) castBuckets[bucket] = { count: 0, totalMana: 0 };
    castBuckets[bucket].count++;
    castBuckets[bucket].totalMana += sp.mana;
  }
  const castOrder = ['Instant', '0.5-1.5s', '1.5-3s', '3-6s', '6s+'];
  for (const b of castOrder) {
    if (castBuckets[b]) {
      const avg = Math.round(castBuckets[b].totalMana / castBuckets[b].count);
      lines.push(`- **${b}:** ${castBuckets[b].count} spells, avg ${avg} mana`);
    }
  }

  lines.push('', `*${classSpells.length} ${CLASS_IDS[cid]} spells analyzed for mana efficiency.*`);
  return lines.join('\n');
}

// Tool 268: Faction category analysis
export async function getFactionCategoryAnalysis(): Promise<string> {
  await loadFactions();
  if (!factions || factions.size === 0) return 'Faction data not available.';

  const lines = ['# Faction Category Analysis', ''];
  lines.push('*Analyzes how factions are distributed across categories (expansions) with value range and starting value statistics.*', '');

  const catFactions: Record<string, FactionEntry[]> = {};
  let uncategorized = 0;
  for (const [, f] of factions) {
    const cat = f.category || 'Uncategorized';
    if (!f.category) uncategorized++;
    if (!catFactions[cat]) catFactions[cat] = [];
    catFactions[cat].push(f);
  }

  lines.push(`- **Total factions:** ${factions.size}`);
  lines.push(`- **Categories:** ${Object.keys(catFactions).length}`);
  lines.push(`- **Uncategorized:** ${uncategorized}`);

  // Category distribution
  lines.push('', '## Factions by Category', '');
  lines.push('| Category | Factions | Avg Min | Avg Max | Range Span |');
  lines.push('|:---------|--------:|-------:|--------:|----------:|');
  const sortedCats = Object.entries(catFactions).sort((a, b) => b[1].length - a[1].length);
  for (const [cat, entries] of sortedCats) {
    const avgMin = Math.round(entries.reduce((s, e) => s + e.minValue, 0) / entries.length);
    const avgMax = Math.round(entries.reduce((s, e) => s + e.maxValue, 0) / entries.length);
    const avgSpan = avgMax - avgMin;
    lines.push(`| ${cat} | ${entries.length} | ${avgMin.toLocaleString()} | ${avgMax.toLocaleString()} | ${avgSpan.toLocaleString()} |`);
  }

  // Faction value range analysis
  lines.push('', '## Faction Value Range Distribution', '');
  const rangeBuckets: Record<string, number> = {};
  for (const [, f] of factions) {
    const span = f.maxValue - f.minValue;
    const bucket = span <= 1000 ? '0-1K' : span <= 5000 ? '1K-5K' : span <= 10000 ? '5K-10K' : span <= 50000 ? '10K-50K' : '50K+';
    rangeBuckets[bucket] = (rangeBuckets[bucket] || 0) + 1;
  }
  for (const [bucket, count] of Object.entries(rangeBuckets).sort((a, b) => b[1] - a[1])) {
    const pct = ((count / factions.size) * 100).toFixed(1);
    lines.push(`- **${bucket}:** ${count} factions (${pct}%)`);
  }

  // Factions with starting values
  let factionsWithStarting = 0;
  let totalStartingEntries = 0;
  const modifierUsage: Record<number, number> = {};
  for (const [, f] of factions) {
    if (f.startingValues && f.startingValues.length > 0) {
      factionsWithStarting++;
      totalStartingEntries += f.startingValues.length;
      for (const sv of f.startingValues) {
        modifierUsage[sv.modifierId] = (modifierUsage[sv.modifierId] || 0) + 1;
      }
    }
  }
  lines.push('', '## Starting Value Analysis', '');
  lines.push(`- **Factions with starting values:** ${factionsWithStarting} (${((factionsWithStarting / factions.size) * 100).toFixed(1)}%)`);
  lines.push(`- **Total starting value entries:** ${totalStartingEntries}`);

  if (Object.keys(modifierUsage).length > 0) {
    lines.push('', '## Most Common Starting Value Modifiers', '');
    lines.push('| Modifier ID | Modifier Name | Faction Count |');
    lines.push('|:------------|:--------------|-------------:|');
    const sortedMods = Object.entries(modifierUsage).sort((a, b) => b[1] - a[1]);
    for (const [modId, count] of sortedMods.slice(0, 20)) {
      const name = factionModifierNames?.get(parseInt(modId)) || `Modifier ${modId}`;
      lines.push(`| ${modId} | ${name} | ${count} |`);
    }
  }

  // Widest and narrowest faction ranges
  lines.push('', '## Widest Faction Ranges (Top 10)', '');
  lines.push('| Faction | Min | Max | Span | Category |');
  lines.push('|:--------|----:|----:|-----:|:---------|');
  const bySpan = [...factions.values()].sort((a, b) => (b.maxValue - b.minValue) - (a.maxValue - a.minValue));
  for (const f of bySpan.slice(0, 10)) {
    const span = f.maxValue - f.minValue;
    lines.push(`| ${f.name} | ${f.minValue.toLocaleString()} | ${f.maxValue.toLocaleString()} | ${span.toLocaleString()} | ${f.category || '—'} |`);
  }

  lines.push('', '## Narrowest Faction Ranges (Top 10)', '');
  lines.push('| Faction | Min | Max | Span | Category |');
  lines.push('|:--------|----:|----:|-----:|:---------|');
  const narrowest = [...factions.values()].sort((a, b) => (a.maxValue - a.minValue) - (b.maxValue - b.minValue));
  for (const f of narrowest.slice(0, 10)) {
    const span = f.maxValue - f.minValue;
    lines.push(`| ${f.name} | ${f.minValue.toLocaleString()} | ${f.maxValue.toLocaleString()} | ${span.toLocaleString()} | ${f.category || '—'} |`);
  }

  lines.push('', `*${factions.size} factions across ${Object.keys(catFactions).length} categories analyzed.*`);
  return lines.join('\n');
}

// Tool 269: Overseer quest slot job requirement analysis
export async function getOverseerQuestSlotJobAnalysis(): Promise<string> {
  await loadOverseerQuests();
  await loadOverseerEnhancements();
  if (!overseerQuests || overseerQuests.size === 0) return 'Overseer quest data not available.';

  const lines = ['# Overseer Quest Slot & Job Requirement Analysis', ''];
  lines.push('*Analyzes which job types are most commonly required across quest slots, slot distributions, and job demand.*', '');

  let totalRequired = 0;
  let totalOptional = 0;
  let totalSlots = 0;
  const jobRequired: Map<number, number> = new Map();
  const jobOptional: Map<number, number> = new Map();
  const jobTotal: Map<number, number> = new Map();
  const slotCountDist: Record<number, number> = {};
  const requiredCountDist: Record<number, number> = {};
  const bonusTraitCountDist: Record<number, number> = {};

  for (const [, quest] of overseerQuests) {
    totalRequired += quest.requiredSlots;
    totalOptional += quest.optionalSlots;
    const total = quest.requiredSlots + quest.optionalSlots;
    totalSlots += total;
    slotCountDist[total] = (slotCountDist[total] || 0) + 1;
    requiredCountDist[quest.requiredSlots] = (requiredCountDist[quest.requiredSlots] || 0) + 1;

    for (const slot of quest.slotDetails) {
      const map = slot.isRequired ? jobRequired : jobOptional;
      map.set(slot.jobTypeId, (map.get(slot.jobTypeId) || 0) + 1);
      jobTotal.set(slot.jobTypeId, (jobTotal.get(slot.jobTypeId) || 0) + 1);
      bonusTraitCountDist[slot.bonusTraitIds.length] = (bonusTraitCountDist[slot.bonusTraitIds.length] || 0) + 1;
    }
  }

  lines.push(`- **Total quests:** ${overseerQuests.size}`);
  lines.push(`- **Total slots:** ${totalSlots}`);
  lines.push(`- **Total required slots:** ${totalRequired}`);
  lines.push(`- **Total optional slots:** ${totalOptional}`);
  lines.push(`- **Average slots per quest:** ${(totalSlots / overseerQuests.size).toFixed(1)}`);

  const jobName = (id: number): string => overseerJobNames?.get(id) || `Job ${id}`;
  lines.push('', '## Job Type Demand (All Slots)', '');
  lines.push('| Job Type | Total | Required | Optional | % of Total |');
  lines.push('|:---------|------:|---------:|---------:|---------:|');
  const sortedJobs = [...jobTotal.entries()].sort((a, b) => b[1] - a[1]);
  for (const [jobId, total] of sortedJobs) {
    const req = jobRequired.get(jobId) || 0;
    const opt = jobOptional.get(jobId) || 0;
    const pct = ((total / totalSlots) * 100).toFixed(1);
    lines.push(`| ${jobName(jobId)} | ${total} | ${req} | ${opt} | ${pct}% |`);
  }

  lines.push('', '## Slot Count Distribution', '');
  for (const [count, freq] of Object.entries(slotCountDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    const pct = ((freq / overseerQuests.size) * 100).toFixed(1);
    lines.push(`- **${count} slots:** ${freq} quests (${pct}%)`);
  }

  lines.push('', '## Required Slot Distribution', '');
  for (const [count, freq] of Object.entries(requiredCountDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    const pct = ((freq / overseerQuests.size) * 100).toFixed(1);
    lines.push(`- **${count} required:** ${freq} quests (${pct}%)`);
  }

  lines.push('', '## Bonus Traits per Slot', '');
  for (const [count, freq] of Object.entries(bonusTraitCountDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    lines.push(`- **${count} bonus traits:** ${freq} slots`);
  }

  lines.push('', '## Job Required vs Optional Ratio', '');
  lines.push('| Job Type | Required % | Optional % |');
  lines.push('|:---------|----------:|-----------:|');
  for (const [jobId, total] of sortedJobs.slice(0, 15)) {
    const req = jobRequired.get(jobId) || 0;
    const opt = jobOptional.get(jobId) || 0;
    const reqPct = ((req / total) * 100).toFixed(0);
    const optPct = ((opt / total) * 100).toFixed(0);
    lines.push(`| ${jobName(jobId)} | ${reqPct}% | ${optPct}% |`);
  }

  lines.push('', '## Quests with Most Slots', '');
  lines.push('| Quest | Required | Optional | Total | Difficulty |');
  lines.push('|:------|--------:|---------:|------:|---------:|');
  const sortedBySlots = [...overseerQuests.values()].sort((a, b) => (b.requiredSlots + b.optionalSlots) - (a.requiredSlots + a.optionalSlots));
  for (const q of sortedBySlots.slice(0, 10)) {
    lines.push(`| ${q.name} | ${q.requiredSlots} | ${q.optionalSlots} | ${q.requiredSlots + q.optionalSlots} | ${q.difficulty} |`);
  }

  lines.push('', `*${totalSlots} slots across ${overseerQuests.size} quests analyzed.*`);
  return lines.join('\n');
}

// Tool 270: Class beneficial/detrimental ratio analysis
export async function getClassBuffDebuffRatio(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const lines = ['# Class Beneficial/Detrimental Spell Ratio', ''];
  lines.push('*Compares the balance of beneficial vs detrimental spells across all 16 classes.*', '');

  const classStats: Record<number, { beneficial: number; detrimental: number; total: number; byTarget: Record<string, { ben: number; det: number }> }> = {};
  for (let i = 1; i <= 16; i++) classStats[i] = { beneficial: 0, detrimental: 0, total: 0, byTarget: {} };

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';
    const targetType = parseInt(spell.fields[SF.TARGET_TYPE]) || 0;
    const targetName = TARGET_TYPES[targetType] || `Type ${targetType}`;

    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
      classStats[i].total++;
      if (beneficial) classStats[i].beneficial++;
      else classStats[i].detrimental++;

      if (!classStats[i].byTarget[targetName]) classStats[i].byTarget[targetName] = { ben: 0, det: 0 };
      if (beneficial) classStats[i].byTarget[targetName].ben++;
      else classStats[i].byTarget[targetName].det++;
    }
  }

  // Main comparison table
  lines.push('## Beneficial vs Detrimental by Class', '');
  lines.push('| Class | Beneficial | Detrimental | Total | Ben % | Det % | Ratio |');
  lines.push('|:------|----------:|-----------:|------:|------:|------:|------:|');
  const sorted = Object.entries(classStats).sort((a, b) => {
    const ra = b[1].beneficial / (b[1].detrimental || 1);
    const rb = a[1].beneficial / (a[1].detrimental || 1);
    return ra - rb;
  });
  for (const [cid, stats] of sorted) {
    const benPct = ((stats.beneficial / stats.total) * 100).toFixed(1);
    const detPct = ((stats.detrimental / stats.total) * 100).toFixed(1);
    const ratio = stats.detrimental > 0 ? (stats.beneficial / stats.detrimental).toFixed(2) : '∞';
    lines.push(`| ${CLASS_IDS[parseInt(cid)]} | ${stats.beneficial} | ${stats.detrimental} | ${stats.total} | ${benPct}% | ${detPct}% | ${ratio} |`);
  }

  // Most offensive classes (highest det%)
  lines.push('', '## Class Role Tendency', '');
  const byDetPct = Object.entries(classStats).sort((a, b) => {
    return (b[1].detrimental / b[1].total) - (a[1].detrimental / a[1].total);
  });
  lines.push('**Most offensive (highest detrimental %):**');
  for (const [cid, stats] of byDetPct.slice(0, 5)) {
    const pct = ((stats.detrimental / stats.total) * 100).toFixed(1);
    lines.push(`- ${CLASS_IDS[parseInt(cid)]}: ${pct}% detrimental`);
  }
  lines.push('', '**Most supportive (highest beneficial %):**');
  for (const [cid, stats] of byDetPct.slice(-5).reverse()) {
    const pct = ((stats.beneficial / stats.total) * 100).toFixed(1);
    lines.push(`- ${CLASS_IDS[parseInt(cid)]}: ${pct}% beneficial`);
  }

  // Target type breakdown (aggregate across all classes)
  lines.push('', '## Beneficial/Detrimental by Target Type (All Classes)', '');
  lines.push('| Target Type | Beneficial | Detrimental | Total |');
  lines.push('|:------------|----------:|-----------:|------:|');
  const targetAgg: Record<string, { ben: number; det: number }> = {};
  for (const stats of Object.values(classStats)) {
    for (const [tgt, counts] of Object.entries(stats.byTarget)) {
      if (!targetAgg[tgt]) targetAgg[tgt] = { ben: 0, det: 0 };
      targetAgg[tgt].ben += counts.ben;
      targetAgg[tgt].det += counts.det;
    }
  }
  for (const [tgt, counts] of Object.entries(targetAgg).sort((a, b) => (b[1].ben + b[1].det) - (a[1].ben + a[1].det)).slice(0, 12)) {
    lines.push(`| ${tgt} | ${counts.ben} | ${counts.det} | ${counts.ben + counts.det} |`);
  }

  lines.push('', '*Beneficial/detrimental ratio analyzed across all 16 classes.*');
  return lines.join('\n');
}

// Tool 271: Spell recourse chain analysis
export async function getSpellRecourseChainAnalysis(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const lines = ['# Spell Recourse Chain Analysis', ''];
  lines.push('*Analyzes spells that trigger secondary "recourse" spells on the caster, and traces recourse chains.*', '');

  // Find all spells with recourse IDs
  const recourseSpells: { id: number; name: string; recourseId: number; recourseName: string; classes: number[] }[] = [];
  const recourseTargets = new Set<number>(); // spell IDs that ARE recourse targets

  for (const [spellId, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const recourseId = parseInt(spell.fields[SF.RECOURSE]) || 0;
    if (recourseId <= 0) continue;

    const recourseSpell = spells.get(recourseId);
    if (!recourseSpell) continue;

    const classes: number[] = [];
    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level > 0 && level < 255) classes.push(i);
    }

    recourseSpells.push({ id: spellId, name: spell.name, recourseId, recourseName: recourseSpell.name, classes });
    recourseTargets.add(recourseId);
  }

  lines.push(`- **Spells with recourse effects:** ${recourseSpells.length}`);
  lines.push(`- **Unique recourse target spells:** ${recourseTargets.size}`);

  // Recourse chains (A -> B -> C)
  const chains: { chain: string[]; depth: number }[] = [];
  for (const rs of recourseSpells) {
    const chain = [rs.name];
    let currentId = rs.recourseId;
    const visited = new Set<number>([rs.id]);
    while (currentId > 0 && !visited.has(currentId)) {
      visited.add(currentId);
      const spell = spells.get(currentId);
      if (!spell) break;
      chain.push(spell.name);
      currentId = parseInt(spell.fields[SF.RECOURSE]) || 0;
    }
    if (chain.length >= 2) chains.push({ chain, depth: chain.length });
  }

  // Longest chains
  chains.sort((a, b) => b.depth - a.depth);
  lines.push('', '## Longest Recourse Chains', '');
  lines.push('| Chain | Depth |');
  lines.push('|:------|------:|');
  const shown = new Set<string>();
  for (const c of chains) {
    const key = c.chain.join(' → ');
    if (shown.has(key)) continue;
    shown.add(key);
    lines.push(`| ${key} | ${c.depth} |`);
    if (shown.size >= 15) break;
  }

  // Chain depth distribution
  const depthDist: Record<number, number> = {};
  for (const c of chains) depthDist[c.depth] = (depthDist[c.depth] || 0) + 1;
  lines.push('', '## Chain Depth Distribution', '');
  for (const [depth, count] of Object.entries(depthDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
    lines.push(`- **Depth ${depth}:** ${count} chains`);
  }

  // Recourse by class
  lines.push('', '## Recourse Spells by Class', '');
  lines.push('| Class | Spells with Recourse | % of Class |');
  lines.push('|:------|--------------------:|----------:|');
  const classCounts: Record<number, number> = {};
  for (const rs of recourseSpells) {
    for (const c of rs.classes) classCounts[c] = (classCounts[c] || 0) + 1;
  }
  for (const [cid, count] of Object.entries(classCounts).sort((a, b) => b[1] - a[1])) {
    // Get total class spells
    let classTotal = 0;
    for (const [, spell] of spells) {
      if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + parseInt(cid) - 1]) || 255;
      if (level > 0 && level < 255) classTotal++;
    }
    const pct = classTotal > 0 ? ((count / classTotal) * 100).toFixed(1) : '0';
    lines.push(`| ${CLASS_IDS[parseInt(cid)]} | ${count} | ${pct}% |`);
  }

  // Most common recourse target names (many spells might point to the same recourse)
  const targetCounts: Record<string, number> = {};
  for (const rs of recourseSpells) {
    targetCounts[rs.recourseName] = (targetCounts[rs.recourseName] || 0) + 1;
  }
  lines.push('', '## Most Common Recourse Targets', '');
  lines.push('| Recourse Spell | Sources |');
  lines.push('|:---------------|--------:|');
  for (const [name, count] of Object.entries(targetCounts).sort((a, b) => b[1] - a[1]).slice(0, 15)) {
    lines.push(`| ${name} | ${count} |`);
  }

  lines.push('', `*${recourseSpells.length} spells with recourse effects analyzed.*`);
  return lines.join('\n');
}

// Tool 272: Achievement completion complexity analysis
export async function getAchievementCompletionComplexity(): Promise<string> {
  await loadAchievements();
  await loadAchievementComponents();
  if (!achievements || !achievementComponents) return 'Achievement data not available.';

  const lines = ['# Achievement Completion Complexity Analysis', ''];
  lines.push('*Analyzes achievement complexity based on component requirements, identifying the easiest and hardest achievements.*', '');

  // Gather component counts per achievement
  const achComplexity: { id: number; name: string; components: number; maxReq: number; sumReq: number; types: Set<number> }[] = [];

  for (const [achId, ach] of achievements) {
    const comps = achievementComponents.get(achId) || [];
    let maxReq = 0;
    let sumReq = 0;
    const types = new Set<number>();
    for (const comp of comps) {
      if (comp.requirement > maxReq) maxReq = comp.requirement;
      sumReq += comp.requirement;
      types.add(comp.type);
    }
    achComplexity.push({ id: achId, name: ach.name, components: comps.length, maxReq, sumReq, types });
  }

  lines.push(`- **Total achievements:** ${achievements.size}`);
  lines.push(`- **Achievements with components:** ${achComplexity.filter(a => a.components > 0).length}`);
  const totalComponents = achComplexity.reduce((s, a) => s + a.components, 0);
  lines.push(`- **Total components:** ${totalComponents}`);
  const avgComponents = (totalComponents / achComplexity.length).toFixed(1);
  lines.push(`- **Average components per achievement:** ${avgComponents}`);

  // Component count distribution
  lines.push('', '## Component Count Distribution', '');
  const compDist: Record<number, number> = {};
  for (const a of achComplexity) {
    const bucket = a.components;
    compDist[bucket] = (compDist[bucket] || 0) + 1;
  }
  for (const [count, freq] of Object.entries(compDist).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).slice(0, 15)) {
    const pct = ((freq / achComplexity.length) * 100).toFixed(1);
    lines.push(`- **${count} components:** ${freq} achievements (${pct}%)`);
  }

  // Most complex achievements (most components)
  const byComponents = [...achComplexity].sort((a, b) => b.components - a.components);
  lines.push('', '## Most Complex Achievements (Most Components)', '');
  lines.push('| Achievement | Components | Max Req | Sum Req | Types |');
  lines.push('|:------------|----------:|--------:|--------:|------:|');
  for (const a of byComponents.slice(0, 15)) {
    lines.push(`| ${a.name} | ${a.components} | ${a.maxReq} | ${a.sumReq} | ${a.types.size} |`);
  }

  // Highest single requirement
  const byMaxReq = [...achComplexity].filter(a => a.maxReq > 0).sort((a, b) => b.maxReq - a.maxReq);
  lines.push('', '## Highest Single Requirement (Top 15)', '');
  lines.push('| Achievement | Max Requirement | Components |');
  lines.push('|:------------|---------------:|----------:|');
  for (const a of byMaxReq.slice(0, 15)) {
    lines.push(`| ${a.name} | ${a.maxReq.toLocaleString()} | ${a.components} |`);
  }

  // Simplest achievements (fewest components, non-zero)
  const bySimplest = achComplexity.filter(a => a.components > 0).sort((a, b) => a.components - b.components || a.sumReq - b.sumReq);
  lines.push('', '## Simplest Achievements (Fewest Components)', '');
  lines.push('| Achievement | Components | Sum Req |');
  lines.push('|:------------|----------:|--------:|');
  for (const a of bySimplest.slice(0, 15)) {
    lines.push(`| ${a.name} | ${a.components} | ${a.sumReq} |`);
  }

  // Component type distribution
  const typeDist: Record<number, number> = {};
  for (const comps of achievementComponents.values()) {
    for (const comp of comps) typeDist[comp.type] = (typeDist[comp.type] || 0) + 1;
  }
  lines.push('', '## Component Type Distribution', '');
  for (const [type, count] of Object.entries(typeDist).sort((a, b) => b[1] - a[1])) {
    const pct = ((count / totalComponents) * 100).toFixed(1);
    lines.push(`- **Type ${type}:** ${count} components (${pct}%)`);
  }

  // Requirement value distribution
  lines.push('', '## Requirement Value Distribution', '');
  const reqBuckets: Record<string, number> = {};
  for (const comps of achievementComponents.values()) {
    for (const comp of comps) {
      const bucket = comp.requirement <= 1 ? '0-1' : comp.requirement <= 5 ? '2-5' : comp.requirement <= 10 ? '6-10' :
        comp.requirement <= 50 ? '11-50' : comp.requirement <= 100 ? '51-100' : comp.requirement <= 1000 ? '101-1000' : '1000+';
      reqBuckets[bucket] = (reqBuckets[bucket] || 0) + 1;
    }
  }
  const reqOrder = ['0-1', '2-5', '6-10', '11-50', '51-100', '101-1000', '1000+'];
  for (const b of reqOrder) {
    if (reqBuckets[b]) lines.push(`- **${b}:** ${reqBuckets[b]} components`);
  }

  lines.push('', `*${achievements.size} achievements analyzed for complexity.*`);
  return lines.join('\n');
}

// Tool 273: Spell endurance cost analysis
export async function getSpellEnduranceCostAnalysis(className: string): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const classId = Object.entries(CLASS_IDS).find(([, name]) => name.toLowerCase() === className.toLowerCase())?.[0];
  if (!classId) return `Unknown class: "${className}". Valid classes: ${Object.values(CLASS_IDS).join(', ')}`;

  const cid = parseInt(classId);
  const lines = [`# Endurance Cost Analysis — ${CLASS_IDS[cid]}`, ''];
  lines.push(`*Analyzes endurance costs for ${CLASS_IDS[cid]} combat abilities and disciplines.*`, '');

  const endSpells: { id: number; name: string; level: number; endurance: number; mana: number; castTime: number; category: string }[] = [];
  for (const [spellId, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + cid - 1]) || 255;
    if (level <= 0 || level >= 255) continue;
    const endurance = parseInt(spell.fields[SF.ENDURANCE]) || 0;
    if (endurance <= 0) continue;
    const mana = parseInt(spell.fields[SF.MANA]) || 0;
    const castTime = parseInt(spell.fields[SF.CAST_TIME]) || 0;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const cat = spellCategories?.get(catId) || 'Unknown';
    endSpells.push({ id: spellId, name: spell.name, level, endurance, mana, castTime, category: cat });
  }

  if (endSpells.length === 0) return `No endurance-cost abilities found for ${CLASS_IDS[cid]}.`;

  lines.push(`- **Abilities with endurance cost:** ${endSpells.length}`);
  const avgEnd = Math.round(endSpells.reduce((s, sp) => s + sp.endurance, 0) / endSpells.length);
  lines.push(`- **Average endurance cost:** ${avgEnd}`);

  // Dual-resource abilities (both mana and endurance)
  const dualResource = endSpells.filter(sp => sp.mana > 0);
  lines.push(`- **Dual-resource (mana + endurance):** ${dualResource.length}`);

  // Distribution
  lines.push('', '## Endurance Cost Distribution', '');
  const buckets: Record<string, number> = {};
  for (const sp of endSpells) {
    const bucket = sp.endurance <= 50 ? '1-50' : sp.endurance <= 200 ? '51-200' : sp.endurance <= 500 ? '201-500' :
      sp.endurance <= 1000 ? '501-1000' : sp.endurance <= 5000 ? '1001-5000' : '5001+';
    buckets[bucket] = (buckets[bucket] || 0) + 1;
  }
  const bucketOrder = ['1-50', '51-200', '201-500', '501-1000', '1001-5000', '5001+'];
  for (const b of bucketOrder) {
    if (buckets[b]) lines.push(`- **${b}:** ${buckets[b]} abilities (${((buckets[b] / endSpells.length) * 100).toFixed(1)}%)`);
  }

  // Most expensive
  const byEnd = [...endSpells].sort((a, b) => b.endurance - a.endurance);
  lines.push('', '## Most Expensive Abilities (Top 15)', '');
  lines.push('| Ability | Level | Endurance | Mana | Category |');
  lines.push('|:--------|------:|----------:|-----:|:---------|');
  for (const sp of byEnd.slice(0, 15)) {
    lines.push(`| ${sp.name} | ${sp.level} | ${sp.endurance} | ${sp.mana || '—'} | ${sp.category} |`);
  }

  // By level range
  lines.push('', '## Average Endurance Cost by Level Range', '');
  lines.push('| Level Range | Avg End | Count | Max End |');
  lines.push('|:------------|--------:|------:|--------:|');
  const ranges: [string, number, number][] = [
    ['1-30', 1, 30], ['31-60', 31, 60], ['61-80', 61, 80],
    ['81-100', 81, 100], ['101-115', 101, 115], ['116-130', 116, 130],
  ];
  for (const [label, lo, hi] of ranges) {
    const inRange = endSpells.filter(sp => sp.level >= lo && sp.level <= hi);
    if (inRange.length === 0) continue;
    const avg = Math.round(inRange.reduce((s, sp) => s + sp.endurance, 0) / inRange.length);
    const max = Math.max(...inRange.map(sp => sp.endurance));
    lines.push(`| ${label} | ${avg} | ${inRange.length} | ${max} |`);
  }

  // By category
  lines.push('', '## Endurance Cost by Category', '');
  lines.push('| Category | Count | Avg End | Min | Max |');
  lines.push('|:---------|------:|--------:|----:|----:|');
  const byCat: Record<string, { count: number; total: number; min: number; max: number }> = {};
  for (const sp of endSpells) {
    if (!byCat[sp.category]) byCat[sp.category] = { count: 0, total: 0, min: Infinity, max: 0 };
    byCat[sp.category].count++;
    byCat[sp.category].total += sp.endurance;
    if (sp.endurance < byCat[sp.category].min) byCat[sp.category].min = sp.endurance;
    if (sp.endurance > byCat[sp.category].max) byCat[sp.category].max = sp.endurance;
  }
  for (const [cat, d] of Object.entries(byCat).sort((a, b) => b[1].count - a[1].count).slice(0, 12)) {
    lines.push(`| ${cat} | ${d.count} | ${Math.round(d.total / d.count)} | ${d.min} | ${d.max} |`);
  }

  lines.push('', `*${endSpells.length} endurance-cost abilities analyzed for ${CLASS_IDS[cid]}.*`);
  return lines.join('\n');
}

// Tool 274: Class spell book size comparison
export async function getClassSpellBookSizeComparison(): Promise<string> {
  await loadSpells();
  await loadSpellDescriptions();
  if (!spells) return 'Spell data not available.';

  const lines = ['# Class Spell Book Size Comparison', ''];
  lines.push('*Compares total spell counts, beneficial/detrimental ratios, and category diversity across all 16 classes.*', '');

  const classData: Record<number, { total: number; beneficial: number; detrimental: number; categories: Set<string>; maxLevel: number; byLevel: Record<number, number> }> = {};
  for (let i = 1; i <= 16; i++) classData[i] = { total: 0, beneficial: 0, detrimental: 0, categories: new Set(), maxLevel: 0, byLevel: {} };

  for (const [, spell] of spells) {
    if (spell.name === 'UNKNOWN DB STR' || spell.name.startsWith('*')) continue;
    const catId = parseInt(spell.fields[SF.CATEGORY]) || 0;
    const cat = spellCategories?.get(catId) || 'Unknown';
    const beneficial = spell.fields[SF.BENEFICIAL] === '1';

    for (let i = 1; i <= 16; i++) {
      const level = parseInt(spell.fields[SF.CLASS_LEVEL_START + i - 1]) || 255;
      if (level <= 0 || level >= 255) continue;
      classData[i].total++;
      if (beneficial) classData[i].beneficial++;
      else classData[i].detrimental++;
      classData[i].categories.add(cat);
      if (level > classData[i].maxLevel) classData[i].maxLevel = level;
      classData[i].byLevel[level] = (classData[i].byLevel[level] || 0) + 1;
    }
  }

  // Main comparison table
  lines.push('## Spell Book Size by Class', '');
  lines.push('| Rank | Class | Total | Beneficial | Detrimental | Categories | Max Level |');
  lines.push('|-----:|:------|------:|-----------:|------------:|-----------:|----------:|');
  const sorted = Object.entries(classData).sort((a, b) => b[1].total - a[1].total);
  for (let i = 0; i < sorted.length; i++) {
    const [cid, data] = sorted[i];
    lines.push(`| ${i + 1} | ${CLASS_IDS[parseInt(cid)]} | ${data.total} | ${data.beneficial} | ${data.detrimental} | ${data.categories.size} | ${data.maxLevel} |`);
  }

  // Statistics
  const totals = sorted.map(([, d]) => d.total);
  const avg = Math.round(totals.reduce((s, t) => s + t, 0) / totals.length);
  const max = totals[0];
  const min = totals[totals.length - 1];
  lines.push('', '## Statistics', '');
  lines.push(`- **Largest spell book:** ${CLASS_IDS[parseInt(sorted[0][0])]} (${max})`);
  lines.push(`- **Smallest spell book:** ${CLASS_IDS[parseInt(sorted[sorted.length - 1][0])]} (${min})`);
  lines.push(`- **Average:** ${avg}`);
  lines.push(`- **Spread:** ${max - min} spells (${((max / min - 1) * 100).toFixed(0)}% difference)`);

  // Level with most new spells per class
  lines.push('', '## Peak Spell Level per Class', '');
  lines.push('| Class | Peak Level | Spells at Peak |');
  lines.push('|:------|----------:|--------------:|');
  for (const [cid, data] of sorted) {
    let peakLevel = 0;
    let peakCount = 0;
    for (const [lvl, count] of Object.entries(data.byLevel)) {
      if (count > peakCount) { peakCount = count; peakLevel = parseInt(lvl); }
    }
    lines.push(`| ${CLASS_IDS[parseInt(cid)]} | ${peakLevel} | ${peakCount} |`);
  }

  // Category diversity ranking
  lines.push('', '## Category Diversity Ranking', '');
  lines.push('| Class | Unique Categories | Spells/Category |');
  lines.push('|:------|------------------:|----------------:|');
  const byCatDiv = Object.entries(classData).sort((a, b) => b[1].categories.size - a[1].categories.size);
  for (const [cid, data] of byCatDiv) {
    const spellsPerCat = (data.total / data.categories.size).toFixed(1);
    lines.push(`| ${CLASS_IDS[parseInt(cid)]} | ${data.categories.size} | ${spellsPerCat} |`);
  }

  lines.push('', '*Spell book sizes compared across all 16 classes.*');
  return lines.join('\n');
}

// Tool 275: Zone level overlap analysis
export async function getZoneLevelOverlapAnalysis(): Promise<string> {
  await loadZones();
  if (!zones || zones.size === 0) return 'Zone data not available.';

  const lines = ['# Zone Level Overlap Analysis', ''];
  lines.push('*Identifies level ranges with the most zone choices and finds zones that serve as alternatives to each other.*', '');

  // Build level -> zones mapping
  const levelZones: Record<number, { id: number; name: string; min: number; max: number }[]> = {};
  const zoneList: { id: number; name: string; min: number; max: number; span: number }[] = [];

  for (const [id, zone] of zones) {
    if (zone.levelMin <= 0 || zone.levelMax <= 0) continue;
    const effectiveMax = Math.min(zone.levelMax, 130);
    const span = effectiveMax - zone.levelMin + 1;
    zoneList.push({ id, name: zone.name, min: zone.levelMin, max: effectiveMax, span });
    for (let lvl = zone.levelMin; lvl <= effectiveMax; lvl++) {
      if (!levelZones[lvl]) levelZones[lvl] = [];
      levelZones[lvl].push({ id, name: zone.name, min: zone.levelMin, max: effectiveMax });
    }
  }

  if (zoneList.length === 0) return 'No zones with level ranges found.';

  lines.push(`- **Zones with level ranges:** ${zoneList.length}`);
  const levels = Object.keys(levelZones).map(Number).sort((a, b) => a - b);
  lines.push(`- **Level coverage:** ${levels[0]}–${levels[levels.length - 1]}`);

  // Zone choices per level
  lines.push('', '## Zone Choices per Level (Sampled)', '');
  lines.push('| Level | Zone Choices | Bar |');
  lines.push('|------:|------------:|:----|');
  let maxChoices = 0;
  for (const lvl of levels) {
    if (levelZones[lvl].length > maxChoices) maxChoices = levelZones[lvl].length;
  }
  for (let lvl = 1; lvl <= 130; lvl += 5) {
    const choices = levelZones[lvl]?.length || 0;
    const barLen = maxChoices > 0 ? Math.round((choices / maxChoices) * 30) : 0;
    lines.push(`| ${lvl} | ${choices} | ${'█'.repeat(barLen)} |`);
  }

  // Levels with most choices
  lines.push('', '## Levels with Most Zone Choices (Top 10)', '');
  lines.push('| Level | Zones Available |');
  lines.push('|------:|:----|');
  const sortedLevels = levels.sort((a, b) => (levelZones[b]?.length || 0) - (levelZones[a]?.length || 0));
  for (const lvl of sortedLevels.slice(0, 10)) {
    const names = levelZones[lvl].map(z => z.name).slice(0, 8).join(', ');
    const more = levelZones[lvl].length > 8 ? ` +${levelZones[lvl].length - 8} more` : '';
    lines.push(`| ${lvl} | ${names}${more} |`);
  }

  // Levels with fewest choices (bottlenecks)
  lines.push('', '## Leveling Bottlenecks (Fewest Choices)', '');
  lines.push('| Level | Zones |');
  lines.push('|------:|:------|');
  const sortedAsc = levels.filter(l => l <= 130).sort((a, b) => (levelZones[a]?.length || 0) - (levelZones[b]?.length || 0));
  for (const lvl of sortedAsc.slice(0, 10)) {
    const names = levelZones[lvl].map(z => z.name).join(', ');
    lines.push(`| ${lvl} | ${names} |`);
  }

  // Zone overlap analysis: find pairs of zones with most overlapping levels
  lines.push('', '## Most Overlapping Zone Pairs (Top 15)', '');
  lines.push('| Zone 1 | Zone 2 | Overlap Levels | Overlap % |');
  lines.push('|:-------|:-------|---------------:|----------:|');
  const overlaps: { z1: string; z2: string; overlap: number; pct: number }[] = [];
  for (let i = 0; i < Math.min(zoneList.length, 200); i++) {
    for (let j = i + 1; j < Math.min(zoneList.length, 200); j++) {
      const z1 = zoneList[i];
      const z2 = zoneList[j];
      const overlapMin = Math.max(z1.min, z2.min);
      const overlapMax = Math.min(z1.max, z2.max);
      if (overlapMin <= overlapMax) {
        const overlap = overlapMax - overlapMin + 1;
        const smallerSpan = Math.min(z1.span, z2.span);
        const pct = (overlap / smallerSpan) * 100;
        if (overlap >= 5) overlaps.push({ z1: z1.name, z2: z2.name, overlap, pct });
      }
    }
  }
  overlaps.sort((a, b) => b.overlap - a.overlap);
  for (const o of overlaps.slice(0, 15)) {
    lines.push(`| ${o.z1} | ${o.z2} | ${o.overlap} | ${o.pct.toFixed(0)}% |`);
  }

  // Widest and narrowest zones
  zoneList.sort((a, b) => b.span - a.span);
  lines.push('', '## Widest Level Ranges (Top 10)', '');
  lines.push('| Zone | Level Range | Span |');
  lines.push('|:-----|:------------|-----:|');
  for (const z of zoneList.slice(0, 10)) {
    lines.push(`| ${z.name} | ${z.min}–${z.max} | ${z.span} |`);
  }

  lines.push('', `*${zoneList.length} zones analyzed for level overlap.*`);
  return lines.join('\n');
}
